// ------------------------------------------------------------
//   oink oink.
// ------------------------------------------------------------

class HDImp:HDMOb{
	default{
		monster;
		species "DoomImp";
		damagefactor "thermal",0.66;
		deathsound "imp/death";
		seesound "imp/sight";
		painsound "imp/pain";
		activesound "imp/active";
		translation "64:72=50:71";
		obituary "%o was marinated by the imps.";
		hitobituary "%o was tenderized by the imps.";

		health 66;
		painchance 80;
		speed 14;
	}
	override void postbeginplay(){
		super.postbeginplay();
		A_Resize(frandom(0.9,1.1));
	}
	states{
	spawn:
		TROO ABCD 10{
			HealThing(8);
			if(!bambush){
				if(random(1,10)==1) setstatelabel("wander");
			}
			A_SetTics(randompick(4,10,24));
			A_HDLook();
		}loop;
	wander:
		TROO ABCD 6 A_MWander();
		TROO A 0{
			HealThing(10);
			if(random(1,3)==1) setstatelabel("spawn");
			else A_HDLook();
		}loop;
	see:
		TROO A 0{
			HealThing(4);
			A_MChaseThink();
			A_MChaseThinkSetState();
		}
	chase:
		TROO ABCD 4 A_MChase();
		TROO H 0 A_Jump(256,"see");
	melee:
		TROO EF 4 A_FaceTarget(60,60);
		TROO G 7 A_CustomMeleeAttack(random(4,20),"imp/melee","none","smallarms0",false);
		TROO F 6;
		TROO H 0 A_Jump(256,"see");
	missile:
		TROO ABCD 4{
			A_TurntoFace();
		}loop;
	shoot:
		TROO F 4;
	shoot2:
		TROO E 6{
			A_Strafe(2);
			if(
				accuracy==0 && random(1,3)==1
				&& distance3d(attacktarget)>128
			)setstatelabel("shoot3");
		}
		TROO G 1 A_StartLeadTarget();
		TROO G 6{
			if(random(0,1)==1)A_FaceLeadTarget(10);
			if(random(0,1)==1)A_ShootMissile("hdimpball",
				shootangle:angle+frandom(-2,2),shootpitch:pitch+frandom(-4,1));
			else A_ShootMissile("hdimpball",seeker:random(0,1));
		}
		TROO F 3{
			accuracy++;
			if(accuracy>=3 || random(1,3)==1){
				accuracy=0;
				setstatelabel("shootend");
				return;
			}
			A_Face(target,10,20);
		}
		goto shoot2;
	shoot3:
		TROO E 2{
			A_PlaySound(seesound);
			A_Strafe(1);
		}
		TROO EEE 6{
			A_SpawnItemEx("reverseimpballtail",4,24,44,
				vel.x+cos(angle),vel.y+sin(angle),vel.z-1,
				0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM);
		}
		TROO G 1 A_StartLeadTarget();
		TROO G 8{
			accuracy=0;
			if(random(0,1)==1)A_FaceLeadTarget(15);
			for (int i=0;i<2;i++){A_ShootMissile("hdimpball",-1,15,
				shootangle:angle+frandom(-5,5),shootpitch:pitch+frandom(-5,4),seeker:true);}
			A_ShootMissile("hdimpball",-1,16,seeker:false);
		}goto shootend;
	shootend:
		TROO F 3 A_Strafe(2);
		TROO H 0 A_Jump(256,"see");
	coverfire:
		TROO F random(3,7) A_Strafe(1);
	cover2:
		TROO E random(5,7){
			if(target && checksight(target))
			setstatelabel("see");
		}
		TROO G 6{
			if(random(0,1)==1)A_ShootMissile("hdimpball",
				shootangle:angle+frandom(-2,2),shootpitch:pitch+frandom(-2,1));
			else A_ShootMissile("hdimpball",seeker:random(0,1));
		}
		TROO F 3{
			accuracy++;
			if(accuracy>=3 || random(1,3)==1){
				accuracy=0;
				setstatelabel("shootend");
				return;
			}
		}
		goto cover2;
	hold:
		TROO AAAAAABBBBBB 1{
			A_MChaseThink();
			if(target && checksight(target))
			A_MChaseThinkSetState();
		}
		TROO H 0 A_Jump(256,"see");



	pain.thermal:
		TROO H 0 HealThing(2);
	pain:
		TROO H 3{
			bnodropoff=false;
			A_GiveInventory("HDFireEnder",3);
		}
		TROO H 3 A_Pain();
		goto missile;
	death:
		TROO I 4;
		TROO J 4 A_HDNoBlocking();
		TROO J 1{
			A_Bleed();
			return (A_JumpIf(vel.z==0,1));
		}wait;
		TROO KKL 2 A_Bleed();
	dead:
		TROO L 2 A_Bleed();
		TROO M 2 canraise A_JumpIf(vel.z!=0,"dead");
		wait;
	xdeath:
		TROO N 4;
		TROO O 1 A_JumpIf(getzat()>=pos.z,1);
		wait;
		TROO P 4 A_PlaySound("misc/gibbed");
		TROO PQRST 4;
		TROO U -1;
	raise:
		"----" A 5;
		TROO M 5 {if(gibbed) setstatelabel("ungib");else A_PlaySound("misc/gibbed");}
		TROO LKJIH 5;
		goto spawn;
	ungib:
		TROO U 10 {gibbed=false;bcorpse=false;A_PlaySound("misc/gibbed");}
		TROO TSRQPON 4 A_Bleed();
		TROO H 0 A_Die();
		goto xdeath;
	}
}

class HDHImp:HDImp{
	actor healtarget;int healseektimer;double htd;
	default{
		translation "64:77=50:76";
		scale 0.8;
		health 100;
		speed 14;
		obituary "%o could feel the schadenfreude.";
		hitobituary "%o said I want a second opinion, so the imps said okay you're ugly too.";
	}
	void A_MChaseHealerPostThink(int dist=512,int newhealtimer=20){
		if(!healtarget){ //if no healtarget, look for one
			int newdist=dist;
			blockthingsiterator itt=blockthingsiterator.create(self,dist);
			while(itt.Next()){
				if(itt.thing.bcorpse && itt.thing.findstate("raise",true) && checksight(itt.thing)){
					newdist=distance3d(itt.thing);
					if(newdist+itt.thing.radius<=dist){
						dist=newdist;
						healtarget=itt.thing;
						healseektimer=newhealtimer;
					}
				}
			}
		}else{
			htd=distance2d(healtarget);

			//clear healtarget if healtarget is alive or too far away, or feartarget too close
			if(healtarget.health>0) healtarget=null;  
			else if(healseektimer<1) healtarget=null;
			else if(htd>512) healtarget=null;
			else if(feartarget && distance2d(feartarget)<128) healtarget=null;

			//and if none of that applies, set the movetarget
			else{
				if(htd<=healtarget.radius+self.radius && checksight(healtarget)){
					setstatelabel("startheal");
				}
				else{
					movetarget.setxyz(healtarget.pos);
					healseektimer--;
					decision&=HDMCT_COVERFIRE;
					decision=HDMCT_ADVANCE;
				}
			}
		}
	}
	states{
	see:
		TROO A 0{
			HealThing(8);
			if(!healtarget || htd>320) A_MChaseThink();
			A_MChaseHealerPostThink();
			if(!healtarget)A_MChaseThinkSetState();
		}
		TROO ABCD 4{
			if(healtarget){
				htd=distance2d(healtarget);
				if(htd<=healtarget.radius+self.radius && checksight(healtarget))
				setstatelabel("startheal");
			}
			A_MChase();
		}loop;
	startheal:
		TROO E 2{
			vel.xy*=0.7;
			if(!healtarget){
				setstatelabel("see");
				return;
			}
			A_Face(healtarget);
			A_PlaySound(seesound);
		}
		TROO EEE 2{
			vel.xy*=0.7;
			if(!healtarget){
				setstatelabel("see");
				return;
			}
			A_Face(healtarget);
		}
		TROO HAHAHA 3;
		TROO H 6{
			if(!healtarget) return;
			if(!healtarget.bcorpse) return;
			actor masbak=master;
			master=healtarget;
			A_RaiseMaster(RF_TRANSFERFRIENDLINESS|RF_NOCHECKPOSITION);
			master=masbak;
			healtarget.bfriendly=self.bfriendly;
			healtarget=null;
			HealThing(12);
		}
		TROO HAHA 3;
		TROO H 0 A_Jump(256,"see");
	shoot:
		TROO F 0 A_Jump(96,"shoot3");
		goto super::shoot;
	shoot3:
		TROO E 2{
			A_PlaySound(seesound);
		}
		TROO EEE 6{
			A_SpawnItemEx("reverseimpballtail",4,24,44,vel.x+cos(angle),vel.y+sin(angle),vel.z-1,0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM);
		}
		TROO G 8{
			A_ShootMissile("hdhimpball",-1,12,seeker:false);
		}goto shootend;
	}
}

class HDMImp:HDImp{
	int fatigue;
	default{
		scale 1.1;speed 13;
		translation "none";
	}
	override void A_MChaseThink(int flankdistance=128,int nofear=false){
		super.A_MChaseThink(256,nofear);
		if(fatigue>8)decision&=HDMCT_AIMSHOOT;
		if(fatigue>4)decision&=HDMCT_COVERFIRE;
		if(fatigue>0)fatigue--;
	}
	states{
	spawn:
		TROO A 0 {if(fatigue>0)fatigue-=6;}
		goto super::spawn;
	podshot:
		TROO HHHHHH 3 {
			if(vel.z<0) vel.z=random(3,4);
			else vel.z+=3;
			vel.xy*=0.6;
		}
		TROO HHH 6{
			A_FaceTarget(1,4);
			vel.z*=0.1;
			fatigue+=9;
			actor a;
			vector3 b=(
				cos(angle+140),
				sin(angle+140),
				0.1
			)*3;
			a=spawn("HDDMImpBall",pos+(0,0,32)+b*8);a.target=self;a.tracer=target;a.vel=b;
			b=(
				cos(angle-140),
				sin(angle-140),
				0.1
			)*3;
			a=spawn("HDDMImpBall",pos+(0,0,32)+b*8);a.target=self;a.tracer=target;a.vel=b;
			b=(
				cos(angle+120),
				sin(angle+120),
				-0.2
			)*2;
			a=spawn("HDDMImpBall",pos+(0,0,30)+b*6);a.target=self;a.tracer=target;a.vel=b;
			b=(
				cos(angle-120),
				sin(angle-120),
				-0.2
			)*2;
			a=spawn("HDDMImpBall",pos+(0,0,30)+b*6);a.target=self;a.tracer=target;a.vel=b;
			b=(
				cos(angle+160),
				sin(angle+160),
				+0.3
			)*2;
			a=spawn("HDDMImpBall",pos+(0,0,34)+b*4);a.target=self;a.tracer=target;a.vel=b;
			b=(
				cos(angle-160),
				sin(angle-160),
				+0.3
			)*2;
			a=spawn("HDDMImpBall",pos+(0,0,34)+b*4);a.target=self;a.tracer=target;a.vel=b;
		}
		TROO HHHHHH 3 {
			if(vel.z<0) vel.z=2;
			else vel.z+=2;
		}
		goto shootend;
	shoot:
		TROO F 0{
			if(pos.z==floorz && ceilingz-floorz>128 && random(1,3)==1) setstatelabel("podshot");
		}
	coverfire:
		TROO F 5 A_Strafe(2);
		TROO E 6 A_Jump(66,"shoot3");
		TROO G 6{
			fatigue+=6;
			A_ShootMissile("hdmimpball",seeker:true);
		}
		goto shootend;
	shoot3:
		TROO E 2{
			A_PlaySound(seesound);
			A_Strafe(2);
		}
		TROO EEE 6{
			A_SpawnItemEx("reverseimpballtail",4,24,44,
				vel.x+cos(angle),vel.y+sin(angle),vel.z-1,
				0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM);
		}
		TROO G 1{
			if(random(1,3)==1 || (target && !checksight(target)) ) setstatelabel("glyphattack");
			else A_StartLeadTarget();
		}
		TROO G 8{
			fatigue+=9;
			if(random(0,1)==1)A_FaceLeadTarget(15);
			for (int i=0;i<6;i++){A_ShootMissile("hdimpball",-1,shootspeed:random(10,30),
				shootangle:angle-18+i*3,shootpitch:pitch+frandom(-3,2),seeker:true);}
			A_ShootMissile("hdmimpball",-1,24,seeker:false);
		}goto shootend;
	glyphattack:
		TROO F 3;
		TROO G 10{
			A_PlaySound(seesound);
			fatigue+=14;
			actor a;
			vector3 glyphadd;
			for (int i=0;i<5;i++){
				if(i==1) glyphadd.xy=(-96,96);
				else if(i==2) glyphadd.xy=(-96,-96);
				else if(i==3) glyphadd.xy=(96,-96);
				else if(i==4) glyphadd.xy=(96,96);
				a=spawn("MageImpGlyph",lasttargetpos+glyphadd);
				if(!i) a.A_PlaySound(self.seesound);
				a.tracer=target;a.target=self;
				a.setz(a.floorz);
			}
		}
		goto shootend;
	}
}




// ------------------------------------------------------------
//   Balls.
// ------------------------------------------------------------

class HDImpBallTail:HDTail{
	default{
		renderstyle "subtract";
	}
	states{
	spawn:
		BAL1 FGH 2;
		loop;
	}
}
class HDImpBall:HDFireball{
	default{
		missiletype "HDImpBallTail";
		decal "scorch";
		seesound "imp/attack";deathsound "imp/shotx";activesound "misc/firecrkl";
		damagefunction(random(1,10));damagetype "thermal";
	}
	states{
	spawn:
		BAL1 ABA 2 bright nodelay A_Tail();
		BAL1 A 0{
			if(target.target) tracer=target.target;
		}
		BAL1 BABAB 2 bright;
	see:
		BAL1 ABA 2 bright A_FBFloat();
		BAL1 B 2 bright{
			if(random(0,1)) A_SimpleSeek(128,true);
		}
		loop;
	death:
		BAL1 C 3 bright{
			spawn("HDSmoke",pos);
			A_Scream();
			vel.z+=1;
			if(random(1,3)==1) return;
			if(blockingmobj){
				if(
					blockingmobj.species==target.species
					&& !target.bdoharmspecies
				)target=null;
				A_Immolate(blockingmobj,self.target,random(0,4)*10);
			}else{
				actor a=spawn("idledummy",pos+HDMath.ScaleVector(oldvel,radius*0.7));
				a.a_setsize(4,4);
				A_Immolate(a,self.target,random(1,6)*10);
			}
		}
		BAL1 D 3 bright;
		BAL1 EEE 1 bright{
			alpha*=0.9;
			vel.z-=0.5;
		}stop;
	}
}


class HDHImpBallTail:HDImpBallTail{
	default{
		renderstyle "add";
		radius 1.2;
	}
}
class HDHImpBall:HDImpBall{
	default{
		+noblood -noblockmap +shootable;
		height 14;radius 12;health 1;speed 7;
		scale 1.6;missiletype "HDHImpBallTail";
		damagefactor "thermal",0;
	}
	states{
	pain:
	death:
		BAL1 C 0 bright{
			A_Scream();
			vel.z+=1;
			if(blockingmobj){
				if(
					blockingmobj.species==target.species
					&& !target.bdoharmspecies
				)target=null;
				A_Immolate(blockingmobj,self.target,random(0,4)*10);
			}else{
				actor a=spawn("idledummy",pos+HDMath.ScaleVector(oldvel,radius*0.7));
				a.a_setsize(4,4);
			}
			A_Blast(
				immolateradius:64,
				immolateamount:random(1,3)*4,
				hurtspecies:false
			);
			A_GiveInventory("HDFireEnder",999);
			bshootable=true;
			bmissile=false;
		}
		BAL1 CCCDDDEEEE 1 bright{
			A_SpawnChunks("HDSmoke",3,3,6);
			alpha*=0.9;
		}
		TNT1 A 0{
			bshootable=false;bnointeraction=true;
		}
		TNT1 AAAAAAAAAAAAA 3 bright{
			A_SpawnChunks("HDSmoke",3,3,6);
			alpha*=0.9;
		}stop;
	}
}


class HDMImpBallTail:HDTail{
	default{
		scale 2.0;radius 1.6;
		speed 0.1;alpha 2.0;
	}
	states{
	spawn:
		BAL1 AB 3;
		loop;
	}
}
class HDMImpBall:HDImpBall{
	default{
		missiletype "HDMImpBallTail";
		damagefunction(random(4,20));
		speed 14;
		scale 1.4;
	}
	states{
	spawn:
		BAL1 A 0 nodelay{
			A_PlaySound("vile/firestrt",CHAN_AUTO);
			if(target.target) tracer=target.target;
		}
		BAL1 ABABA 2 bright A_Tail();
		BAL1 BAB 2 bright;
	see:
		BAL1 AB 2 bright A_FBFloat();
		BAL1 B 0 A_SimpleSeek(1024,true);
		loop;
	death:
		BAL1 C 0 bright{
			A_Scream();
			vel.z+=1;
			if(blockingmobj){
				if(
					blockingmobj.species==target.species
					&& !target.bdoharmspecies
				)target=null;
				A_Immolate(blockingmobj,self.target,random(4,8)*8);
			}else{
				actor a=spawn("idledummy",pos+HDMath.ScaleVector(oldvel,radius*0.7));
				a.a_setsize(4,4);
			}
			A_Blast(
				immolateradius:32,
				immolateamount:random(3,6)*6,
				hurtspecies:false
			);
		}
		BAL1 CCDDEE 2 bright{
			A_SpawnChunks("HDSmoke",2,1,3);
			alpha*=0.8;
		}stop;
	}
}
class MageImpGlyph:IdleDummy{
	default{
		+flatsprite +bright
		renderstyle "add";
		alpha 0;
	}
	states{
	spawn:
		BAL1 A 0 nodelay{
			A_PlaySound("putto/sight");
		}
		BAL1 CDECDEC random(1,4){angle+=20;alpha+=0.1;}
		BAL1 DECDECDECDE 2{angle+=20;alpha+=0.1;}
		BAL1 A 0{
			actor a=spawn("HDMImpBall",pos+(0,0,1));
			a.target=target;a.tracer=tracer;
			a.vel.z+=6;
			a=spawn("HDSmoke",pos);
			a.vel.z+=clamp((ceilingz-floorz)*0.001,0.01,3);
			A_PlaySound("vile/firestrt");
		}
		BAL1 CDECCDDEEE 3{
			angle+=20;
			alpha*=0.9;
			scale*=1.05;
		}
		stop;
	}
}
class HDDMImpBall:HDImpBall{
	vector3 forward;
	override void postbeginplay(){
		super.postbeginplay();
		A_PlaySound("vile/firestrt",CHAN_AUTO);
		if(target){
			forward=(
				cos(target.angle)*cos(target.pitch),
				sin(target.angle)*cos(target.pitch),
				-sin(target.pitch)
			)*speed;
		}
		if(tracer) A_FaceTracer(2,2);
	}
	states{
	spawn:
		BAL1 AB 2 nodelay{
			A_Tail();
			vel+=forward;
		}
		BAL1 ABA 2 A_Tail();
		BAL1 BABAB 2;
		goto see;
	}
}
