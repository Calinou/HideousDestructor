//-------------------------------------------------
// Ladder
//-------------------------------------------------

//show where the ladder is hanging
//no it doesn't swing, math is hard :(
class hdladdersection:idledummy{
	default{
		+wallsprite
	}
	double proportion;
	override void postbeginplay(){
		super.postbeginplay();
		//master is top, target is bottom
		if(!master||!target){
			destroy();return;
		}
		proportion=target.pos.z-master.pos.z;
		if(!proportion){
			destroy();return;
		}
		proportion=abs(master.pos.z-pos.z)/proportion;
	}
	override void tick(){
		if(!master||!target){
			destroy();return;
		}
		double mpz=master.pos.z;
		setz(mpz+(mpz-target.pos.z)*proportion-12);
		nexttic();
	}
	states{
	spawn:
		LADD B -1;
	}
}
class hdladdertop:hdactor{
	default{
		+missile //testing
		+flatsprite
		height 1;radius 10;
	}
	states{
	spawn:
		LADD A -1;
	}
	override void tick(){
		setz(floorz+4);
		nexttic();
	}
	override void postbeginplay(){
		super.postbeginplay();
		pitch=18;
		bmissile=false;master=target;
		setz(floorz);
		fcheckposition tm;
		vector2 mvlast=pos.xy;
		vector2 mv=angletovector(angle,2);
		for(int i=0;i<20;i++){
			mvlast+=mv;
			checkmove(mvlast,PCM_DROPOFF|PCM_NOACTORS,tm);

			//found a place for the ladder to hang down
			int htdiff=clamp(floorz-tm.floorz,0,LADDER_MAX);
			if(htdiff){
				A_PlaySound("misc/ladder");

				//spawn the ladder end
				target=spawn("hdladderbottom",tm.pos);
				target.target=self;
				target.master=master;
				target.angle=angle;

				vector2 mv2=mv*0.02;

				//spawn the ladder sections
				int sectionlength=min(htdiff,LADDER_MAX)/LADDER_SECTIONS;
				for(i=0;i<LADDER_SECTIONS;i++){
					vector3 newpos=tm.pos+(mv2,-sectionlength)*i;
					actor sss=spawn("hdladdersection",newpos);
					sss.master=self;sss.target=target;sss.angle=angle;
					sss.translation=master.translation;
					target.setorigin(newpos,true);
				}

				//reposition the thing
				setorigin((target.pos.xy-mv*radius,tm.pos.z),true);

				return;
			}
		}

		//if there's no lower floor to drop the ladder, abort.
		if(master){
			master.A_Log("No point hanging a ladder here.",true);
			master.A_GiveInventory("HDLadder");
		}else{
			actor hdl=spawn("HDLadder",pos);
			hdl.A_PlaySound("misc/ladder");
		}
		destroy();
	}
}
enum ladderfigures{
	LADDER_MAX=300,
	LADDER_SECTIONS=LADDER_MAX/12,
}
class hdladderbottom:hdactor{
	default{
		+nogravity +wallsprite
		height 56;radius 10;
	}
	actor currentuser;
	double currentuserz;
	override bool used(actor user){
		double upz=user.pos.z;
		if(
			upz>target.pos.z+24
			||upz+user.height*1.3<pos.z
		)return false;
		if(currentuser){
			disengageladder();
			return false;
		}
		currentuser=user;
		currentuser.vel.z+=1;
		currentuserz=user.pos.z;
		currentuser.A_Log("You climb the ladder.",true);
		return true;
	}
	void disengageladder(bool message=true){
		if(!currentuser)return;
		if(playerpawn(currentuser))playerpawn(currentuser).viewbob=1.;
		if(message)currentuser.A_Log("Ladder disengaged.",true);
		currentuser=null;
	}
	override void ondestroy(){
		if(playerpawn(currentuser))playerpawn(currentuser).viewbob=1.;
		super.ondestroy();
	}
	override void tick(){
		if(!target){destroy();return;}
		setz(clamp(pos.z,max(target.pos.z-LADDER_MAX,getzat()),target.pos.z+LADDER_MAX));

		if(currentuser){
			if(currentuser.health<1){disengageladder(false);return;}


			//check if facing the ladder
			bool facing=abs(
				deltaangle(
					angleto(currentuser,true),
					currentuser.angle
				)
			)>100;

			//checks when above ladder
			if(
				currentuser.pos.z>target.pos.z-16
			){
				//throw in some use of controls still
				if(currentuser.player){
					int bt=currentuser.player.cmd.buttons;
					if(
						bt&BT_JUMP
						||bt&BT_SPEED
						||(!facing&&bt&BT_USE)
					){
						disengageladder();
						if(bt&BT_CROUCH&&bt&BT_JUMP){
							actor hdl=spawn("HDLadder",target.pos);
							hdl.A_PlaySound("misc/ladder");
							target.destroy();
							if(self)destroy();
						}
						return;
					}
					if(currentuser.floorz<currentuser.pos.z){
						int fm=currentuser.player.cmd.forwardmove/6000;
						int sm=currentuser.player.cmd.sidemove/6000;
						if(fm||sm)currentuser.trymove(
							currentuser.pos.xy
							+angletovector(currentuser.angle,fm)
							+angletovector(currentuser.angle-90,sm),
							true
						);
					}
				}
				if(target.distance2d(currentuser)>40){
					vector2 tp=pos.xy;
					currentuser.setorigin((
						clamp(currentuser.pos.x,
							tp.x-40,
							tp.x+40
						),
						clamp(currentuser.pos.y,
							tp.y-40,
							tp.y+40
						),
						min(currentuser.pos.z,target.pos.z+24)
					),true);
				}
				return;
			}
			currentuser.vel.xy*=0.7;
			currentuser.vel.z=0;

			//climbing interface
			if(currentuser.player){
				double fm=currentuser.player.cmd.forwardmove*0.000125;
				double sm=currentuser.player.cmd.sidemove*0.000125;
				int bt=currentuser.player.cmd.buttons;

				//barehanded and descending are faster
				if(facing){
					if(!sm&&fm<0)fm*=1.5;
					weapon wp=currentuser.player.readyweapon;
					if(wp is "Ring"||wp is "NullWeapon"){
						sm*=2;fm*=2;
					}
				}else fm*=-1;

				if(currentuser.countinv("PowerStrength"))fm*=1.8;
				if(hdplayerpawn(currentuser)&&hdplayerpawn(currentuser).stunned)
					fm*=0.2;

				//apply climbing
				currentuserz+=fm;
				if(sm)currentuser.trymove(
					currentuser.pos.xy+angletovector(currentuser.angle-90,sm),
					true
				);
				if(fm||sm)playerpawn(currentuser).viewbob=1;
					else playerpawn(currentuser).viewbob=0.;

				//jump also disengages
				//crouch+jump to remove the rope
				if(bt){
					if(bt&BT_JUMP){
						vector3 vl=(
							(currentuser.pos.xy-pos.xy).unit()*3,
							4
						);
						if(currentuser.countinv("PowerStrength"))vl*=2.2;
						currentuser.vel+=vl;

						if(bt&BT_CROUCH){
							currentuser.A_Log("Ladder taken down.",true);

							actor hdl=spawn("HDLadder",target.pos);
							hdl.A_PlaySound("misc/ladder");
							hdl.vel.xy=vl.xy;

							target.destroy();
							if(self)destroy();
							return;
						}else disengageladder();
					}else if(!facing&&bt&BT_USE)disengageladder();
				}
			}
			if(!currentuser)return;

			currentuserz=clamp(currentuserz,
				pos.z-currentuser.height*1.3,//currentuser.floorz,
				currentuser.ceilingz-currentuser.height
			);
			currentuser.setorigin((
				clamp(currentuser.pos.x,
					pos.x-16,
					pos.x+16
				),
				clamp(currentuser.pos.y,
					pos.y-16,
					pos.y+16
				),
				currentuserz
			),true);
		}
		nexttic();
	}
	states{
	spawn:
		LADD B -1;wait;
	}
}
class HDLadder:HDPickup{
	default{
		inventory.icon "LADDA0";
		inventory.pickupmessage "Picked up a ladder.";
		height 24;radius 12;
	}
	states{
	spawn:
		LADD A -1;
	use:
		TNT1 A 0{
			actor aaa;int bbb;
			[bbb,aaa]=A_SpawnItemEx(
				"HDLadderTop",16*cos(pitch),0,48-16*sin(pitch),
				flags:SXF_NOCHECKPOSITION|SXF_SETTARGET
			);if(!aaa)return;

			//only face player if above player's height - otherwise why not just mantle?
			if(aaa.floorz>pos.z+height){
				aaa.angle+=180;
			}
		}stop;
	}
}



