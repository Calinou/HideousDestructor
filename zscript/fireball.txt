// ------------------------------------------------------------
// Fireball
// a pocket of almost-lighter-than-air hot charged gas,
// held together by magic and capable of propelling itself
// ------------------------------------------------------------

//persistent tail actor that need not be spawned constantly
class HDFireballTail:IdleDummy{
	default{
		+forcexybillboard +rollsprite +rollcenter +bright +noclip
		renderstyle "add";
		speed -0.3;height 1.0;radius 0.6;deathheight 0.7;friction 1.1;
	}
	override void tick(){
		if(!master){
			destroy();return;
		}
		if(globalfreeze||level.Frozen){
			clearinterpolation();
			return;
		}
		if(alpha<0.3){
			setxyz(master.pos);
			vel=master.vel*speed+(frandom(-0.1,0.1),frandom(-0.1,0.1),frandom(0.5,1));
			alpha=height;
			scale.x=radius;scale.y=radius;
			roll=random(0,7)*45;
		}else{
			alpha*=deathheight;
			scale*=friction;
		}
		trymove(self.pos.xy+vel.xy,true);
		addz(vel.z,true);
		nexttic();
	}
}

//damage would be balefire, electro, radioactivity or heat/immolation
class HDFireball:HDActor{
	vector3 oldvel;
	vector3 frac;
	int fracc;
	double seekspeed;
	double zat;
	double grav;
	default{
		+missile +seekermissile +noblockmap +dropoff +activateimpact +activatepcross +hittracer
		+forcexybillboard +rollsprite +rollcenter +bright

		renderstyle "add";
		radius 4;height 4;speed 10;gravity 0.05;deathheight 24;
		damagetype "thermal";damagefunction(1);

		seesound "imp/attack";deathsound "imp/shotx";
	}
	override void postbeginplay(){
		super.postbeginplay();
		seekspeed=speed*0.0618;
		grav=getgravity();
		fracc=speed/radius;
		frac=vel/fracc;
		A_PlaySound(seesound,CHAN_BODY);
	}
	bool A_FBSeek(
		int seekradius=256,
		bool inlosonly=true
	){
		if(!tracer)return false;
		vector3 totracer;
		if(pos.z>tracer.pos.z+tracer.height)totracer.z=0;
			else totracer.z=tracer.height;
		totracer+=tracer.pos-self.pos;
		double disttotracer=distance2d(tracer);
		if(
			(!inlosonly || checksight(tracer))
			&&
			(disttotracer<seekradius)
		){
			totracer=totracer.unit()*seekspeed;
			vel+=totracer;
			return true;
		}
		return false;
	}
	void A_FBFloat(
		double jitter=0.02
	){
		if(jitter){
			jitter*=radius;
			vel+=(
				frandom(-jitter,jitter),
				frandom(-jitter,jitter),
				frandom(-jitter,jitter)
			);
		}
		zat=pos.z-floorz;
		if(zat<deathheight&&vel.z<0)vel.z+=(deathheight-zat)*0.03;
	}
	void A_FBTail(){
		if(!missilename) return;
		actor a=spawn(missilename,pos);
		a.master=self;a.vel=self.vel*0.9;
	}
	override void Tick(){
		if(globalfreeze||level.frozen){
			clearinterpolation();
			return;
		}
		if(!bmissile){
			//I don't anticipate any use other than death state...
			trymove(pos.xy+vel.xy,true);
			if(pos.z<floorz)setz(floorz);
			else if(pos.z+height>ceilingz)setz(ceilingz-height);
			else addz(vel.z,true);
			vel*=0.9;
			nexttic();
			return;
		}
		if(vel==(0,0,0)) vel.x=minvel;

		//update frac
		if(oldvel!=vel){
			oldvel=vel;
			fracc=max(vel.length()/radius,1);
			frac=vel/fracc;
		}

		//the iterator
		for(int i=0;i<fracc;i++){
			fcheckposition tm;

			//hit something while moving horizontally
			if(!trymove(pos.xy+frac.xy,true,true,tm)){
				if(!bSkyExplode){
					let l = tm.ceilingline;
					if (BlockingLine != NULL && BlockingLine.special == Line_Horizon){
						destroy();
						return;
					}
				}
				if(!target)target=master;
				explodemissile(BlockingLine,BlockingMobj);
				return;
			}
			addz(frac.z,true);

			//check skyfloor first before usual
			if(
				!bSkyExplode
				&& floorpic==skyflatnum
				&& pos.z<floorz
			){
				destroy();
				return;
			}else if(pos.z<floorz){
				setz(floorz);
				hitfloor();
				explodemissile(null,null);
				return;
			}

			//by the time it comes back down it would have dissipated!
			//(this rationalization is subject to change)
			if(
				!bSkyExplode
				&& ceilingpic==skyflatnum
				&& pos.z+height>ceilingz
			){
				destroy();
				return;
			}else if(pos.z+height>ceilingz){
				setz(ceilingz-height);
				explodemissile(null,null);
				return;
			}
		}
		vel.z-=grav;
		nexttic();
	}
}



class dimpbd:hdfireballtail{
	default{
		translation "ice";
		renderstyle "subtract";
		deathheight 0.9;
	}
	states{
	spawn:
		BAL1 CDE 5{
			roll=random(0,359);
			scale.x*=randompick(-1,1);
		}loop;
	}
}
class dimpb:hdfireball{
	default{
		missiletype "dimpbd";
		damagetype "thermal";
		decal "scorch";
	}
	states{
	spawn:
		BAL1 ABAB 3 A_FBTail();
	spawn2:
		BAL1 AB 3 {if(!A_FBSeek())A_FBFloat();}
		loop;
	death:
		BAL1 A 0{
			if(!blockingmobj)A_SpawnChunks("HDSmokeChunk",2,frandom(2,4));
			A_Immolate(blockingmobj,target,random(25,35));
		}
		BAL1 CDE 4;
		stop;
	}
}
class dimp:doomimp{
	vector2 lead1;
	vector2 lead2;
	states{
	missile:
		TROO EE 6 A_FaceTarget(60,60);
		TROO E 4 A_FaceTarget(20,20);
		TROO F 2 A_FaceTarget(20,20);
		TROO F 1{
			A_FaceTarget(20,20);
			lead1=(angle,pitch);
		}
		TROO F 1{
			A_FaceTarget(20,20);
			lead2=(angle,pitch);
		}
		TROO G 10{
			if(target){
				double dist=distance2d(target);
				pitch-=dist*0.01;
				pitch-=(lead2.y-lead1.y)*dist*0.02;
				angle+=(lead2.x-lead1.x)*dist*frandom(0,0.06);
			}
			actor a;bool b;
			[b,a]=A_SpawnItemEx("dimpb",0,0,32,cos(pitch)*12,0,sin(-pitch)*12,0,SXF_SETTARGET);
			a.tracer=target;
		}
		goto see;
	}
}




