// ------------------------------------------------------------
// Nice movement your objects have there.
// Shame if something happened to them.
// ------------------------------------------------------------

//general corpse-gibbing
class SawGib:InventoryFlag{
	default{
		inventory.maxamount int.MAX;
	}
	override void attachtoowner(actor user){
		super.attachtoowner(user);
		actor o=owner;
		if(owner){
			stamina=max(o.gibhealth,o.spawnhealth());
		}else goawayanddie();
	}
	override void doeffect(){
		if(bmissileevenmore)return;
		if(amount>stamina){
			bmissileevenmore=true;
			actor o=owner;
			if(
				!owner.bcorpse
				||!owner.bshootable
				||owner.health>0
				||!o.findstate("xdeath",true)
			)goawayanddie();
			else{
				o.bshootable=false;
				//use the old death state first
				if(o.findstate("XDeathBrewtleLulz"))o.setstatelabel("XDeathBrewtleLulz");else
				if(o.findstate("XXDeath"))o.setstatelabel("XXDeath");else
				o.setstatelabel("xdeath");
			}
		}
	}
}

//A generic mob controller.
//Stick this onto an actor for all sorts of fun effects!
class HDMobAI:Inventory{
	override void detachfromowner(){
		if(feartarget)feartarget.destroy();
		if(movetarget)movetarget.destroy();
		super.detachfromowner();
	}
	override void doeffect(){
		if(!owner||owner.health<1){
			if(feartarget)feartarget.destroy();
			if(movetarget)movetarget.destroy();
			destroy();
		}
	}

	actor feartarget;
	actor movetarget;

	//consolidate diversification
	static void resize(actor caller,double minscl=0.9,double maxscl=1.,int minhealth=0){
		double scl=frandom(minscl,maxscl);
		caller.scale*=scl;
		caller.mass*=scl;
		caller.speed*=scl;
		caller.meleerange*=scl;
		caller.A_SetSize(caller.radius*scl,caller.height*scl);
		if(minhealth<1)caller.health*=max(scl,1);else caller.health=max(caller.health*scl,1);
	}

	//taking all the same flags as A_LookEx
	static void look(
		actor caller,
		int flags=0,
		float minseedist=0,
		float maxseedist=0,
		float maxheardist=0,
		double fov=0,
		statelabel label="see",
		int soundchance=40
	){
		caller.A_LookEx(flags,minseedist,maxseedist,maxheardist,fov,label);
		if(!caller.bambush)caller.angle+=random(-10,10);
		if(!random(1,soundchance))caller.A_PlaySound(caller.activesound);
	}

	//smooth chase
	static void Chase(actor caller,actor movetarget=null,bool res=false,bool flee=true){
		if(caller.A_CheckBlock("null")){
			caller.A_Wander();
			return;
		}
		actor attacktarget=caller.target;
		if(!attacktarget||attacktarget.health<random(-5,1)){
			caller.target=null;
			caller.setstatelabel("spawn");
			return;
		}
		if(!movetarget)movetarget=attacktarget;

		//call A_Chase once for targeting purposes
		if(caller.checksight(attacktarget)){
			if(
				caller.findstate("melee")
				&&attacktarget.distance3d(caller)<caller.meleerange
			){
				caller.setstatelabel("melee");
				return;
			}else if(
				caller.findstate("missile")
				&&random(0,255)<caller.minmissilechance
				&&(
					!caller.maxtargetrange||
					attacktarget.distance3d(caller)<caller.maxtargetrange
				)
			){
				caller.setstatelabel("missile");
				return;
			}
		}

		//remember original position, etc.
		vector3 pg=caller.pos;
		bool fraid=caller.bfrightened;

		//chase the move target and record the resulting position
		caller.target=movetarget;
		caller.bfrightened=flee;
		caller.maxtargetrange=0;
		caller.A_Chase(flags:CHF_NODIRECTIONTURN|CHF_NOPOSTATTACKTURN|(res?CHF_RESURRECT:0));
		vector3 pp=caller.pos;

		//reset target and fear
		caller.target=attacktarget;
		caller.bfrightened=fraid;

		if(!caller.bfloat && caller.floorz<caller.pos.z)return; //abort if can't propel caller
		caller.vel.xy*=0.7; //slow down

		//reset position and move in chase direction
		if(pp!=pg){
			if(hd_debug){
				caller.SetOrigin(pg,false);
				if(caller.bfloat){
					caller.vel+=(pp-pg)*0.2;
					if(caller.pos.z-attacktarget.pos.z<attacktarget.height)
						caller.vel.z+=frandom(0,0.1); //floaty death from above
				}else{
					caller.vel.xy+=(pp.xy-pg.xy)*0.16;
				}
			}else{
				caller.vel+=(pp-pg).unit()*0.01;
			}
		}

		//face appropriate direction
		if(caller.distance3d(attacktarget)<caller.meleerange*2)caller.A_FaceTarget(10,10);
		else caller.A_FaceMovementDirection(5,40);
	}

	//check if shot is clear
	//hdmobai.tryshoot(self,pradius:6,pheight:6)
	static bool TryShoot(
		actor caller,
		double shootheight=-1,
		int range=256,
		double pradius=0,
		double pheight=0
	){
		if(!caller.target)return false;
		if(shootheight<0)shootheight=caller.height-6;
		actor a;int b;
		int bottomdist;int topdist;int leftdist;int rightdist;
		vector3 oldpos=caller.pos;
		range=min(caller.distance3d(caller.target),range);
		int range2=range*2;

		//bottom centre - always done
		caller.addz(shootheight);
		[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
			"CheckPuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ);
		if(!a)bottomdist=range2;else{
			if(a.tracer==caller.target)bottomdist=range2;else
			bottomdist=a.distance3d(caller);
			a.spawn("BulletPuff",a.pos);
		}


		//top centre
		if(pheight){
			caller.addz(pheight);
			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"CheckPuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ);
			if(!a)topdist=range2;else{
				if(a.tracer==caller.target)topdist=range2;else
				topdist=a.distance3d(caller);
				a.spawn("BulletPuff",a.pos);
			}
			caller.addz(-pheight);
		}else topdist=range2; //if no check, impact deemed to be beyond range

		//left and right
		if(pradius){
			double pht=pheight*0.5;
			caller.addz(pht);

			vector3 adj=(cos(caller.angle+90),sin(caller.angle+90),0)*pradius;
			caller.setxyz(caller.pos+adj);
			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"CheckPuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ);
			if(!a)leftdist=range2;else{
				if(a.tracer==caller.target)leftdist=range2;else
				leftdist=a.distance3d(caller);
				a.spawn("BulletPuff",a.pos);
			}

			caller.setxyz(caller.pos-adj*2);
			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"CheckPuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ);
			if(!a)rightdist=range2;else{
				if(a.tracer==caller.target)rightdist=range2;else
				rightdist=a.distance3d(caller);
				a.spawn("BulletPuff",a.pos);
			}

			caller.addz(-pht);
		}else{
			leftdist=range2;rightdist=range2;
		}

		//important
		caller.setxyz(oldpos);

		if(min(bottomdist,topdist,leftdist,rightdist)+5<range)return false;

		return true;
	}

	//setting targets, etc.
	static void setfeartarget(actor caller,actor frightener){
		caller.A_GiveInventory("HDMobAI");
		HDMobAI a=HDMobAI(caller.findinventory("HDMobAI"));
		if(a)a.feartarget=frightener;
	}
	static void setmovetarget(actor caller,vector3 mtpos){
		caller.A_GiveInventory("HDMobAI");
		HDMobAI a=HDMobAI(caller.findinventory("HDMobAI"));
		if(a){
			if(!a.movetarget)a.feartarget=caller.spawn("IdleDummy",caller.pos);
			if(a.movetarget){
				a.movetarget.setorigin(mtpos,false);
			}
		}
	}
}

class exzo:zombieman{
	states{
	see:
		POSS AABBCCDD 4{HDMobAI.Chase(self);}
		loop;
	missile:
		POSS E 10 A_FaceTarget();
		POSS F 8 A_PosAttack();
		POSS E 8;
		goto see;
	pain:
		POSS G 3;
		POSS G 3 A_Pain();
		goto see;
	raise:
		POSS KJIH 5;
		goto see;
	}
}
