// ------------------------------------------------------------
// Nice movement your objects have there.
// Shame if something happened to them.
// ------------------------------------------------------------

//general corpse-gibbing
class SawGib:InventoryFlag{
	default{
		inventory.maxamount int.MAX;
	}
	override void attachtoowner(actor user){
		super.attachtoowner(user);
		actor o=owner;
		if(owner){
			stamina=max(o.gibhealth,o.spawnhealth());
		}else goawayanddie();
	}
	override void doeffect(){
		if(bmissileevenmore)return;
		if(amount>stamina){  
			bmissileevenmore=true;
			actor o=owner;
			if(
				!owner.bcorpse
				||!owner.bshootable
				||owner.health>0  
				||!o.findstate("xdeath",true)
			)goawayanddie();
			else{
				o.bshootable=false;
				//use the old death state first
				if(o.findstate("XDeathBrewtleLulz"))o.setstatelabel("XDeathBrewtleLulz");else
				if(o.findstate("XXDeath"))o.setstatelabel("XXDeath");else
				o.setstatelabel("xdeath");
			}
		}
	}
}
//wrapper until all monsters scriptified
class HDCorpseFlags:ActionItem{
	states{
	pickup:
		TNT1 A 0{
			hdmobai.CorpseFlags(self);
		}fail;
	}
}


//static mob functions
struct HDMobAI play{
	//randomize size
	static void resize(actor caller,double minscl=0.9,double maxscl=1.,int minhealth=0){
		double scl=frandom(minscl,maxscl);
		caller.scale*=scl;
		caller.mass*=scl;
		caller.speed*=scl;
		caller.meleerange*=scl;
		caller.A_SetSize(caller.radius*scl,caller.height*scl);
		if(minhealth<1)caller.health*=max(scl,1);else caller.health=max(caller.health*scl,1);
	}

	//set and unset shootable corpse
	//"CorpseFlags" item is a wrapper for this now
	static void CorpseFlags(actor caller){
		caller.A_TakeInventory("SawGib");
		if(caller.health>0){    
			caller.bnotautoaimed=false;
			caller.balwaystelefrag=false;
		}else{
			caller.bshootable=true;
			caller.bnotautoaimed=true;
			caller.balwaystelefrag=true;
		}
	}

	//taking all the same flags as A_LookEx
	static void Look(
		actor caller,
		int flags=0,
		float minseedist=0,
		float maxseedist=0,
		float maxheardist=0,
		double fov=0,
		statelabel label="see",
		int soundchance=40
	){
		caller.A_LookEx(flags,minseedist,maxseedist,maxheardist,fov,label);
		if(!caller.bambush)caller.angle+=random(-10,10);
		if(!random(1,soundchance))caller.A_PlaySound(caller.activesound);
	}

	//smooth chase
	//do NOT try to set targets in here, JUST do the chase sequence
	static void Chase(actor caller,actor movetarget=null,bool res=false,bool flee=true){
		if(!caller.trymove(caller.pos.xy,false)){
			caller.A_Wander();
			return;
		}

		//remember original position, etc.
		vector3 pg=caller.pos;
		bool fraid=caller.bfrightened;
		actor attacktarget=caller.target;

		//chase the move target and record the resulting position
		caller.bfrightened=flee;
		if(attacktarget)caller.A_Chase("melee","missile",CHF_NODIRECTIONTURN|CHF_NOPOSTATTACKTURN|(res?CHF_RESURRECT:0));
		else caller.A_Wander(flags:CHF_NODIRECTIONTURN);
		vector3 pp=caller.pos;

		if(!caller.bfloat && caller.floorz<caller.pos.z)return; //abort if can't propel caller
		caller.vel.xy*=0.7; //slow down

		//reset position and move in chase direction
		if(pp!=pg){
			caller.setorigin(pg,false);
			if(caller.bfloat){
				caller.vel+=(pp-pg)*(fraid?0.32:0.16);
				if(attacktarget&&caller.pos.z-attacktarget.pos.z<attacktarget.height)
					caller.vel.z+=frandom(0,0.1); //floaty death from above
			}else{
				caller.vel.xy+=(pp.xy-pg.xy)*(flee?0.32:0.16);
			}
		}

		//face appropriate direction
		if(attacktarget&&caller.distance3d(attacktarget)<caller.meleerange*2)
			caller.A_FaceTarget(10,10);
		else if(caller.vel.xy!=(0,0))caller.A_FaceMovementDirection(15,40);

		//reset things
		caller.bfrightened=fraid;
	}

	//check if shot is clear
	//hdmobai.tryshoot(self,pradius:6,pheight:6)
	static bool TryShoot(
		actor caller,
		double shootheight=-1,
		double range=256,
		double pradius=0,
		double pheight=0
	){
		if(!caller.target)return false;
		if(shootheight<0)shootheight=caller.height-6;

		actor a=null;int b;
		double bottomdist=range;double topdist=range;
		double leftdist=range;double rightdist=range;
		double fullrange=range;

		//bottom centre - always done
		[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
			"TryShootPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
			offsetz:shootheight
		);
		if(a){
			bottomdist=a.distance3d(caller);
			//if any subsequent collision happens after hitting target, ignore it
			if(a.tracer==caller.target)range=min(range,bottomdist);
		}

		//top centre
		if(pheight){
			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"TryShootPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:pheight
			);
			if(a){
				topdist=a.distance3d(caller);
				if(a.tracer==caller.target)range=min(range,topdist);
			}
		}

		//left and right
		if(pradius){
			double pht=pheight*0.5;
			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"TryShootPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:pht,offsetside:-pradius
			);
			if(a){
				leftdist=a.distance3d(caller);
				if(a.tracer==caller.target)range=min(range,leftdist);
			}

			[a,b]=caller.LineAttack(caller.angle,range,caller.pitch,0,"none",
				"TryShootPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:pht,offsetside:pradius
			);
			if(a){
				rightdist=a.distance3d(caller);
				if(a.tracer==caller.target)range=min(range,rightdist);
			}
		}

		if(min(bottomdist,topdist,leftdist,rightdist)<range)return false;
		return true;
	}

	//set a feartarget for nearby mobs
	//hdmobai.frighten(self,256); maybe 128 for bullet and 512 for plasma and bfg
	static void Frighten(actor caller,double fraidius,actor fearsome=null){
		if(!fearsome)fearsome=caller;
		actor hir;
		blockthingsiterator it=blockthingsiterator.create(caller,fraidius);
		while(it.Next()){
			hir=it.thing;
			if(hir
				&& hir.bIsMonster
				&& hir.health>0
				&& hir.goal is "HDMobster"
				&& hir.CheckSight(fearsome)
			){
				HDMobster(hir.goal).threat=fearsome;
				HDMobster(hir.goal).thraidius=fraidius;
			}
		}
	}
}
class TryShootPuff:CheckPuff{
	default{
		-alwayspuff
	}
}




//actor that sets monster's goal
class HDMobster:IdleDummy{
	vector3 firstposition;
	actor threat;
	double thraidius;
	static hdmobster SpawnMobster(actor caller){
		let hdmb=hdmobster(spawn("HDMobster",caller.pos));
		hdmb.master=caller;
		hdmb.target=caller.target;
		return hdmb;
	}
	override void postbeginplay(){
		super.postbeginplay();
		firstposition=pos;
		threat=null;thraidius=256;
		changetid(123); //only used for actoriterator
	}
	states{
	spawn:
		TNT1 A random(7,10){
			if(
				!master
				//abort if something else is setting the goal, e.g. a level script
				||(master.goal&&master.goal!=self)
			){
				destroy();return;
			}
			if(master.health<1)return;
			master.goal=self;
			master.bchasegoal=true;

			//decide where to place goal
			target=master.target;
			if(threat){
				setorigin(master.pos+master.pos-threat.pos,false);
				if(
					!master.checksight(threat)
					||master.distance3d(threat)>thraidius  
				)threat=null;
			}else if(target){
				//chase target directly, or occasionaly randomize general direction
				if(
					target.health>0
					&&master.checksight(target)
				)setorigin(master.target.pos,false);  
				else if(!random(0,100))setorigin(
					pos+(random(-512,512),random(-512,512),0),false
				);
			}else setorigin(firstposition,false); //go back to start
		}wait;
	}
}




class exzo:zombieman{
	override void postbeginplay(){
		super.postbeginplay();
		hdmobster.spawnmobster(self);
	}
	states{
	see:
		POSS AABBCCDD 4{HDMobAI.Chase(self);}
		loop;
	missile:
		POSS E 10 A_FaceTarget();
		POSS F 8 A_PosAttack();
		POSS E 8;
		goto see;
	pain:
		POSS G 3;
		POSS G 3 A_Pain();
		goto see;
	raise:
		POSS KJIH 5;
		goto see;
	}
}
