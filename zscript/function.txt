// ------------------------------------------------------------
//   Basic functional stuff
// ------------------------------------------------------------

//event handler
class HDHandlers:EventHandler{}

//because "extend class Actor" doesn't work
class HDActor:Actor{
	default{
		+noblockmonst
	}
	//advance to the next tic without doing anything
	void nexttic(){
		ClearInterpolation(); //after 3.1.0 this may be unnecessary
		if(!CheckNoDelay()) return;
		if(tics!=-1){
			if(tics>0)tics--;
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}
	//wrapper for HDMath.CheckLump()
	bool CheckLump(string lumpname){
		return HDMath.CheckLump(lumpname);
	}
	//shoot a missile without changing pitch and angle; missile inherits momentum
	//A_ShootMissile("ShotgunBlast",44,0);
	virtual void A_ShootMissile(
		class<Actor> ms="DoomImpBall",
		double shootheight=-1,
		double shootspeed=-1,
		double shootangle=999,
		double shootpitch=999,
		bool seeker=false
	){
		//the real defaults
		if(shootangle==999) shootangle=self.angle;
		if(shootpitch==999) shootpitch=self.pitch;
		if(shootheight<0){
			if(self is "PlayerPawn") shootheight=self.height-12;
			else shootheight=self.missileheight;
		}
		actor prj=spawnmissileanglezspeed(
			self.pos.z+shootheight,
			ms,
			shootangle,
			-sin(pitch),
			shootspeed,
			self,
			false
		);
		if(shootspeed<=0) //default to projectile's own speed
			prj.A_ChangeVelocity(cos(pitch)*prj.speed,0,-sin(pitch)*prj.speed,CVF_RELATIVE);
		prj.vel+=self.vel;prj.pitch=shootpitch;
		prj.master=self;
		if(seeker) prj.tracer=self.target;
		//prj.playspawnsound(prj);
	}
	//generic function to spawn actors coming out of an explosion
	//for frags: A_SpawnChunks("HDFrag",42,100,700);
	void A_SpawnChunks(
		class<actor> chunk,
		int number=12,
		double minvel=10,
		double maxvel=20
	){
		if(
			chunk=="WallChunk"
			||chunk.getparentclass()=="WallChunk"
			||chunk.getparentclass().getparentclass()=="WallChunk"
		){
			int ch=hdmath.count("WallChunk");
			if(ch>500){
				if(hd_debug)A_Log(string.format("%i is too many chunks, %s not spawned",ch,chunk.getclassname()));
				return;
			}
		}
		int airb=0;
		vector3 burstpoint=self.pos+(0,0,self.height*0.5);
		if(burstpoint.z-floorz<56) airb=-1;
			else if(ceilingz-burstpoint.z<56) airb=1;
		actor frg;vector3 bp;
		for(int i=0;i<number;i++){
			frg=spawn(chunk,burstpoint);
			bp=(
				frandom(-1,1),
				frandom(-1,1),
				0
			);
			if(airb<0) bp.z=frandom(0.01,1);
				else if(airb>0) bp.z=-frandom(0.01,1);
				else bp.z=frandom(-1,1);
			bp*=frandom(minvel,maxvel);
			if(bp==(0,0,0))bp.z=1;
			frg.vel=vel+bp;
			if(frg is "HDBullet"){
				frg.target=target;
				frg.bseeinvisible=true; //work around hack that normally lets bullet out
			}
		}
	}
	//face a specified vector. NEGATIVE Z IS DOWN.
	//A_FaceVector((-20,90,-10),10,10,true);
	void A_FaceVector(vector3 v,double maxangle=0,double maxpitch=0,bool relative=false){
		double nangle=atan2(v.y,v.x);
		double abshorz=v.xy.length();
		double npitch=-atan2(v.z,abshorz);

		//cap angle
		double dangle=nangle-self.angle;
		if((abs(dangle)<360-maxangle)&&(abs(dangle)>maxangle)&&(maxangle>0)){
			if(abs(dangle)>180) dangle-=360;
			dangle=clamp(dangle,-maxangle,maxangle);
			nangle=self.angle+dangle;
		}

		//cap pitch
		dangle=npitch-self.pitch;
		if((abs(dangle)>maxpitch)&&(maxpitch>0)){
			dangle=clamp(dangle,-maxpitch,maxpitch);
			npitch=self.pitch+dangle;
		}

		//apply: add if relative, replace if not
		if(relative){
			A_SetAngle(angle+nangle,SPF_INTERPOLATE);
			A_SetPitch(pitch+npitch,SPF_INTERPOLATE);
		}else{
			A_SetAngle(nangle,SPF_INTERPOLATE);
			A_SetPitch(npitch,SPF_INTERPOLATE);
		}
	}
	//very crude way to tell if someone's back is turned
	//A_CheckBackTurned(self,self.pos,target.pos,target.angle)
	bool A_CheckBackTurned(vector3 ownpos,vector3 tpos,double tangle){
		if(
			((tangle>314 || tangle<46) && ownpos.x<tpos.x) ||
			((tangle>45 && tangle<136) && ownpos.y<tpos.y) ||
			((tangle>135 && tangle<226) && ownpos.x>tpos.x) ||
			((tangle>225 && tangle<316) && ownpos.y>tpos.y)
		)return true;else return false;
	}
	//set a feartarget for nearby mobs
	//A_Frighten(256); maybe 128 for bullet and 512 for plasma and bfg
	void A_Frighten(double fraidius,actor fearsome=null){
		if(!fearsome)fearsome=self;
		actor hir;
		blockthingsiterator it=blockthingsiterator.create(self,fraidius);
		while(it.Next()){
			hir=it.thing;
			if(hir
				&& hir.bIsMonster
				&& hir.health>0
				&& hir.CheckSight(fearsome)
			){
				hir.A_GiveInventory("HDMobAI");
				HDMobAI hirai=HDMobAI(hir.findinventory("HDMobAI"));
				if(hirai)hirai.feartarget=fearsome;
			}
		}
	}
}

class InventoryFlag:Inventory{
	default{
		+inventory.untossable;+nointeraction;+noblockmap;
		inventory.maxamount 1;inventory.amount 1;
	}
	states{
	spawn:
		TNT1 A 0;
		stop;
	}
}
class ActionItem:CustomInventory{
	default{
		+inventory.untossable -inventory.invbar +noblockmap
	}
	//wrapper for HDWeapon and ActionItem
	//remember: LEFT and DOWN
	//change these back to vector2s after 3.2?
	action void A_MuzzleClimb(
		double mc10=0,double mc11=0,
		double mc20=0,double mc21=0,
		double mc30=0,double mc31=0,
		double mc40=0,double mc41=0
	){
		let hdp=HDPlayerPawn(self);
		if(hdp){
			hdp.A_MuzzleClimb((mc10,mc11),(mc20,mc21),(mc30,mc31),(mc40,mc41));
		}else{ //I don't even know why
			vector2 mc0=(mc10,mc11)+(mc20,mc21)+(mc30,mc31)+(mc40,mc41);
			A_SetPitch(pitch+mc0.y,SPF_INTERPOLATE);
			A_SetAngle(angle+mc0.x,SPF_INTERPOLATE);
		}
	}
	states{
	nope:
		TNT1 A 0;fail;
	spawn:
		TNT1 A 0;stop;
	}
}
class IdleDummy:HDActor{
	default{
		+noclip +nointeraction +noblockmap
		height 0;radius 0;
	}
	states{
	spawn:
		TNT1 A -1 nodelay{
			if(stamina>0) A_SetTics(stamina);
		}stop;
	}
}
class CheckPuff:IdleDummy{
	default{
		+bloodlessimpact +hittracer +puffonactors +alwayspuff +puffgetsowner
		stamina 1;
	}
}
//mostly for doing TryMove checks to grab blockingline data
class TMChecker:HDActor{
	default{
		radius 3;height 1;maxstepheight 0;
	}
	states{
	spawn:
		TNT1 A 1;
		stop;
	}
}


//collection of generic math functions
struct HDMath{
	//why does ZS not have a native round function?????
	//or ceiling, for that matter????????
	static int Round(double input){
		int r=floor(input);if(input-r>=0.5) r++;
		return r;
	}
	//returns how much MINIMUM to turn to get from one angle to another
	//because i am so sick of re-learning how to do it every time
	//HDMath.AngleChange(90,-42)
	static double AngleChange(double a1, double a2){
//		return deltaangle(a2,a1);
		//delete once upgraded to new zscript
		double a=a2-a1;
		while(a<0) a+=360;
		a%=360;
		if(a>180)a-=360;
		return a;
	}
	//return a vector roughly as long as the desired length
	//HDMath.ScaleVector(vel,4);
	static vector3 ScaleVector(vector3 src,double length=1){
		return src.unit()*length;
	}
	//return true if lump exists
	//mostly for seeing if we're playing D1 or D2
	//HDMath.CheckLump("SHT2A0")
	static bool CheckLump(string lumpname){
		if(Wads.CheckNumForName(lumpname,wads.ns_sprites,-1,false)<0)return false;
		return true;
	}
	//counts stuff
	//HDMath.CountThinkers("IdleDummy")
	static int Count(name type,bool exactmatch=false){
		int count=0;
		thinkeriterator it=thinkeriterator.create(type);
		while(it.Next(exact:exactmatch))count++;
		return count;
	}
	//gets how many of an inventory are attached to a given owner.
	//can get number of thinkers or total amount.
	//HDMath.supercountinv(target,"parasite")
	static int SuperCountInv(actor caller,class<inventory> type,bool geteachamount=false){
		int count=0;

		//new, unreliable? version
		for(let probe=caller.inv;probe;probe=probe.inv){
			if(probe is type){
				if(geteachamount)count+=probe.amount;
				else count++;
			}
		}return count;

		//old version
		thinkeriterator invfinder=thinkeriterator.create("Inventory");
		inventory mo;
		while(mo=inventory(invfinder.next())){
			if(mo is type && mo.owner==caller){
				if(geteachamount)count+=mo.amount;
				else count++;
			}
		}return count;
	}
	//calculate the speed at which 2 actors are moving towards each other
	//surely there's got to be a faster way to do this x_x
	static double TowardsEachOther(actor a1, actor a2){
		vector3 oldpos1=a1.pos;
		vector3 oldpos2=a2.pos;
		vector3 newpos1=oldpos1+a1.vel;
		vector3 newpos2=oldpos2+a2.vel;
		double l1=(oldpos1-oldpos2).length();
		double l2=(newpos1-newpos2).length();
		return l1-l2;
	}
}
struct HDF play{
	//return the maximum capacity for this actor and this inventory
	//force give-and-take to register if absent
	//HDF.MaxInv(self,"FourMilAmmo")
	static int MaxInv(actor holder,class<inventory> inv){
		if(holder.findinventory(inv))return holder.findinventory(inv).maxamount;
		holder.A_GiveInventory(inv);
		let hh=holder.findinventory(inv);
		if(!hh){
			if(hd_debug)
			holder.A_Log(string.format("Invalid type for HDF.maxinv: %s",inv.getclassname()));
			return -1;
		}
		int max=hh.maxamount;
		hh.destroy();
		return max;
	}
	//transfer inventory: one gets, the other loses
	enum TransferInventoryFlags{
		ITRF_ADD=1,
		ITRF_KEEPGIVER=2,
	};
	static int TransferInventory(
		actor giver,
		actor receiver,
		class<inventory> item,
		int flags=0,
		int amt=0
	){
		//set the amount
		if(amt<1)amt=giver.countinv(item);
		else amt=min(amt,giver.countinv(item));

		//give the amount as appropriate
		if(flags & ITRF_ADD){
			amt=min(amt,maxinv(receiver,item)-receiver.countinv(item));
			if(amt)receiver.A_GiveInventory(item,amt);
		}else receiver.A_SetInventory(item,amt);

		//remove from giver if true
		if(!(flags & ITRF_KEEPGIVER)){
			giver.A_TakeInventory(item,amt);
		}
		return amt;
	}
	//transfer fire. returns # of fire actors affected.
	static int TransferFire(actor ror,actor ree,int maxfires=-1){
		actoriterator it=actoriterator.create(-7677,"HDFire");
		actor fff;int counter;
		bool eee;if(ree)eee=true;
		while(maxfires && (fff=it.next())){
			maxfires--;
			if(fff.target==ror){
				counter+=fff.stamina;
				if(eee)fff.target=ree;
				else fff.destroy();
			}
		}
		return counter;
	}
}



