// ------------------------------------------------------------
// Basic functional stuff
// ------------------------------------------------------------

//event handler
class HDHandlers:EventHandler{}

//because "extend class Actor" doesn't work
class HDActor:Actor{
	default{
		+noblockmonst
	}
	//advance to the next tic without doing anything
	void nexttic(){
		if(!CheckNoDelay()) return;
		if(tics!=-1){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}
	//decorate wrapper for HDMath.CheckLump()
	bool CheckLump(string lumpname){
		return HDMath.CheckLump(lumpname);
	}
	//generic function to spawn actors coming out of an explosion
	//for frags: A_SpawnChunks("HDFrag",42,100,700);
	void A_SpawnChunks(
		class<actor> chunk,
		int number=12,
		double minvel=10,
		double maxvel=20
	){
		if(
			chunk=="WallChunk"
			||chunk.getparentclass()=="WallChunk"
			||chunk.getparentclass().getparentclass()=="WallChunk"
		){
			int ch=hdmath.count("WallChunk");
			if(ch>500){  
				if(hd_debug)A_Log(string.format("%i is too many chunks, %s not spawned",ch,chunk.getclassname()));
				return;
			}
		}
		int airb=0;
		vector3 burstpoint=self.pos+(0,0,self.height*0.5);
		if(burstpoint.z-floorz<56) airb=-1;
			else if(ceilingz-burstpoint.z<56) airb=1;
		for(int i=0;i<number;i++){
			actor frg=spawn(chunk,burstpoint);
			vector3 bp=(
				frandom(-1,1),
				frandom(-1,1),
				airb<0?frandom(0.01,1):(airb>0?-frandom(0.01,1):frandom(-1,1))
			)*frandom(minvel,maxvel);
			if(bp==(0,0,0))bp.z=1;
			frg.vel=vel+bp;
			if(frg is "HDBullet"){
				frg.target=target;
				frg.bseeinvisible=true; //work around hack that normally lets bullet out
			}
		}
	}
}

class InventoryFlag:Inventory{
	default{
		+inventory.untossable;+nointeraction;+noblockmap;
		inventory.maxamount 1;inventory.amount 1;
	}
	states{
	spawn:
		TNT1 A 0;
		stop;
	}
}
class ActionItem:CustomInventory{
	default{
		+inventory.untossable -inventory.invbar +noblockmap
	}
	//wrapper for HDWeapon and ActionItem
	//remember: LEFT and DOWN
	//would use vector2s but lol bracketing errors I don't need that kind of negativity in my life
	action void A_MuzzleClimb(
		double mc10=0,double mc11=0,
		double mc20=0,double mc21=0,
		double mc30=0,double mc31=0,
		double mc40=0,double mc41=0
	){
		let hdp=HDPlayerPawn(self);
		if(hdp){
			hdp.A_MuzzleClimb((mc10,mc11),(mc20,mc21),(mc30,mc31),(mc40,mc41));
		}else{ //I don't even know why
			vector2 mc0=(mc10,mc11)+(mc20,mc21)+(mc30,mc31)+(mc40,mc41);
			A_SetPitch(pitch+mc0.y,SPF_INTERPOLATE);
			A_SetAngle(angle+mc0.x,SPF_INTERPOLATE);
		}
	}
	states{
	nope:
		TNT1 A 0;fail;
	spawn:
		TNT1 A 0;stop;
	}
}
class IdleDummy:HDActor{
	default{
		+noclip +nointeraction +noblockmap
		height 0;radius 0;
	}
	states{
	spawn:
		TNT1 A -1 nodelay{
			if(stamina>0) A_SetTics(stamina);  
		}stop;
	}
}
class CheckPuff:IdleDummy{
	default{
		+bloodlessimpact +hittracer +puffonactors +alwayspuff +puffgetsowner
		stamina 1;
	}
}
//mostly for doing TryMove checks to grab blockingline data
class TMChecker:HDActor{
	default{
		radius 3;height 1;maxstepheight 0;
	}
	states{
	spawn:
		TNT1 A 1;
		stop;
	}
}


// Blocker to prevent shotguns from overpenetrating multiple targets
// A_SpawnItemEx("tempshield",flags:SXF_SETMASTER|SXF_NOCHECKPOSITION);
class tempshield:actor{
	default{
		-solid +shootable +nodamage
		mass 10000;
		radius 16;height 50;
		stamina 16;
	}
	override void tick(){
		super.tick();
		if(master){
			setorigin(master.pos,false);
		}
		stamina--;
		if(stamina<1)destroy();
	}
	states{
	spawn:
		TNT1 A 16;
		stop;
	}
}
class tempshield2:tempshield{
	default{
		radius 18;height 26;
		stamina 10;
	}
}
class tempshieldyellow:tempshield{
	default{bloodcolor "aa 99 22";}
}
class tempshieldgreen:tempshield{
	default{bloodcolor "44 99 22";}
}
class tempshield2green:tempshield2{
	default{bloodcolor "44 99 22";}
}
class tempshieldblue:tempshield{
	default{bloodcolor "00 00 99";}
}
class tempshield2blue:tempshield2{
	default{bloodcolor "00 00 99";}
}
class tempshieldpuff:tempshield{
	default{+noblood}
}
class tempshield2puff:tempshield2{
	default{+noblood}
}


//collection of generic math functions
struct HDMath{
	//return true if lump exists
	//mostly for seeing if we're playing D1 or D2
	//HDMath.CheckLump("SHT2A0")
	static bool CheckLump(string lumpname){
		return Wads.CheckNumForName(lumpname,wads.ns_sprites,-1,false)>=0;
	}
	//return the maximum capacity for this actor and this inventory
	//HDMath.MaxInv(self,"FourMilAmmo")
	static int MaxInv(actor holder,class<inventory> inv){
		if(holder.findinventory(inv))return holder.findinventory(inv).maxamount;
		return getdefaultbytype(inv).maxamount;
	}
	//counts stuff
	//HDMath.CountThinkers("IdleDummy")
	static int Count(name type,bool exactmatch=false){
		int count=0;
		thinkeriterator it=thinkeriterator.create(type);
		while(it.Next(exact:exactmatch))count++;
		return count;
	}
	//calculate the speed at which 2 actors are moving towards each other
	static double TowardsEachOther(actor a1, actor a2){
		vector3 oldpos1=a1.pos;
		vector3 oldpos2=a2.pos;
		vector3 newpos1=oldpos1+a1.vel;
		vector3 newpos2=oldpos2+a2.vel;
		double l1=(oldpos1-oldpos2).length();
		double l2=(newpos1-newpos2).length();
		return l1-l2;
	}
}
struct HDF play{
	//transfer inventory: one gets, the other loses
	enum TransferInventoryFlags{
		ITRF_ADD=1,
		ITRF_KEEPGIVER=2,
	};
	static int TransferInventory(
		actor giver,
		actor receiver,
		class<inventory> item,
		int flags=0,
		int amt=0
	){
		//set the amount
		if(amt<1)amt=giver.countinv(item);
		else amt=min(amt,giver.countinv(item));

		//give the amount as appropriate
		if(flags & ITRF_ADD){
			amt=min(amt,hdmath.maxinv(receiver,item)-receiver.countinv(item));
			if(amt)receiver.A_GiveInventory(item,amt);
		}else receiver.A_SetInventory(item,amt);

		//remove from giver if true
		if(!(flags & ITRF_KEEPGIVER)){
			giver.A_TakeInventory(item,amt);
		}
		return amt;
	}
	//transfer fire. returns # of fire actors affected.
	static int TransferFire(actor ror,actor ree,int maxfires=-1){
		actoriterator it=actoriterator.create(-7677,"HDFire");
		actor fff;int counter;
		bool eee;if(ree)eee=true;
		while(maxfires && (fff=it.next())){
			maxfires--;
			if(fff.target==ror){
				counter+=fff.stamina;
				if(eee)fff.target=ree;
				else fff.destroy();
			}
		}
		return counter;
	}
	//split inventory item to match pickup sprite
	static void SplitAmmoSpawn(inventory caller,int maxunit=1){
		while(caller.amount>maxunit){
			caller.amount-=maxunit;
			inventory bbb=inventory(caller.spawn(caller.getclass(),caller.pos));
			bbb.amount=maxunit;bbb.vel=caller.vel+(frandom(-1,1),frandom(-1,1),frandom(-1,1));
		}
	}
}










