// ------------------------------------------------------------
// Tracked magazines (and clips and batteries)
// ------------------------------------------------------------
/*
	special:
		override insert, extract and consolidate for zm66 and cell
	for the mags:
		debris empty only if not retaining
		debris empty should die and become pickup
		different sprite depending on empty
	for the weapons:
		unload:
			int tounload=blahblahblah
			set the loaded variable to -1
			HDMagAmmo.SpawnMag(self,<type>,tounload);
			HDMagAmmo.GiveMag(self,<type>,tounload);
		reload:
			A_JumpIfInventory(magtype,"reallyreload");
			int toload=mags.TakeMag(true);
			if(toload<0)return;
			let the player load an empty
	for backpack
		predefine a dynarray in the backpack for each such item
		place:
			check for room
			takemag, push
		retrieve:
			int frombp=bpmags[bpmags.size()-1];
			bpmags.pop();
			HDMagAmmo.GiveMag(self,type,frombp);
	for levelreset
		Consolidate all
*/
class HDMagAmmo:HDAmmo{
	array<int> mags; //or clips or batteries, whatever
	int maxperunit;
	property maxperunit:maxperunit;
	class<inventory> roundtype;
	property roundtype:roundtype;
	double roundbulk;
	property roundbulk:roundbulk;
	double magbulk;
	property magbulk:magbulk;
	string nicename;
	property nicename:nicename;
	default{
		hdmagammo.maxperunit 30;
		hdmagammo.roundtype "HDPistolAmmo";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "Generic Mag-Tracked Ammo";
		inventory.maxamount 10;
	}
	override double getbulk(){
		double result=0;
		SyncAmount();
		for(int i=0;i<amount;i++){
			result+=max(magbulk,roundbulk*mags[i]*1.1);
		}
		return result;
	}

	//add mag amount or size as appropriate
	//should be called at the start of each interaction
	//should NEVER reduce the array to none if it was not none before
	void SyncAmount(){
		amount=max(amount,mags.size());
		while(amount>mags.size()){
			//mags.push(random(1,maxperunit));	//testing
			mags.push(maxperunit);
		}
	}
	//remove one mag and return the value
	//use to load or drop
	int TakeMag(bool getmax){
		SyncAmount();
		if(amount<1)return -1;
		//the usual: get the last one
		if(!getmax){
			int lastmag=mags[mags.size()-1];
			mags.pop();
			amount=mags.size();
			return lastmag;
		}

		int maxindex=mags.find(maxperunit);
		//if fail, take the FIRST mag
		//(because last is probably what you just unloaded)
		if(
			maxindex==mags.size()
			&&mags[mags.size()-1]<maxperunit
		){
			int firstmag=mags[0];
			mags.delete(0);
			amount=mags.size();
			return firstmag;
		}
		//take one full mag
		mags.delete(maxindex);
		amount=mags.size();
		return maxperunit;
	}
	//take last mag and put it at index zero
	void LastToFirst(){
		SyncAmount();
		if(amount<2)return;
		mags.insert(0,mags[mags.size()-1]);
		mags.pop();
	}
	void FirstToLast(){
		SyncAmount();
		if(amount<2)return;
		mags.push(mags[0]);
		mags.delete(0);
	}
	//bring up the lowest-value mag
	//useful for refilling and discarding
	void LowestToLast(){
		SyncAmount();
		if(amount<2)return;
		int lowestindex=-1;
		int lowest=maxperunit;
		for(int i=0;i<amount;i++){
			if(lowest>mags[i]){
				lowest=mags[i];
				lowestindex=i;
			}
		}
		if(lowestindex<0)return;
		mags.delete(lowestindex);
		mags.push(lowest);
	}
	//bring up the highest-value non-full mag
	//useful for refilling and discarding
	void HighestFillableToLast(){
		SyncAmount();
		if(amount<2)return;
		int highestindex=-1;
		int highest=0;
		for(int i=0;i<amount;i++){
			if(highest>mags[i]&&mags[i]<maxperunit){
				highest=mags[i];
				highestindex=i;
			}
		}
		if(highestindex<0||highestindex==mags.size())return;
		mags.delete(highestindex);
		mags.push(highest);
	}
	//add a mag
	//use to unload
	void AddAMag(int addamt=-1){
		SyncAmount();
		if(amount>=maxamount)return;
		if(addamt<0||addamt>maxperunit)addamt=maxperunit;
		mags.push(addamt);
		amount=mags.size();
	}
	//give a mag to someone
	static bool GiveMag(actor receiver,class<inventory> type,int giveamt){
		if(receiver.findinventory(type)){
			let mmm=HDMagAmmo(receiver.findinventory(type));
			if(mmm.amount>=mmm.maxamount){
				HDMagAmmo.SpawnMag(receiver,type,giveamt);
				return false;
			}
			mmm.AddAMag(giveamt);
		}else{
			receiver.A_GiveInventory(type,1);
			let mmm=HDMagAmmo(receiver.findinventory(type));
			mmm.mags.clear();
			mmm.amount=0;
			mmm.AddAMag(giveamt);
			mmm.amount=mmm.mags.size();
		}
		return true;
	}
	//spawn and drop
	//mostly for unloads
	static actor SpawnMag(actor giver,class<inventory> type,int giveamt){
		let mmm=HDMagAmmo(giver.spawn(type,giver.pos));
		mmm.addz(giver.height-12);mmm.angle=giver.angle;
		mmm.A_ChangeVelocity(2,0,-1,CVF_RELATIVE);
		mmm.vel+=giver.vel;
		mmm.amount=0;
		mmm.mags.clear();
		mmm.AddAMag(giveamt);
		mmm.amount=mmm.mags.size();
		return mmm;
	}
	//for weapon reloading sequences so you don't look like an idiot
	//if(HDMagAmmo.NothingLoaded(self,"HD9mMag15"))
	static bool NothingLoaded(actor caller,class<inventory> magtype){
		let tocheck=HDMagAmmo(caller.findinventory(magtype));
		if(!tocheck)return true;
		for(int i=0;i<tocheck.amount;i++){
			if(tocheck.mags[i]>0)return false;
		}
		return true;
	}

	//add and extract rounds
	//return values can be used to stop loops or affect animations
	virtual bool Extract(){
		SyncAmount();
		if(
			mags[mags.size()-1]<1
			||owner.A_JumpIfInventory(roundtype,0,"null")
		)return false;
		HDF.Give(owner,roundtype,1);
		owner.A_PlaySound("weapons/rifleclick2",CHAN_WEAPON);
		mags[mags.size()-1]--;
		return true;
	}
	virtual bool Insert(){
		SyncAmount();
		if(
			mags[mags.size()-1]>=maxperunit
			||!owner.countinv(roundtype)
		)return false;
		owner.A_TakeInventory(roundtype,1,TIF_NOTAKEINFINITE);
		owner.A_PlaySound("weapons/rifleclick2",CHAN_WEAPON);
		mags[mags.size()-1]++;
		return true;
	}
	//consolidate
	virtual void Consolidate(){
		SyncAmount();
		if(amount<2)return;
		int totalrounds=0;
		for(int i=0;i<amount;i++){
			totalrounds+=mags[i];
			mags[i]=0; //keep the empties, do NOT call clear()!
		}
		for(int i=0;i<amount;i++){
			int toinsert=min(maxperunit,totalrounds);
			mags[i]=toinsert;
			totalrounds-=toinsert;
			if(totalrounds<1)break;
		}
	}
	//purge empty
	void PurgeEmpties(){
		SyncAmount();
		LowestToLast();
		while(mags[mags.size()-1]<1){
			owner.A_DropInventory(getclassname(),1);
			LowestToLast();
		}
	}
	//max everything
	void MaxCheat(){
		mags.clear();
		SyncAmount();
	}

	//debug: log amounts
	void LogAmounts(bool owneronly=false){
		string stt=string.format("%i  %s: ",amount,getclassname());
		for(int i=0;i<amount;i++){
			stt=string.format("%s %i",stt,mags[i]);
		}
		if(owneronly&&owner)owner.A_Log(stt,true);
		else A_Log(stt);
	}

	override void actualpickup(actor other){
		if(!other)other=picktarget;
		if(!other)return;
		name gcn=getclassname();

		//you're only ever picking up one at a time
//		if(HDMath.MaxInv(other,gcn)<=other.countinv(gcn))return;
		let alreadygot=HDMagAmmo(other.findinventory(gcn));
		if(alreadygot){
			alreadygot.syncamount();
			while(alreadygot.amount>=alreadygot.maxamount){
				int thismag=mags[0];
				bool thisisbetter=false;
				for(int i=0;!thisisbetter&&i<alreadygot.amount;i++){
					if(thismag>alreadygot.mags[i])thisisbetter=true;
				}
				if(!thisisbetter)return;
				alreadygot.LowestToLast();
alreadygot.logamounts();
				other.A_DropInventory(gcn,1);
			}
		}

		//misc. effects
		other.A_PlaySound(pickupsound,CHAN_AUTO);
		other.A_Log(string.format("\cg%s",pickupmessage()),true);

		//if no information, give max, otherwise use own array info
		if(mags.size()<1)other.A_GiveInventory(gcn);
		else HDMagAmmo.GiveMag(other,gcn,mags[0]);
		destroy();
	}
	override inventory createtossable(int amt){
		if(amount<1)return null;
		amt=min(max(1,amt),amount);
		inventory iii;
		for(int i=0;i<amt;i++){
			iii=inventory(spawn(getclassname(),owner.pos));
			if(iii){
				iii.addz(owner.height*0.6);
				iii.angle=owner.angle;iii.target=owner;iii.vel=owner.vel;
				iii.A_ChangeVelocity(4,frandom(-0.6,0.6),frandom(0.9,1.1),CVF_RELATIVE);
				if(droptranslation&&owner){
					actor onr=owner;
					if(iii)iii.translation=onr.translation;
				}
				let mmm=HDMagAmmo(iii);
				mmm.mags.clear();
				mmm.mags.push(takemag(false));
			}
		}
		return iii;
	}
	override void postbeginplay(){
		super.postbeginplay();
		syncamount();
	}

	states{
	use:
		TNT1 A 0{
			invoker.SyncAmount();
			A_SetInventory("HDMagManager",1);
			let mmm=HDMagManager(findinventory("HDMagManager"));
			mmm.thismag=invoker;mmm.thismagtype=invoker.getclassname();
			UseInventory(mmm);

			if(!invoker.amount||!hd_debug)return;

			invoker.LogAmounts(true);

			//stuff to test
			//give hdmagammo 10;wait 1;use hdmagammo
			//A_Log("PurgeEmpties");invoker.PurgeEmpties();
				//MaxCheat
				//LastToFirst
				//LowestToLast
				//HighestFillableToLast
				//Extract
				//Insert
				//Consolidate
				//TakeMag(true)
				//TakeMag(false)
				//SpawnMag
				//PurgeEmpties
			//invoker.LogAmounts();
		}fail;
	spawn:
		TNT1 A 1;
		TNT1 A 0{
			invoker.SyncAmount();
			while(invoker.amount>1){
				inventory aa=inventory(spawn(invoker.getclassname(),invoker.pos));
				aa.amount=1;invoker.amount--;
				let aaa=HDMagAmmo(aa);
				aaa.mags.clear();
				aaa.mags.push(invoker.takemag(false));
			}
			if(!invoker.mags[0])invoker.setstatelabel("spawnempty");
			else invoker.setstatelabel("spawn2");
		}stop;
	spawn2:
		CELL A -1;
		stop;
	spawnempty:
		CELL D -1;
		stop;
	}
}




class HD9mMag15:HDMagAmmo{
	default{
		hdmagammo.maxperunit 15;
		hdmagammo.roundtype "HDPistolAmmo";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "Pistol Magazines";
		inventory.maxamount 18;
		inventory.pickupmessage "Picked up a pistol magazine.";
	}
	states{
	spawn2:
		CLP2 A -1;
		stop;
	spawnempty:
		CLP2 B -1{
			brollsprite=true;brollcenter=true;
			roll=randompick(0,0,0,0,2,2,2,2,1,3)*90;
		}stop;
	}
}
class HD9mMag30:HD9mMag15{
	default{
		hdmagammo.maxperunit 30;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "SMG Magazines";
		inventory.maxamount 8;
		inventory.pickupmessage "Picked up an SMG magazine.";
	}
	states{
	spawn2:
		CLP3 A -1;
		stop;
	spawnempty:
		CLP3 B -1{
			brollsprite=true;brollcenter=true;
			roll=randompick(0,0,0,0,2,2,2,2,1,3)*90;
		}stop;
	}
}

class HD7mMag:HDMagAmmo{
	default{
		hdmagammo.maxperunit 30;
		hdmagammo.roundtype "SevenMilAmmo";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "Liberator Magazines";
		inventory.maxamount 8;
		inventory.pickupmessage "Picked up a 7.76mm magazine.";
		scale 0.8;
	}
	states{
	spawn2:
		RMAG A -1;
		stop;
	spawnempty:
		RMAG B -1{
			brollsprite=true;brollcenter=true;
			roll=randompick(0,0,0,0,2,2,2,2,1,3)*90;
		}stop;
	}
}
class HD7mClip:HDMagAmmo{
	default{
		hdmagammo.maxperunit 10;
		hdmagammo.roundtype "SevenMilAmmo";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "Boss Clips";
		inventory.maxamount 20;
		inventory.pickupmessage "Picked up a 7.76mm clip.";
		scale 0.8;
	}
	states(actor){
	spawn2:
		RCLP ABCDE -1{
			int amt=mags[0];
			if(amt>8)frame=0;
			else if(amt>6)frame=1;
			else if(amt>4)frame=2;
			else if(amt>2)frame=3;
			else if(amt>0)frame=4;
		}stop;
	spawnempty:
		RCLP F -1{
			brollsprite=true;brollcenter=true;
			roll=randompick(1,1,1,1,3,3,3,3,0,2)*90;
		}stop;
	}
}

class HDBattery:HDMagAmmo{
	default{
		hdmagammo.maxperunit 20;
		hdmagammo.roundtype "";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "Batteries";
		inventory.pickupmessage "Picked up a battery.";
		scale 0.4;
	}
	override double getbulk(){
		return ENC_BATTERY*amount;
	}
	override bool Insert(){return false;}
	override bool Extract(){return false;}
	override void Consolidate(){}
	states(actor){
	spawn2:
		CELL CAB -1{
			int amt=mags[0];
			if(amt>13)frame=0;
			else if(amt>6)frame=1;
		}stop;
	spawnempty:
		CELL D -1;
		stop;
	}
}

class HD4mMag:HDMagAmmo{
	default{
		hdmagammo.maxperunit 51;
		hdmagammo.roundtype "FourMilAmmo";
		hdmagammo.roundbulk 0;
		hdmagammo.magbulk 0;
		hdmagammo.nicename "4.26 UAC Standard Magazines";
		inventory.maxamount 12;
		inventory.pickupmessage "Picked up a 4.26 UAC Standard magazine.";
	}
	override void postbeginplay(){
		super.postbeginplay();
		sealtimer=0;
	}
	int sealtimer;
	override void doeffect(){
		if(sealtimer>0)sealtimer--;
	}
	override string pickupmessage(){
		string pms="Picked up a 4.26 UAC Standard magazine.";
		if(mags[0]<51)pms.appendformat(" %s",HDCONST_426MAGMSG);
		return pms;
	}
	bool DirtyMagsOnly(){
		for(int i=0;i<amount;i++){
			if(mags[i]>=51)return false;
		}
		return true;
	}
	override bool Extract(){
		SyncAmount();
		int mindex=mags.size()-1;
		if(
			mags[mindex]<1
			||owner.A_JumpIfInventory(roundtype,0,"null")
		)return false;
		if(mags[mindex]>=51){
			if(sealtimer<1){
				owner.A_Log(string.format("%s\nDo you really want to do that?",HDCONST_426MAGMSG),true);
				sealtimer=10;
				return false;
			}else{
				mags[mindex]=50;
				owner.A_PlaySound("weapons/rifleclick",CHAN_WEAPON);
				return false;
			}
		}
		int totake=random(1,min(
			mags[mindex],
			HDMath.MaxInv(owner,"FourMilAmmo")-owner.countinv("FourMilAmmo"))
		);
		HDF.Give(owner,roundtype,totake);
		owner.A_PlaySound("weapons/rifleclick2",CHAN_WEAPON);
		owner.A_PlaySound("weapons/rockreload",CHAN_BODY,0.4);
		mags[mindex]-=totake;
		return true;
	}
	override bool Insert(){
		SyncAmount();
		if(
			mags[mags.size()-1]>=50
			||!owner.countinv(roundtype)
		)return false;
		owner.A_TakeInventory(roundtype,1,TIF_NOTAKEINFINITE);
		owner.A_PlaySound("weapons/rifleclick2",CHAN_WEAPON);
		if(!random(0,7)){
			owner.A_PlaySound("weapons/bigcrack",CHAN_BODY);
			owner.A_SpawnItemEx("HDSmokeChunk",12,0,owner.height-12,4,frandom(-2,2),frandom(2,4));
			owner.damagemobj(self,owner,1,"Thermal",DMG_NO_ARMOR);
			return false;
		}
		owner.A_PlaySound("weapons/pocket",CHAN_BODY,frandom(0.1,0.6));
		mags[mags.size()-1]++;
		return true;
	}
	override void Consolidate(){
		SyncAmount();
		if(amount<2)return;
		int totalrounds=0;
		for(int i=0;i<amount;i++){
			if(mags[i]>=51)continue;
			totalrounds+=mags[i];
			mags[i]=0; //keep the empties, do NOT call clear()!
		}
		for(int i=0;i<amount;i++){
			if(mags[i]>=51)continue;
			int toinsert=min(50,totalrounds)*frandom(0.9,1.);
			mags[i]=toinsert;
			totalrounds-=toinsert;
			if(totalrounds<1)break;
		}
	}
	states(actor){
	spawn2:
		ZMAG AB -1{
			if(mags[0]<51)frame=1;
		}stop;
	spawnempty:
		ZMAG C -1{
			brollsprite=true;brollcenter=true;
			roll=randompick(0,0,0,0,2,2,2,2,1,3)*90;
		}stop;
	}
}




