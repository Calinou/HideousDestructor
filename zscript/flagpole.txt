// ------------------------------------------------------------
// Flagpole mode
// ------------------------------------------------------------
extend class HDHandlers{
	void SpawnFlagpole(){
		vector3 spawnfirst=getrandomspawnpoint();
		vector3 spawnsecond;
		do{
			spawnsecond=getrandomspawnpoint(spawnfirst);
		}while(spawnsecond==spawnfirst);
		actor.spawn("HDCapFlagpole",spawnfirst,ALLOW_REPLACE);
		actor.spawn("HDCapFlag",spawnsecond,ALLOW_REPLACE);
		actor.spawn("TeleFog",spawnsecond,ALLOW_REPLACE);
		if(hd_debug){
			console.printf("Flagpole spawned at ["
				..spawnfirst.x..", "
				..spawnfirst.y..", "
				..spawnfirst.z.."]\nFlag spawned at ["
				..spawnsecond.x..", "
				..spawnsecond.y..", "
				..spawnsecond.z.."]"
			);
		}
	}
	vector3 GetRandomSpawnPoint(
		vector3 compare1=(0,0,32000),
		vector3 compare2=(0,0,32000),
		vector3 compare3=(0,0,32000)
	){
		let hhh=hdhandlers(eventhandler.find("hdhandlers"));

		//if all (0,0,32k) simply pick a random point and be done with it
		if(
			compare1.z==32000
			&&compare2.z==32000
			&&compare3.z==32000
		){
			int whch=random(0,invposx.size()-1);
			return (hhh.invposx[whch],hhh.invposy[whch],hhh.invposz[whch]);
		}

		//pick 5 random points and get the furthest one
		vector3 candidatepoint[10];
		int highestcandidate=0;
		double highestdist=0;
		for(int i=0;i<candidatepoint.size();i++){
			//obtain a random point
			int whch=random(0,invposx.size()-1);
			candidatepoint[i]=(hhh.invposx[whch],hhh.invposy[whch],hhh.invposz[whch]);

			//determine the lowest distance from each of the comparison points
			double lowestdist=(65000.*65000.);
			for(int j=0;j<3;j++){
				vector3 ddd;
				if(j==0)ddd=compare1;
				else if(j==0)ddd=compare2;
				else ddd=compare3;
				if(ddd.z==32000)continue;

				ddd=level.vec3offset(candidatepoint[i],ddd);
				double compdist=ddd dot ddd;
				if(compdist<lowestdist)lowestdist=compdist;
			}
			//if the above result is higher, update best candidate
			if(lowestdist>highestdist){
				highestdist=lowestdist;
				highestcandidate=i;
			}
		}
		return candidatepoint[highestcandidate];
	}
}


class HDCapFlagpole:Actor{
	default{
		+flatsprite
		+nointeraction
		renderstyle "add";
		height 1;radius 1;
	}
	states{
	spawn:
		BAL2 C 1{
			alpha=frandom(0.2,0.7);
			A_SetAngle(angle+frandom(6,18),SPF_INTERPOLATE);
			scale=(1.,1.)*clamp(scale.x+frandom(-0.3,0.3),0.4,3.6);
			setz(floorz+frandom(0,4));
		}
		wait;
	}
}
class HDFlagBanner:Actor{
	default{
		+nointeraction
		+wallsprite
		renderstyle "add";
		height 1;radius 1;
		alpha 0.8;
	}
	states{
	spawn:
		BAL1 A 0;
		---- A 1{
			alpha=frandom(0.7,0.9);
			angle+=1.;
		}wait;
	}
}
class HDFlagCappedBanner:HDFlagBanner{
	default{
		+floatbob
		scale 2.;
	}
	states{
	spawn:
		BAL1 A 0;
		---- A 1{
			alpha+=frandom(-0.007,0.004);
			angle+=1.;
			if(alpha<0.001)destroy();
		}wait;
	}
}
class HDCapFlag:HDWeapon{
	default{
		+weapon.wimpy_weapon
		+weapon.cheatnotweapon
		+inventory.invbar
		inventory.pickupsound "misc/p_pkup";
		inventory.pickupmessage "You got the flag!";
	}
	override void ownerdied(){
		owner.dropinventory(self);
		weaponstatus[CAPFS_PROGRESS]=0;
	}
	override void initializewepstats(bool idfa){
		weaponstatus[CAPFS_TEAM]=-1;
	}
	override void DrawHUDStuff(HDStatusBar sb,HDWeapon hdw,HDPlayerPawn hpl){
		sb.drawimage("BAL1A0",(-32,-22),sb.DI_SCREEN_CENTER_BOTTOM,scale:(0.6,0.6));
		sb.drawwepnum(hdw.weaponstatus[CAPFS_PROGRESS],100);
		string teamname;
		if(hdw.weaponstatus[CAPFS_TEAM]<0)teamname="\cu<none>";
		else teamname=teamplay?teams[hpl.player.getteam()].mname:hpl.player.getusername();
		sb.drawstring(
			sb.psmallfont,teamname,(-12,-16),
			sb.DI_TEXT_ALIGN_RIGHT|sb.DI_TRANSLATABLE|sb.DI_SCREEN_CENTER_BOTTOM,
			Font.CR_BRICK
		);
	}
	override void ondestroy(){
		super.ondestroy();
		if(banner)banner.destroy();
	}
	actor banner;
	override void tick(){
		super.tick();
		if(!banner){
			banner=spawn("HDFlagBanner",pos);
		}
		if(owner||floorz<pos.z){
			banner.binvisible=true;
		}else{
			banner.setorigin((pos.xy,pos.z+24),true);
			banner.binvisible=false;
		}
	}
	states{
	spawn:
		HCAP A 1400;
		HCAP A 0{
			let hhh=hdhandlers(eventhandler.find("hdhandlers"));
			vector3 dest=hhh.getrandomspawnpoint();
			while(dest==pos){dest=hhh.getrandomspawnpoint();}
			spawn("telefog",pos,ALLOW_REPLACE);
			spawn("telefog",dest,ALLOW_REPLACE);
			if(hd_debug)A_Log("Flag moved to ["..dest.x..", "..dest.y..", "..dest.z.."]");
			else A_Log("The flag has moved!");
			setorigin(dest,false);
		}
		loop;
	ready:
		TNT1 A 1{
			invoker.weaponstatus[CAPFS_PROGRESS]=0;
			A_WeaponReady();
		}
		goto readyend;
	fire:
		TNT1 A 0{
			int ownnum=teamplay?player.getteam():playernumber();
			if(
				invoker.weaponstatus[CAPFS_TEAM]!=ownnum
			){
				setweaponstate("holdprogram");
			}else{
				setweaponstate("holdplant");
			}
		}
		TNT1 A 0 A_ClearRefire();
		goto readyend;
	holdplant:
		TNT1 A 1{
			if(!CheckProximity("HDCapFlagpole",96,flags:CPXF_CHECKSIGHT|CPXF_SETTRACER)){
				if(HDCapFlagpole(tracer)){
					A_WeaponMessage("\n\n\n\cgOut of range!\n\cjGo back in there and restart.",70);
				}
				tracer=null;
			}
			let fp=HDCapFlagpole(tracer);
			if(!fp){
				invoker.weaponstatus[CAPFS_PROGRESS]=0;
				setweaponstate("nope");
				return;
			}

			invoker.weaponstatus[CAPFS_PROGRESS]++;
			if(invoker.weaponstatus[CAPFS_PROGRESS]>=CAPF_PROGRESSMAX){
				string planter;
				if(teamplay)planter=teams[player.getteam()].mname.."\cx team!";
				else planter=player.getusername().."\cx!";
				A_PrintBold("\cxFlag planted\n\cxby \cd"..planter,5,"BIGFONT");
				let hhh=hdhandlers(eventhandler.find("hdhandlers"));

				//if in lives mode, undo deaths
				//else add points
				if(teamplay){
					if(fraglimit<100){
						for(int i=0;i<MAXPLAYERS;i++){
							if(
								playeringame[i]
								&&player.getteam()==players[i].getteam()
							)players[i].fragcount+=5;
						}
					}else{
						let hdlc=hdlivescounter.get();
						for(int i=0;i<MAXPLAYERS;i++){
							if(!playeringame[i])continue;
							if(players[i].mo)players[i].mo.UndoPlayerMorph(player,0,true);
							if(
								player.getteam()==players[i].getteam()
							){
								hdlc.deaths[i]--;
							}else{
								if(!random(0,2))hdlc.deaths[i]++;
							}
						}
						hdlc.updatefragcounts(hdlc);
					}
				}else{
					if(fraglimit<100){
						player.fragcount+=10;
					}else{
						let hdlc=hdlivescounter.get();
						int pn=playernumber();
						hdlc.deaths[pn]-=MAXPLAYERS;
						for(int i=0;i<MAXPLAYERS;i++){
							if(
								playeringame[i]
								&&i!=pn
							){
								hdlc.deaths[i]++;
								hdlc.deaths[pn]++;
							}
						}
						hdlc.updatefragcounts(hdlc);
					}
				}

				//reset the flag and pole
				hhh.SpawnFlagpole();

				//destroy the old ones
				spawn("HDExplosion",(fp.pos.xy,fp.pos.z+16),ALLOW_REPLACE);
				spawn("HDFlagCappedBanner",(fp.pos.xy,fp.pos.z+24),ALLOW_REPLACE);
				fp.destroy();
				invoker.weaponstatus[CAPFS_PROGRESS]=0;
				invoker.goawayanddie();
			}
		}
		TNT1 A 0 A_Refire("holdplant");
		goto readyend;
	holdprogram:
		TNT1 A 1{
			invoker.weaponstatus[CAPFS_PROGRESS]++;
			if(invoker.weaponstatus[CAPFS_PROGRESS]>=CAPF_PROGRESSMAX){
				string planter;
				if(teamplay)planter=teams[player.getteam()].mname.."\cr team!";
				else planter=player.getusername().."\cr!";
				A_PrintBold("\crFlag programmed\n\crto \cd"..planter,3,"BIGFONT");
				invoker.weaponstatus[CAPFS_TEAM]=teamplay?player.getteam():playernumber();
				invoker.weaponstatus[CAPFS_PROGRESS]=0;
				invoker.translation=translation;
				setweaponstate("nope");
			}
		}
		TNT1 A 0 A_Refire("holdprogram");
		goto readyend;
	altfire:
		TNT1 A 1 A_DropInventory("HDCapFlag");
		TNT1 A 1 A_ClearRefire();
		goto ready;
	}
}
enum HDCapFlagNums{
	CAPFS_TEAM=1,
	CAPFS_PROGRESS=2,

	CAPF_PROGRESSMAX=100,
}
