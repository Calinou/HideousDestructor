// ------------------------------------------------------------
//   Additional player functions
// ------------------------------------------------------------

extend class HDPlayerPawn{
	actor antenna;
	void A_MoveAntenna(vector3 newpos){
		if(!antenna){
			antenna=spawn("IdleDummy");
			antenna.A_SetSize(3,3,3);
		}
		antenna.setorigin(newpos,false);
	}

	//check mantling
	//returns: -1 cannot mantle; 0 cannot mantle but on ground; 1 can mantle
	int MantleCheck(){
		bool onground;
		int res=-1;
		if(zat==pos.z){
			onground=true;
			res=0;
		}

		//determine max height
		int mantlemax=36;
		if((player.readyweapon is "NullWeapon" || player.readyweapon is "Ring") && beatmax>18){
			if(onground) mantlemax=64;
			else mantlemax=56;
		}
		//place the antenna
		A_MoveAntenna(pos+vel+(cos(angle)*18,sin(angle)*18,mantlemax));
		//check if blocked
		mantlemax=antenna.getzat();
		if((mantlemax-pos.z)<=maxstepheight) return res; //don't mantle steppables
		if(antenna.getzat(flags:GZF_CEILING)-mantlemax<1) return res; //can't squeeze fingers in
		if(antenna.pos.z<mantlemax) return res; //too high to reach and grab

		//thrust player upwards and forwards
		if(
			onground
			&& !(getplayerinput(MODINPUT_OLDBUTTONS) && BT_JUMP)
		){
			if(beatmax<24)vel.z+=4;
			else vel.z+=7;
			beatmax--;
		}else vel.z+=3;
		return 1;
	}
	//and jump. don't separate from mantling.
	void JumpCheck(){
		if(
			beatmax>14
			&& getplayerinput(MODINPUT_BUTTONS) & BT_JUMP //replace with event asap
			&& !MantleCheck()
			&& !(getplayerinput(MODINPUT_OLDBUTTONS) & BT_JUMP)
		){
			double jumppower=7;
			if(beatmax<20) jumppower=3;
			else if(beatmax<24) jumppower=5;
			double jz=jumppower*0.6;
			double fm=getplayerinput(MODINPUT_FORWARDMOVE);
			double sm=getplayerinput(MODINPUT_SIDEMOVE);
			if(!sm){
				if(!fm) vel.z+=jz; //straight up
				else if(fm>0){ //forwards
					jumppower*=1.5;
					A_ChangeVelocity(jumppower,0,jz,CVF_RELATIVE);
				}else{ //backwards
					A_ChangeVelocity(-jumppower,0,jz,CVF_RELATIVE);
				}
			}else if(!fm){ //side jump
				if(sm>0) jumppower*=-1;
				A_ChangeVelocity(0,jumppower,jz,CVF_RELATIVE);
			}else{ //diagonal jump
				int smult=1;
				int fmult=1;
				if(fm<0) fmult=-1;
				if(sm>0) smult=-1;
				jumppower*=HDCONST_ONEOVERSQRTTWO;
				A_ChangeVelocity(jumppower*fmult,jumppower*smult,jz,CVF_RELATIVE);
			}
			if(height<40)beatmax-=5;
			else beatmax-=2;
		}
	}

	//
	actor muzzle;
	bool MuzzleBlock(){
		if(barehanded) return false;
		if(!muzzle){
			muzzle=spawn("HDMuzzleBlocker",pos);
		}
		double barrellength=24;

		//replace this section once weapons are scriptified
		name wp=player.readyweapon.getclassname();
		if(wp=="Vulcanette")barrellength=28;
		else if(wp=="BFG9k")barrellength=26;
		else if(wp=="RocquetteLauncher")barrellength=28;
		else if(wp=="BossRifle")barrellength=32;
		else if(wp=="ThunderBuster")barrellength=26;
		else if(wp=="Lumberjack")barrellength=26;
		else if(wp=="Hunter")barrellength=28;
		else if(wp=="LiberatorGrenadeRifle")barrellength=25;
		else if(wp=="LiberatorRifle")barrellength=25;
		else if(wp=="ZM66GrenadeRifle")barrellength=23;
		else if(wp=="ZM66Rifle")barrellength=23;
		else if(wp=="ZM66SemiRifle")barrellength=23;
		else if(wp=="Brontornis")barrellength=22;
		else if(wp=="Slayer")barrellength=20;
		else if(wp=="HDSMG")barrellength=20;
		else if(wp=="Blooper")barrellength=18;
		else if(wp=="HDPistol")barrellength=3;

		barrellength-=radius; //don't bother checking within the player!
		vector3 frac=(cos(pitch),0,-sin(pitch));
		frac.xy=rotatevector(frac.xy,angle);

		bool hitleft;bool hitright;bool hittop;bool hitbottom;
		double bump=max(0.3,abs(hdmath.anglechange(lastangle,angle))*0.05);

		muzzle.setorigin(pos+(cos(angle+90)*2,sin(angle+90)*2,height-12)+frac*radius,false);
		for(int i=0;i<barrellength;i++){
			muzzle.addz(frac.z);
			if(
				!muzzle.trymove(muzzle.pos.xy+frac.xy,true,true)
				||muzzle.pos.z<muzzle.floorz
			){
				driftleft-=bump;
				hitleft=true;
			}
		}
		muzzle.setorigin(pos+(cos(angle-90)*2,sin(angle-90)*2,height-12)+frac*radius,false);
		for(int i=0;i<barrellength;i++){
			muzzle.addz(frac.z);
			if(
				!muzzle.trymove(muzzle.pos.xy+frac.xy,true,true)
				||muzzle.pos.z<muzzle.floorz
			){
				driftleft+=bump;
				hitright=true;
			}
		}
		muzzle.setorigin(pos+(0,0,height-11)+frac*radius,false);
		for(int i=0;i<barrellength;i++){
			muzzle.addz(frac.z);
			if(
				!muzzle.trymove(muzzle.pos.xy+frac.xy,true,true)
				||muzzle.pos.z<muzzle.floorz
			){
				driftdown+=bump;
				hittop=true;
			}
		}
		muzzle.setorigin(pos+(0,0,height-14)+frac*radius,false);
		for(int i=0;i<barrellength;i++){
			muzzle.addz(frac.z);
			if(
				!muzzle.trymove(muzzle.pos.xy+frac.xy,true,true)
				||muzzle.pos.z<muzzle.floorz
			){
				driftdown-=bump;
				hitbottom=true;
			}
		}
		if(hitright || hitleft || hittop || hitbottom){
			if(hitright&&hitleft&&hittop&&hitbottom){
				A_ChangeVelocity(-1,0,0,CVF_RELATIVE);
				A_GiveInventory("IsMoving",2);
				if(
					instatesequence(curstate,resolvestate("spawn"))
				)setstatelabel("see");
			}
			return true;
		}
		return false;
	}

	//constant polling for weapon inertia and muzzle climb
	double driftleft;
	double driftdown;
	vector3 muzzlevel;
	void Gunertia(){
		double mult=0.01;
		double dec=12;
		double yaw=getplayerinput(MODINPUT_YAW)*HDCONST_YAWTODEGREE;
		double ptch=getplayerinput(MODINPUT_PITCH)*HDCONST_YAWTODEGREE;

		//reduced drift while supported.
		if(countinv("issupported") && yaw<5){
			A_SetAngle(lastangle-yaw*0.1,SPF_INTERPOLATE);
			A_SetPitch(lastpitch-ptch*0.1,SPF_INTERPOLATE);
			mult*=0.4;dec*=0.6;
		}
		//reduced turning while crouched.
		else if(height<40 && abs(yaw)>3){
			A_SetAngle(lastangle-yaw*0.2,SPF_INTERPOLATE);
			mult*=0.6;dec*=0.6;
		}

		//replace this section once weapons are scriptified
		name wp=player.readyweapon.getclassname();
		if(barehanded){
			mult=0;
			dec=0.1;
		}
		else if(wp=="Vulcanette")mult*=5
			+((countinv("VulcJuice")||countinv("VulcEmptyCell"))?0.2:0)
			+0.001*(
			+countinv("VulcMag1")+countinv("VulcLoaded1")
			+countinv("VulcMag2")+countinv("VulcLoaded2")
			+countinv("VulcMag3")+countinv("VulcLoaded3")
			+countinv("VulcMag4")+countinv("VulcLoaded4")
			+countinv("VulcMag5")+countinv("VulcLoaded5")
		);
		else if(wp=="BFG9k")mult*=5.5+0.6*countinv("BFGLoaded");
		else if(wp=="RocquetteLauncher")mult*=4
			+0.2*(countinv("RocketMag"))
			+0.5*(countinv("HEATLoaded"));
		else if(wp=="BossRifle")mult*=5;
		else if(wp=="ThunderBuster")
			mult*=4+((countinv("PlasmaBattery")||countinv("PlasmaEmptyCell"))?0.2:0);
		else if(wp=="Lumberjack")
			mult*=4+((countinv("LumberCell")>0||countinv("LumberEmptyCell")>0)?0.3:0);
		else if(wp=="Hunter"){
			if(countinv("ShotgunTube")>3)mult*=countinv("ShotgunTube")*0.2;
			else mult*=4;
		}
		else if(wp=="LiberatorGrenadeRifle")mult*=4.2-0.25*countinv("LiberatorNoMag")+0.2*countinv("LiberatorGrenadeChamber");
		else if(wp=="LiberatorRifle")mult*=3.6-0.2*countinv("LiberatorNoMag");
		else if(wp=="ZM66GrenadeRifle")mult*=3.8-0.2*countinv("ZM66NoMag")+0.2*countinv("ZM66GLoaded");
		else if(wp=="ZM66Rifle")mult*=3.4-0.2*countinv("ZM66NoMag");
		else if(wp=="ZM66SemiRifle")mult*=3.4-0.2*countinv("ZM66NoMag");
		else if(wp=="Brontornis")mult*=3.5;
		else if(wp=="Slayer")mult*=3;
		else if(wp=="HDSMG")mult*=3-0.3*countinv("HDSMGNoMag");
		else if(wp=="Blooper")mult*=2.5+0.5*countinv("BloopChamber");
		else if(wp=="HDPistol")mult*=2;

		dec=clamp(dec*mult,0,0.9);
		yaw*=mult;ptch*=mult;

		//resistance from weapon
		angle-=yaw*HDCONST_YAWTODEGREE*mult;

		//apply the drift
		if(driftleft){
			A_SetAngle(angle+driftleft,SPF_INTERPOLATE);
			driftleft*=dec;
		}
		if(driftdown){
			A_SetPitch(pitch+driftdown,SPF_INTERPOLATE);
			driftdown*=dec;
		}

		//add to inertia
		driftleft+=yaw;
		driftdown-=ptch;

		//even more inertia
		if(muzzlevel!=vel){
			vector3 diff=muzzlevel-vel;
			muzzlevel=vel;
			if(diff.length()<30){
				vector3 notionalpos=(
					cos(pitch)*cos(angle),
					cos(pitch)*sin(angle),
					-sin(pitch)
				)*24+diff;
				double abshorz=notionalpos.xy.length();
				double nangle=atan2(notionalpos.y,notionalpos.x);
				if(nangle<0)nangle+=360;
				double npitch=-atan2(notionalpos.z,abshorz);
				nangle=hdmath.anglechange(angle,nangle);

				if(abs(npitch)<60)driftleft+=nangle*mult*4;
				driftdown+=(npitch-pitch)*mult*4;
			}
		}

		//feet angle
		dec=hdmath.anglechange(angle,feetangle); //we won't be using dec after this
		if(pos.z==zat && abs(dec)>50-20*countinv("IsCrouching")){
			A_SetAngle(angle-yaw*0.3,SPF_INTERPOLATE);
			A_ChangeVelocity(0,dec/abs(dec)*0.1,0,CVF_RELATIVE);
			A_GiveInventory("IsMoving",2);
			feetangle+=clamp(angle-feetangle,-10,10);
			if(
				instatesequence(curstate,resolvestate("spawn"))
			)setstatelabel("see");
		}
	}

	//Muzzle climb!
	void MuzzleClimb(
		double down,
		double left,
		bool doublemoving=true
	){
		if(doublemoving && countinv("ismoving")){down*=2;left*=2;}
		driftdown+=down;
		driftleft+=left;
	}

	//not actually checking to stumble, but to slow down on bad terrain
	bool StumbleCheck(){
		if(zat!=pos.z) return false;
		vector2 p=rotatevector((
			getplayerinput(MODINPUT_FORWARDMOVE)*0.005,
			getplayerinput(MODINPUT_SIDEMOVE)*-0.005
		),angle);
		if(p==(0,0)) return false;
		//if trying to sprint, quardruple effective input
		if(runwalksprint>0) p*=4;
		A_MoveAntenna(pos+(p.x,p.y,zat));
		if(zat-antenna.getzat()>16) return true;
		return false;
	}



	//the heart
	const HDCONST_MINHEARTTICS = 5; //35/5*60=420 beats per minute!
	int beatcount;
	int beatmax;
	int beatcap;
	int beatcounter;
	int stimcount;
	int regenblues;
	int woundcount;
	int newwoundcount;
	int oldwoundcount;
	int aggravateddamage;
	void HeartTicker(){
		if(bkilled) return; //don't really need this...

		//on every beat
		if(beatcount>0){
			beatcount--;
			pitch-=0.00001*beatcount*(1+2*(35-beatmax));
		}else{
			//limit beatmax
			if(countinv("PowerStrength")) beatmax=clamp(beatmax,4,14);
			else beatmax=clamp(beatmax,HDCONST_MINHEARTTICS,35);

			if(beatmax<8)DamageMobj(self,self,1,"internal");

			//reset beatcount, subject to stims
			if(stimcount) beatcount=beatmax-random(1,2);
				else beatcount=beatmax;
			A_SetBlend("66 10 12",0.3-0.3*(health*0.01),beatcount);
			pitch+=0.002*beatcount*(1+(35-beatmax));
			beatcounter++;

			//sprinting
			if(cansprint && runwalksprint>0)beatmax--;

			//adrenalized vessels begin to relax...
			if(newwoundcount>0 && (beatmax>32||beatmax>=beatcap)){
				newwoundcount--;woundcount++;
			}

			//magical healing stops imminent danger first
			if(regenblues>0 && woundcount+newwoundcount>0){
				newwoundcount--;woundcount--;
				regenblues--;
			}

			//don't go negative wound
			if(newwoundcount<0)newwoundcount=0;
			if(woundcount<0)woundcount=0;

			if(beatcounter%4==0){	//every 4 beats
				//recovering heart rate
				if(beatmax<beatcap) beatmax++;
			}
			if(beatcounter%12==0){	//every 12 beats
				//you're either gaining or losing health
				if(woundcount)A_DamageSelf(random(1,woundcount),"bleedout");
				else healthing(1);

				if(stimcount>0)stimcount--;
				if(regenblues>0 && oldwoundcount+aggravateddamage>0){
					oldwoundcount-=2;aggravateddamage--;
					regenblues--;
					if(oldwoundcount<0)oldwoundcount=0;
					if(aggravateddamage<0)aggravateddamage=0;
				}
				if(woundcount>0 && beatmax<26 && random(1,7==1)){
					newwoundcount++;woundcount--;
				}
			}
			if(beatcounter%20==0){	//every 20 beats
				beatcap=35;

				//updating beatcap (minimum heart rate)
				if(health<40) beatcap=clamp(beatcap,1,24);
				else if(health<60) beatcap=clamp(beatcap,1,32);
				if(woundcount>10) beatcap=clamp(beatcap,1,12);    
				else if(woundcount>5) beatcap=clamp(beatcap,1,24);

				//keep stim below cap as long as it's above 12
				if(stimcount>0 && beatcap>12)    
					beatcap=clamp(beatcap,12,beatcap-1);
			}
			if(beatcounter==120){	//every 120 beats
				beatcounter=0;	//reset
				if(random(70,health)==100-aggravateddamage)oldwoundcount--;
			}
		}
	}
}

class HDMuzzleBlocker:HDActor{
	default{
		-solid -nogravity -shootable
		height 1;radius 1;
	}
}