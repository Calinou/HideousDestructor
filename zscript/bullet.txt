// ------------------------------------------------------------
// The Bullet!
// ------------------------------------------------------------

//testing performance when spamming
class HDBulletb:PlasmaBall replaces PlasmaBall{
	override void postbeginplay(){
		if(!hd_debug){super.postbeginplay();return;}
		for (int i=14;i;i--){
			A_SpawnItemEx("HDBullet",0,0,0,vel.x+frandom(-1,1),vel.y+frandom(-1,1),vel.z+frandom(-1,1),0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEMOMENTUM);
		}
		destroy();
	}
}

class HDBullet:HDActor{
	/*
		special usages:
		accuracy: hardness/pointiness.
		woundhealth: "extra" damage from frangibility, etc.
	*/
	double grav;
	double oneoverspeed;
	double speedsquared;
	bool inthesky;
	flinetracedata blt;
	line lasthitline;
	actor throughthis;
	double penetration; //juvenile giggling

	class<actor> distantsounder;
	property distantsounder:distantsounder;

	enum BulletConsts{
		BULLET_TERMINALVELOCITY=-277,
		BULLET_CRACKINTERVAL=64,
	}
	default{
		projectile; -nogravity
		+noextremedeath +cannotpush +hittracer +forcexybillboard
		height 0.05;radius 0.05;
		maxstepheight 0;
		missileheight 0; projectilekickback 20;
		damagefunction(0);
		hdbullet.distantsounder "none";

		mass 40; //60 426
		speed 40;//accuracy 20;
		pushfactor 0.1;
	}
	override void beginplay(){
		damagetype="SmallArms0"; //how do you set this in the defaults???
		super.beginplay();
		lasthitline=null;
	}
	override void postbeginplay(){
		super.postbeginplay();
		throughthis=target;
		if(distantsounder!="none"){
			actor m=spawn(distantsounder,pos,ALLOW_REPLACE);
			m.target=target;
		}
		grav=getgravity();
		if(target && !pitch)pitch=target.pitch;

		//these are particular to true bullets and not grenades.
		LongArmWobble();
		Gunsmoke();
		/*
			this is included in initialization because all pre-ZScript weapon code
			would A_SpawnItemEx the bullets adding only the shooter's own momentum,
			leaving the bullet to set its own state.
			summoning a bullet will cause it to go twice as fast.
		*/
		A_ChangeVelocity(speed*cos(pitch),0,speed*sin(-pitch),CVF_RELATIVE);
	}
	states{
	spawn:
		BAL1 A -1 nodelay{
			if(!hd_debug){
				tics=0;
				scale=(0.3,0.3);
			}
		}
		BLET A -1;
	}
	override void tick(){
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			bnointeraction=true;
			actor.tick();
			return;
		}


		//if it's in the sky, do a separate thing instead
		if(inthesky){
			setorigin(pos+vel,true);
			if(ceilingz>pos.z)inthesky=false;
			if(vel.z>BULLET_TERMINALVELOCITY)vel.z-=grav;
			//nexttic
			if(CheckNoDelay()){
				if(tics>0)tics--;  
				while(!tics){
					if(!SetState(CurState.NextState)){
						return;
					}
				}
			}
			return;
		}


		//point actor in velocity
		//set some basic variables
		speed=vel.length();
		speedsquared=vel dot vel;
		penetration=speedsquared*mass*accuracy*0.000000001/pushfactor*frandom(0.9,1.1);
		A_FaceMovementDirection();

		//hack to escape shooter
		bool bsbak=false;
		if(throughthis){
			bsbak=throughthis.bshootable;
			throughthis.bshootable=false;
		}

		//get the line
		LineTrace(
			angle,
			speed,
			pitch,
			flags:0,
			data:blt
		);

		//reset hacks
		if(throughthis){
			throughthis.bshootable=bsbak;
			throughthis=null;
		}


		//find points close to players and spawn crackers
		//also spawn trails if applicable
		if(speed>256){
			name b="";
			if(speed>1000){
				if(mass>200) b="SupersonicTrailBig";
				else b="SupersonicTrail";
			}else if(speed>800){
				b="SupersonicTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				b="SupersonicTrailSmall";
			}else if(speed>100){
				b="SubsonicTrail";
			}
			if(b!=""){
				vector3 crackbak=pos;
				vector3 crackinterval=blt.hitdir*BULLET_CRACKINTERVAL;
				int j=max(1,blt.distance*(1./BULLET_CRACKINTERVAL));
				for(int i=0;i<j;i++){
					setxyz(crackbak+crackinterval*i);
					if(missilename)spawn(missilename,pos);
					bool gotplayer=false;
					for(int k=0;!gotplayer && k<MAXPLAYERS;k++){
						if(playeringame[k] && players[k].mo){
							if(
								distance3d(players[k].mo)<256
							){
								gotplayer=true;
								spawn(b,pos);
							}
						}
					}
				}
				setxyz(crackbak);
			}
		}

		//set the new position
		setorigin(blt.hitlocation,true);

		//it's (probably) not coming back up
		bool zricochet=false;
		if(blt.hittype==Trace_HitFloor){
			if(floorpic==skyflatnum){
				destroy();return;
			}
			zricochet=true;
		}
		//but it can come back down
		if(blt.hittype==Trace_HitCeiling){
			if(ceilingpic==skyflatnum){
				inthesky=true;
				return;
			}
			zricochet=true;
		}
		//another way to come up or down
		if(zricochet){
			setz(clamp(pos.z,floorz+1,ceilingz-1));
			double velxy=max(abs(vel.x),abs(vel.y));
			if(
				frandom(-speed,frandom(-speed,velxy))>abs(vel.z)
			){
				Puff(speed*0.3);
				vel.z=-frandom(0.1,0.9)*vel.z;
				vel.xy=rotatevector(vel.xy,frandom(-45,45)*pushfactor);
				vel*=frandom(0.6,0.9);
			}else{
				Puff();destroy();return;
			}
		}

		//all other situations
		CheckPortalTransition();

		if(blt.hitline){
			let hitline=blt.hitline;

			//way less hacky horizon line check
			if(hitline.special==Line_Horizon){destroy();return;}

			//STILL PRETTY HACKY lower sky ceiling check
			if(
				hitline.backsector
				&&hitline.frontsector
			){
				sector othersector=
					hitline.backsector==blt.hitsector?
					hitline.frontsector:hitline.backsector;
				if(
					othersector.gettexture(othersector.ceiling)==skyflatnum
					&&othersector.ceilingplane.zatpoint
						(blt.hitlocation.xy+blt.hitdir.xy)<blt.hitlocation.z
				){
					inthesky=true;
					return;
				}
			}

			//check if moving through void
			if(
				lasthitline
				&&!lasthitline.backsector
				&&blt.distance>penetration
			){
				destroy();return;
			}

			BulletImpact(hitline);
			if(bdestroyed)return;

			//update last hit line
			lasthitline=hitline;
		}

		if(blt.hitactor){
			BulletImpact(blt.hitline,blt.hitactor);
			if(bdestroyed)return;
		}

		//drop and wobble
		if(vel.z>BULLET_TERMINALVELOCITY)vel.z-=grav;
		if(pushfactor)A_Changevelocity(
			-frandom(0,pushfactor)*0.01*speed,
			frandom(-pushfactor,pushfactor),
			0,CVF_RELATIVE
		);
		//nexttic
		if(CheckNoDelay()){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}

	//impact
	virtual void BulletImpact(line hitline=null,actor hitactor=null){
		if(max(abs(pos.x),abs(pos.y))>=32678){destroy();return;}
		if(hitactor){
			throughthis=hitactor;
			tracer=hitactor;
			BulletImpactDamage(hitactor);
			if(vel dot vel<(50*50)){
				destroy();return;
			}else{
				vel.xy=rotatevector(vel.xy,frandom(-10,10)*pushfactor);
				vel.z*=pushfactor*frandom(-0.4,0.4);
			}
		}else if(hitline){
			//these get used a lot
			vector3 hitdir=blt.hitdir;
			vector3 hitlocation=blt.hitlocation;

			//save the hitline info for future reference
			lasthitline=hitline;

			//decal
			name decal="BulletChip";
			if(penetration<4.)decal="BulletChipSmall";
			setorigin(hitlocation-hitdir*4,false);
			A_SprayDecal(decal,max(12,penetration*2));

			//ricochet
			if(!random(0,15)){
				bmissile=true;
				vel.xy=rotatevector(vel.xy,frandom(0,360))*0.9;
				vel.z=frandom(-vel.z,vel.z*0.8);
				Puff(speed*0.9);
				return;
			}else Puff();

			if(
				penetration<=0
				||(!hd_penetrate&&!deathmatch&&skill<5)
			){destroy();return;}


			//pierce
			setorigin(hitlocation+hitdir*min(10,penetration),false);
			if(floorz>=pos.z||ceilingz<=pos.z){destroy();return;}

			bool backsectorceilingfloor=(
				hitline.backsector
				&&hitline.backsector.floorplane.zatpoint(hitlocation.xy+hitdir.xy)<pos.z
				&&hitline.backsector.ceilingplane.zatpoint(hitlocation.xy+hitdir.xy)>pos.z
			);

			angle=-angle;pitch=-pitch;
			if(backsectorceilingfloor)A_SprayDecal(decal,max(12,penetration*2));
			LineAttack(
				angle,penetration*2,pitch,0,"none",
				"PenePuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ
			);
			angle=-angle;pitch=-pitch;

			//final goodbye
			if(vel dot vel<(50*50)){
				destroy();return;
			}
		}
	}
	//apply damage and blood
	void BulletImpactDamage(actor victim){
		int dmg=woundhealth*mass*0.002;
		int maxdmg=mass*speedsquared*0.0000002;

		//set damagetype
		bool pierced=true;
		double victimthickness=max(
			victim.radius*0.1,
			victim.spawnhealth()*0.01
		);
		if(penetration>victimthickness){damagetype="SmallArms3";vel*=0.9;}
		else if(penetration>victimthickness*0.6){damagetype="SmallArms2";vel*=0.8;}
		else if(penetration>victimthickness*0.4){damagetype="SmallArms1";vel*=0.4;}
		else if(penetration>victimthickness*0.2){damagetype="SmallArms1";vel*=0.2;}
		else{
			damagetype="Bashing";
			pierced=false;
			vel*=0.1;
		}

		if(
			pierced&&
			(!(victim is "HDPlayerPawn")||hdplayerpawn(victim).armourlevel<1)
		){
			dmg*=frandom(1,3);
			maxdmg=max(dmg,maxdmg);
		}

		//extra damage for hitting ~center of mass
		vector3 hitdir=blt.hitdir;
		vector3 extrapolation=pos+hitdir*victim.radius;
		vector3 victimheart=victim.pos;
		victimheart.z+=victim.height*0.6;
		extrapolation=victimheart-extrapolation;
		double distancefromheart=extrapolation dot extrapolation;
		double victimheartsize=victim.radius*0.3;
		if(distancefromheart<victimheartsize*victimheartsize){
			if(hd_debug)A_Log("CRIT!");
			if(pierced)maxdmg*=2;
			else maxdmg+=speed/100;
		}

		//determine net damage
		dmg=random(dmg,maxdmg);
		if(hd_debug){
			string targ="";
			if(victim.player)targ=victim.player.getusername();
				else targ=victim.getclassname();
			A_Log(string.format("%s \ca%i \cj%s",self.getclassname(),dmg,targ));
		}

		//don't place puff/blood right on edge of box - looks bad with too many
		setorigin(pos+hitdir*random(1,victim.radius),false);

		//puff or bleed as appropriate
		if(bbloodlessimpact||!victim.bshootable||victim.bnoblood)Puff();
		else for(int i=0;i<dmg;i+=40){
			victim.A_SpawnItemEx(
				victim.bloodtype,
				//comes out of actor itself
				(pos.x-victim.pos.x)*frandom(0.6,0.9),
				(pos.y-victim.pos.y)*frandom(0.6,0.9),
				(pos.z-victim.pos.z)*frandom(0.6,0.9),
				frandom(3,6),frandom(-1,1),frandom(1,3),
				180,
				SXF_USEBLOODCOLOR|
				SXF_NOCHECKPOSITION|
				SXF_ABSOLUTEPOSITION
			);
		}

		//gibbing
		if(victim.bcorpse){
			int gibs=max(randompick(0,0,0,1),dmg*0.05);
			victim.A_GiveInventory("SawGib",gibs);
		}

		//do this last, as it can destroy some actors leading to an address zero crash
		victim.damagemobj(self,self.target,dmg,damagetype,DMG_THRUSTLESS);
	}
	virtual actor Puff(int sp=0){
		if(max(abs(pos.x),abs(pos.y))>=32678)return null;
		if(!sp)sp=speed;
		name pufftype="BulletPuffBig";
		if(sp>800){
			pufftype="BulletPuffBig";
		}else if(sp>512){
			pufftype="BulletPuffMedium";
		}else{
			pufftype="BulletPuffSmall";
		}
		bool gbg;actor ppp;
		[gbg,ppp]=A_SpawnItemEx(pufftype,flags:
			SXF_NOCHECKPOSITION
		);
		return ppp;
	}
	virtual void Gunsmoke(){
		actor gs;
		double j=cos(pitch);
		vector3 vk=(j*cos(angle),j*sin(angle),-sin(pitch));
		j=max(1,speed*min(mass,100)*0.00001);
		for(int i=0;i<j;i++){
			gs=spawn("HDGunSmoke",pos+i*vk,ALLOW_REPLACE);
			gs.pitch=pitch;gs.angle=angle;gs.vel=vk*j;
		}
	}
	void LongArmWobble(){
		let hdp=hdplayerpawn(target);
		if(hdp&&hdp.scopecamera){
			pitch+=deltaangle(hdp.pitch,hdp.scopecamera.pitch);
			angle+=deltaangle(hdp.angle,hdp.scopecamera.angle);
		}else if(countinv("IsMoving",AAPTR_TARGET)>=10){
			pitch+=frandom(-2,2);
			angle+=frandom(-1,1);
		}
	}
}
class NewBulletMovePuff:CheckPuff{
	default{
		+skyexplode //important!
	}
}
class SupersonicTrail:IdleDummy{
	states{
	spawn:
		TNT1 A 10;stop;
	}
	override void postbeginplay(){
		if(!random(0,2))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.32);
	}
}
class SupersonicTrailBig:SupersonicTrail{
	override void postbeginplay(){
		A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.42);
	}
}
class SupersonicTrailSmall:SupersonicTrail{
	override void postbeginplay(){
		if(!random(0,4))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",0,0.1);
	}
}
class SubsonicTrail:SupersonicTrail{
	override void postbeginplay(){
		A_PlaySound("weapons/subfwoosh",0,0.03);
	}
}






// transitional?

//special usage:accuracy=variation
//A_GiveInventory("DecoBulleter");
class DecoBulleter:ActionItem{
	default{
		missiletype "HDBullet";
	}
	states{
	pickup:
		TNT1 A 0{
			actor p=spawn(invoker.missilename,pos+(0,0,height-6));
			if(!p)return;
			p.target=self;p.angle=angle;p.pitch=pitch;
			if(invoker.speed)p.speed=invoker.speed;
			double pf=invoker.accuracy;
			if(pf){
				p.vel+=(
					frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
				);
				p.speed+=10*frandom(-pf,pf);
			}
			p.vel+=self.vel;
		}fail;
	}
}
class DecoBulleter9f:DecoBulleter{
	default{
		missiletype "HDBullet9";
		speed 500;
		accuracy 1;
	}
}



//the actual bullets!
class HDBulletFrag:HDBullet{
	default{
		woundhealth 2;
	}
	override void postbeginplay(){
		HDActor.PostBeginPlay();

		grav=getgravity();
		pushfactor=frandom(0.8,2.);
		mass=random(100,150);
		accuracy=random(3,6);
	}
	override actor Puff(int sp){
		if(max(abs(pos.x),abs(pos.y))>=32678)return null;
		actor ppp;
		[sp,ppp]=A_SpawnItemEx("FragPuff",flags:
			SXF_NOCHECKPOSITION
		);
		return ppp;
	}
}
class HDBullet9:HDBullet{
	default{
		pushfactor 0.5;
		mass 1539;
		speed 480;
		accuracy 4;
	}
}
class HDBullet426:HDBullet{
	default{
		pushfactor 0.6;
		mass 320;
		speed 1200;
		accuracy 6;
		woundhealth 6;
		hdbullet.distantsounder "DistantRifle";
	}
}
class HDBullet776:HDBullet{
	default{
		pushfactor 0.3;
		mass 1176;
		speed 1100;
		accuracy 17;
		woundhealth 7;
		hdbullet.distantsounder "DoubleDistantRifle";
	}
}
class HDBullet00:HDBullet{
	default{
		pushfactor 0.9;
		mass 576;
		accuracy 5;
		woundhealth 0;
	}
	override void postbeginplay(){
		HDActor.postbeginplay();
		Gunsmoke();
		grav=getgravity();
	}
}
class HDBullet00b:HDBullet00{
	default{
		stamina 7; //claymores in the future?
		speed 700;
		pushfactor 0.5;
	}
	override void postbeginplay(){
		LongArmWobble();
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		actor bb;
		double p=pushfactor;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			hdbullet(bb).throughthis=target;
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(bb.speed*cos(bb.pitch),0,bb.speed*sin(-bb.pitch),CVF_RELATIVE);
		}
		destroy();
	}
}
class HDBullet00bfl:HDBullet00b{
	default{
		speed 800;
		pushfactor 0.3;
		accuracy -1;
	}
	override void postbeginplay(){
		LongArmWobble();
		setorigin(pos+(cos(angle-90),sin(angle-90),0)*accuracy,false);
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		angle+=accuracy*0.1;

		actor bb;
		double p=pushfactor;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			hdbullet(bb).throughthis=target;
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(
				bb.speed*cos(bb.pitch),0,
				bb.speed*sin(-bb.pitch),CVF_RELATIVE
			);
		}
		destroy();
	}
}
class HDBullet00bfr:HDBullet00bfl{
	default{
		accuracy 1;
	}
}
class HDBullet00bf:HDBullet00bfl{ //used for super shotgun guys
	default{
		accuracy 0;
	}
}
class HDBullet00bf2:HDBullet00bfl{
	override void postbeginplay(){
		LongArmWobble();
		for(double i=-1;i<=3;i+=3){
			setorigin(pos+(cos(angle-90),sin(angle-90),0)*i,false);
			spawn("DistantShotgun",pos,ALLOW_REPLACE);
			angle+=i*0.1;

			actor bb;
			double p=pushfactor;
			for(int ii=stamina;ii;ii--){
				bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
				hdbullet(bb).throughthis=target;
				bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
				bb.speed=speed+speed*frandom(-p,p);
				bb.pitch+=frandom(-p,p);
				bb.angle+=frandom(-p,p);
				bb.A_ChangeVelocity(
					bb.speed*cos(bb.pitch),0,
					bb.speed*sin(-bb.pitch),CVF_RELATIVE
				);
			}
		}
		destroy();
	}
}


