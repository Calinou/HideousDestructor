// ------------------------------------------------------------
// The Bullet!
// ------------------------------------------------------------

//testing performance when spamming
class HDBulletb:PlasmaBall{//replaces PlasmaBall{
	override void postbeginplay(){
		if(!hd_debug){super.postbeginplay();return;}
		for (int i=14;i;i--){
			A_SpawnItemEx("HDBullet",0,0,0,vel.x+frandom(-1,1),vel.y+frandom(-1,1),vel.z+frandom(-1,1),0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEMOMENTUM);
		}
		destroy();
	}
}

class HDBullet:HDActor{
	/*
		special usages:
		accuracy: penetration distance.
		woundhealth: "extra" damage from frangibility, etc.
	*/
	actor a;int b;
	vector3 crackvel;
	double grav;
	double hitdist;
	double oneoverspeed;
	double shootz;
	int dmg;
	bool inthesky;
	line firstblockingline;

	class<actor> distantsounder;
	property distantsounder:distantsounder;

	default{
		projectile; -nogravity
		+noextremedeath +cannotpush +hittracer +forcexybillboard
		height 0.05;radius 0.05;
		maxstepheight 0;
		missileheight 0; projectilekickback 20;
		damagefunction(0);
		hdbullet.distantsounder "none";

		mass 40; //40 426, 50 : 00, 80 776, 90 9mil, 600 40mm
		speed 40;//accuracy 20;
		pushfactor 0.1;
	}
	override void beginplay(){
		damagetype="SmallArms0"; //how do you set this in the defaults???
		super.beginplay();
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(distantsounder!="none"){
			actor m=spawn(distantsounder,pos,ALLOW_REPLACE);
			m.target=target;
		}
		shootz = height*0.5+8;
		grav=getgravity();
		if(target && !pitch)pitch=target.pitch;

		//these are particular to true bullets and not grenades.
		LongArmWobble();
		Gunsmoke();
		/*
			this is included in initialization because all pre-ZScript weapon code
			would A_SpawnItemEx the bullets adding only the shooter's own momentum,
			leaving the bullet to set its own state.
			summoning a bullet will cause it to go twice as fast.
		*/
		A_ChangeVelocity(speed*cos(pitch),0,speed*sin(-pitch),CVF_RELATIVE);
	}
	states{
	spawn:
		BAL1 A -1 nodelay{
			if(!hd_debug){
				tics=0;
				scale=(0.3,0.3);
			}
		}
		BLET A -1;
	}
	override void tick(){
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			//nexttic
			if(CheckNoDelay()){
				if(tics>0)tics--;  
				while(!tics){
					if(!SetState(CurState.NextState)){
						return;
					}
				}
			}
			return;
		}

		//if it's in the sky, do a separate thing instead
		if(inthesky){
			setorigin(pos+vel,false);
			if(ceilingz>pos.z) inthesky=false;
			if(vel.z>-277)vel.z-=grav;
			//nexttic
			if(CheckNoDelay()){
				if(tics>0)tics--;  
				while(!tics){
					if(!SetState(CurState.NextState)){
						return;
					}
				}
			}
			return;
		}

		//point actor in velocity
		speed=vel.length();
		A_FaceMovementDirection();

		//b is never used.
		bool bsbak=false;
		if(!bseeinvisible&&target){
			bsbak=target.bshootable;
			target.bshootable=false; //hack to escape shooter
		}
		[a,b]=LineAttack(angle,speed,pitch,0,"none",
			"NewBulletMovePuff",
			flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ
		);

		//reset hacks
		if(!bseeinvisible && target)target.bshootable=bsbak;
		bseeinvisible=true;

		if(a){
			hitdist=distance3d(a);

			//find points close to players and spawn crackers
			CrackType();

			//it got shot into the sky!
			if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
				inthesky=true;
			}else{
				setorigin(a.pos,true);
				CheckPortalTransition();

				if(missilename)Effect();

				//NOW test for impacts...

				//used for a few things
				vector3 posbak;

				//lower sky ceiling check
				posbak=a.pos;
				a.setorigin(a.pos+(cos(angle),sin(angle),0)*4,false);
				if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
					setorigin(a.pos,false);
					inthesky=true;
					return;
				}
				a.setorigin(posbak,false);

				//SUPER HACKY horizon line check
				posbak=pos;
				vector2 sizbak=(radius,height);
				a_setsize(12,4);
				if(
					!trymove(posbak.xy+1*(cos(angle),sin(angle)),true,true)
					&& blockingline && blockingline.special==Line_Horizon
				){
					destroy();return;
				}
				setorigin(posbak,false);
				a_setsize(sizbak.x,sizbak.y);

				//save the blockingline info for future reference
				if(blockingline){
					firstblockingline=blockingline;
				}


				//finally, the "real" impacts
				if(floorz>pos.z||ceilingz<=pos.z+height){
					Puff();destroy();return;
				}else if(abs(hitdist-speed)>radius){
					BulletImpact();
					if(bdestroyed)return;
				}
			}
		}
		//destroy immediately if on a sky floor.
		if(!a||(floorz>pos.z&&floorpic==skyflatnum)){
			destroy();return;
		}

		//drop and wobble
		vel.z-=grav;
		if(pushfactor)A_Changevelocity(
			-frandom(0,pushfactor)*0.01*speed,
			frandom(-pushfactor,pushfactor),
			0,CVF_RELATIVE
		);
		//nexttic
		if(CheckNoDelay()){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}

	//impact
	virtual void BulletImpact(){
		bmissile=false;
		if(a && a.tracer){
			BulletImpactDamage();
			destroy();return;
		}else{
			//decal
			//if anyone knows how to prevent this from showing up on the wrong side, let me know!
			name decal="BulletChip";
			if(dmg<80)decal="BulletChipSmall";
			A_SprayDecal(decal,radius+4); //dunno why minimum is +4

			//ricochet
			if(!random(0,15)){
				bmissile=true;
				vel.xy=rotatevector(vel.xy,frandom(0,360))*0.9;
				vel.z=frandom(-vel.z,vel.z*0.8);
				Puff(speed*0.9);
			}

			//pierce
			else if((hd_penetrate||deathmatch) && accuracy){
				Puff(speed*0.4);
				actor e;
				vector3 velp=vel.unit();
				vector3 velpp=velp;
				velp*=accuracy;
				double oz=pos.z;
				setorigin(pos+velp,false);

				//disappear if stuck inside the floor or ceiling.
				//I have no idea why this doesn't work.
				if(ceilingz<pos.z||floorz>pos.z){
					destroy();return;
				}

				//find exact point of exit.
				angle+=180;pitch*=-1;
				[e,b]=LineAttack(
					angle,accuracy+2,pitch,0,"none","NewBulletMovePuff",
					flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT|LAF_OVERRIDEZ
				);

				//if there's any place to put a check for the void, place it here.
				//basically: check of firstblockingline is the same as what e hits,
				//and if e.blockingline has no front sector.


				//exit hole.
				//I have no idea why this won't work for raised floors.
				A_SprayDecal(decal,max(5,accuracy+2));

				//reorient bullet.
				angle+=180;pitch*=-1;

				//place at point of exit, puff, continue.
				setorigin(e.pos+velpp,false);
				if(speed>500){
					actor pp=spawn("PenePuff",e.pos+velpp,ALLOW_REPLACE);
					pp.vel=vel*0.006;
				}else Puff(speed*1.4);
				vel*=0.9;
				accuracy=0;
				bmissile=true;
			}

			//final puff
			else{
				Puff();
				destroy();return;
			}
		}
	}
	//apply damage and blood
	void BulletImpactDamage(){
		dmg+=mass*speed*0.0003+woundhealth;
		int maxdmg=dmg*2;

		//set damagetype
		int penetrability=(2.-pushfactor)*(accuracy+speed)+random(-200,200);
		if(penetrability>1500)damagetype="SmallArms3";
		else if(penetrability>1100)damagetype="SmallArms2";
		else if(penetrability>600)damagetype="SmallArms1";
		else damagetype="SmallArms0";


		//supersonic shockwave damage
		if(speed>HDCONST_SPEEDOFSOUND)maxdmg*=1.2;

		//extra damage for hitting ~center of mass
		double cang=angle;
		double cpi=pitch;
		A_Face(a.tracer);
		if(absangle(angle,cang)<12){
			double th=a.tracer.height;
			double pz=pos.z-sin(cpi)*a.tracer.radius;
			pz=abs(a.tracer.pos.z+(th*0.61)-pz);
			if(pz*5<th){
				if(hd_debug)A_Log("CRIT!");
				maxdmg*=2;
			}
		}
		angle=cang;pitch=cpi;

		//determine net damage
		dmg=random(dmg,maxdmg);
		if(hd_debug){
			string targ="";
			if(a.tracer.player)targ=a.tracer.player.getusername();
				else targ=a.tracer.getclassname();
			A_Log(string.format("%s \ca%i \cj%s",self.getclassname(),dmg,targ));
		}

		//don't place puff/blood right on edge of box - looks bad with too many
		setorigin(pos+(
			cos(pitch)*cos(angle)*random(1,a.tracer.radius),
			cos(pitch)*sin(angle)*random(1,a.tracer.radius),
			sin(-pitch)*random(1,a.tracer.radius)
		),false);

		//puff or bleed as appropriate
		if(bbloodlessimpact||!a.tracer.bshootable||a.tracer.bnoblood)Puff();
		else for(int i=0;i<dmg;i+=40){
			a.tracer.A_SpawnItemEx(
				a.tracer.bloodtype,
				//comes out of actor itself
				(a.pos.x-a.tracer.pos.x)*frandom(0.6,0.9),
				(a.pos.y-a.tracer.pos.y)*frandom(0.6,0.9),
				(a.pos.z-a.tracer.pos.z)*frandom(0.6,0.9),
				random(3,6),random(-1,1),random(1,3),
				180,
				SXF_USEBLOODCOLOR|
				SXF_NOCHECKPOSITION|
				SXF_ABSOLUTEPOSITION
			);
		}

		//gibbing
		if(a.tracer.bcorpse){
			int gibs=max(randompick(0,0,0,1),dmg*0.05);
			a.tracer.A_GiveInventory("SawGib",gibs);
		}

		//do this last, as it can destroy some actors leading to an address zero crash
		a.tracer.damagemobj(self,self.target,dmg,damagetype,DMG_THRUSTLESS);
	}
	//generate puff
	virtual void Puff(int sp=0){
		if(max(abs(pos.x),abs(pos.y))>=32678)return;
		if(!sp)sp=speed;
		name pufftype="BulletPuffBig";
		if(sp>800){
			pufftype="BulletPuffBig";
		}else if(sp>512){
			pufftype="BulletPuffMedium";
		}else{
			pufftype="BulletPuffSmall";
		}
		A_SpawnItemEx(pufftype,flags:
			SXF_NOCHECKPOSITION
		);
	}
	//sets crack sound
	void CrackType(){
		if(speed>256){
			name b="";
			if(speed>1000){
				if(mass>80) b="SupersonicTrailBig";
				else b="SupersonicTrail";
			}else if(speed>800){
				b="SupersonicTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				b="SupersonicTrailSmall";
			}else if(speed>100){
				b="SubsonicTrail";
			}

			if(b=="")return;

			crackvel=vel*64/hitdist;
			int k=hitdist*(1./64);

			actor cracker=spawn("idledummy",pos);
			for(int j=0;j<k;j++){
				cracker.setorigin(cracker.pos+crackvel,false);
				bool p=false;
				for(int i=0;!p && i<MAXPLAYERS;i++){
					if(playeringame[i] && players[i].mo){
						if(
							cracker.distance3d(players[i].mo)<256
						){
							p=true;
							spawn(b,cracker.pos);
						}
					}
				}
			}
			cracker.destroy();
		}
	}
	virtual void Gunsmoke(){
		actor gs;
		double j=cos(pitch);
		vector3 vk=(j*cos(angle),j*sin(angle),-sin(pitch));
		j=max(1,speed*min(mass,100)*0.00001);
		for(int i=0;i<j;i++){
			gs=spawn("HDGunSmoke",pos+i*vk,ALLOW_REPLACE);
			gs.pitch=pitch;gs.angle=angle;gs.vel=vk*j;
		}
	}
	virtual void LongArmWobble(){
		if(countinv("IsMoving",AAPTR_TARGET)>=10){
			pitch+=frandom(-2,2);
			angle+=frandom(-1,1);
		}
	}
	virtual void Effect(
		class<Actor> trailtype="None",
		int numactors=12,
		double spacing=4,
		double velmul=0.6
	){
		if(!bmissile||!speed) return;
		if(trailtype=="None")trailtype=missilename;
		if(!trailtype)return;
		vector3 frac=-vel.unit()*spacing;
		vector3 trvel=vel*0.006+(0,0,2);
		numactors=speed/spacing;
		for(int i=numactors;i;i--){
			actor tr=spawn(trailtype,pos,ALLOW_REPLACE);
			if(tr.pos.z>tr.ceilingz-10)tr.destroy();
			tr.setorigin(pos+frac*i,true);
			tr.vel=trvel;
		}
	}
}
class NewBulletMovePuff:CheckPuff{
	default{
		+skyexplode //important!
	}
}
class SupersonicTrail:IdleDummy{
	states{
	spawn:
		TNT1 A 10;stop;
	}
	override void postbeginplay(){
		if(!random(0,2))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.32);
	}
}
class SupersonicTrailBig:SupersonicTrail{
	override void postbeginplay(){
		A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.42);
	}
}
class SupersonicTrailSmall:SupersonicTrail{
	override void postbeginplay(){
		if(!random(0,4))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",0,0.1);
	}
}
class SubsonicTrail:SupersonicTrail{
	override void postbeginplay(){
		A_PlaySound("weapons/subfwoosh",0,0.03);
	}
}








// transitional?

//special usage:accuracy=variation
//A_GiveInventory("DecoBulleter");
class DecoBulleter:ActionItem{
	default{
		missiletype "HDBullet";
	}
	states{
	pickup:
		TNT1 A 0{
			actor p=spawn(invoker.missilename,pos+(0,0,height-6));
			if(!p)return;
			p.target=self;p.angle=angle;p.pitch=pitch;
			if(invoker.speed)p.speed=invoker.speed;
			double pf=invoker.accuracy;
			if(pf){
				p.vel+=(
					frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
				);
				p.speed+=10*frandom(-pf,pf);
			}
			p.vel+=self.vel;
		}fail;
	}
}
class DecoBulleter9f:DecoBulleter{
	default{
		missiletype "HDBullet9";
		speed 500;
		accuracy 1;
	}
}



//the actual bullets!
class HDBulletFrag:HDBullet{
	default{
		woundhealth 1;
	}
	override void postbeginplay(){
		HDActor.PostBeginPlay();
		shootz = height*0.5+8;

		grav=getgravity();
		pushfactor=frandom(0.6,1);
		mass=random(15,60);
		accuracy=random(0,4);
	}
	override void Puff(int sp){
		if(max(abs(pos.x),abs(pos.y))>=32678)return;
		A_SpawnItemEx("FragPuff",flags:
			SXF_NOCHECKPOSITION
		);
	}
}
class HDBullet9:HDBullet{
	default{
		pushfactor 0.5;
		mass 90;
		speed 480;
		accuracy 9;
	}
}
class HDBullet426:HDBullet{
	default{
		pushfactor 0.6;
		mass 60;
		speed 1200;
		accuracy 6;
		woundhealth 6;
		hdbullet.distantsounder "DistantRifle";
	}
}
class HDBullet776:HDBullet{
	default{
		pushfactor 0.3;
		mass 100;
		speed 1100;
		accuracy 17;
		woundhealth 7;
		hdbullet.distantsounder "DoubleDistantRifle";
	}
}
class HDBullet00:HDBullet{
	default{
		pushfactor 0.9;
		mass 50;
		accuracy 8;
		woundhealth 0;
	}
	override void postbeginplay(){
		HDActor.postbeginplay();
		Gunsmoke();
		shootz = height*0.5+8;
		grav=getgravity();
	}
}
class HDBullet00b:HDBullet00{
	default{
		stamina 7; //claymores in the future?
		speed 700;
		pushfactor 0.5;
	}
	override void postbeginplay(){
		LongArmWobble();
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		actor bb;
		double p=pushfactor;
		if(target && !pitch)pitch=target.pitch;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(bb.speed*cos(bb.pitch),0,bb.speed*sin(-bb.pitch),CVF_RELATIVE);
		}
		destroy();
	}
}
class HDBullet00bfl:HDBullet00b{
	default{
		speed 800;
		pushfactor 0.3;
		accuracy -1;
	}
	override void postbeginplay(){
		LongArmWobble();
		setorigin(pos+(cos(angle-90),sin(angle-90),0)*accuracy,false);
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		angle+=accuracy*0.1;

		actor bb;
		double p=pushfactor;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(
				bb.speed*cos(bb.pitch),0,
				bb.speed*sin(-bb.pitch),CVF_RELATIVE
			);
		}
		destroy();
	}
}
class HDBullet00bfr:HDBullet00bfl{
	default{
		accuracy 1;
	}
}
class HDBullet00bf:HDBullet00bfl{ //used for super shotgun guys
	default{
		accuracy 0;
	}
}
class HDBullet00bf2:HDBullet00bfl{
	override void postbeginplay(){
		LongArmWobble();
		for(double i=-1;i<=3;i+=3){
			setorigin(pos+(cos(angle-90),sin(angle-90),0)*i,false);
			spawn("DistantShotgun",pos,ALLOW_REPLACE);
			angle+=i*0.1;

			actor bb;
			double p=pushfactor;
			for(int ii=stamina;ii;ii--){
				bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
				bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
				bb.speed=speed+speed*frandom(-p,p);
				bb.pitch+=frandom(-p,p);
				bb.angle+=frandom(-p,p);
				bb.A_ChangeVelocity(
					bb.speed*cos(bb.pitch),0,
					bb.speed*sin(-bb.pitch),CVF_RELATIVE
				);
			}
		}
		destroy();
	}
}




