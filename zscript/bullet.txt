// ------------------------------------------------------------
// The Bullet!
// ------------------------------------------------------------

//testing performance when spamming
class HDBulletb:PlasmaBall{//replaces PlasmaBall{
	override void postbeginplay(){
		if(!hd_debug){super.postbeginplay();return;}
		for (int i=14;i;i--){
			A_SpawnItemEx("HDBullet",0,0,0,vel.x+frandom(-1,1),vel.y+frandom(-1,1),vel.z+frandom(-1,1),0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEMOMENTUM);
		}
		destroy();
	}
}

class HDBullet:HDActor{
	/*
		special usages:
		accuracy: penetration distance.
		woundhealth: "extra" damage from frangibility, etc.
	*/
	actor a;int b;
	vector3 crackvel;
	double grav;
	double hitdist;
	double oneoverspeed;
	double shootz;
	int dmg;
	bool inthesky;
	default{
		projectile; -nogravity
		+bloodsplatter +noextremedeath +cannotpush +hittracer +forcexybillboard
		height 0.05;radius 0.05;
		maxstepheight 0;
		missileheight 0; projectilekickback 20;
		damagefunction(0);

		mass 40; //40 426, 50 00, 80 776, 90 9mil, 600 40mm
		speed 40;//accuracy 20;
		pushfactor 0.1;
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(missilename){
			actor m=spawn(missilename,pos,ALLOW_REPLACE);
			m.target=target;
		}
		shootz = height*0.5+8;
		grav=getgravity();
		if(target && !pitch)pitch=target.pitch;

		//these are particular to true bullets and not grenades.
		LongArmWobble();
		Gunsmoke();
		/*
			this is included in initialization because all pre-ZScript weapon code
			would A_SpawnItemEx the bullets adding only the shooter's own momentum,
			leaving the bullet to set its own state.
			summoning a bullet will cause it to go twice as fast.
		*/
		A_ChangeVelocity(speed*cos(pitch),0,speed*sin(-pitch),CVF_RELATIVE);
	}
	states{
	spawn:
		BAL1 A -1 nodelay{
			if(!hd_debug){
				tics=0;
				scale=(0.3,0.3);
			}
		}
		BLET A -1;
	}
	override void tick(){
		ClearInterpolation();
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			nexttic();
			return;
		}

		//if it's in the sky, do a separate thing instead
		if(inthesky){
			setorigin(pos+vel,false);
			if(ceilingz>pos.z) inthesky=false;
			if(vel.z>-277)vel.z-=grav;
			nexttic();
			return;
		}

		//point actor in velocity
		speed=vel.length();
		A_FaceMovementDirection();

		//LineAttack always has a zoffset of centre+8.
		//b is never used.
		if(!bseeinvisible && target)target.bshootable=false; //hack to escape shooter
		addz(-shootz);
		[a,b]=LineAttack(angle,speed,pitch,0,"none",
			"NewBulletMovePuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT
		);

		//reset hacks
		addz(shootz);
		if(!bseeinvisible && target)target.bshootable=true;
		bseeinvisible=true;

		if(a){
			hitdist=distance3d(a);

			//it got shot into the sky!
			if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
				inthesky=true;
			}
			else{
				setorigin(a.pos,true);

				//find points close to players and spawn crackers
				CrackType();

				//NOW test for impacts...

				//used for a few things
				vector3 posbak;

				//lower sky ceiling check
				posbak=a.pos;
				a.setorigin(a.pos+(cos(angle),sin(angle),0)*4,false);
				if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
					setorigin(a.pos,false);
					inthesky=true;
					return;
				}
				a.setorigin(posbak,false);

				//SUPER HACKY horizon line check
				posbak=pos;
				vector2 sizbak=(radius,height);
				a_setsize(12,4);
				if(!trymove(posbak.xy+1*(cos(angle),sin(angle)),true,true)){
					if(blockingline && blockingline.special == Line_Horizon){
						destroy();return;
					}
				}
				setorigin(posbak,false);
				a_setsize(sizbak.x,sizbak.y);


				//finally, the "real" impacts
				if(floorz>pos.z || ceilingz<=pos.z+height){
					Puff();destroy();return;
				}else if(abs(hitdist-speed)>radius){
					BulletImpact();
					if(bdestroyed)return;
				}
			}
		}
		if(!a || (floorz>pos.z && floorpic==skyflatnum)){
			destroy();
			return;
		}

		//drop and wobble
		vel.z-=grav;
		if(pushfactor)A_Changevelocity(
			-frandom(0,pushfactor)*0.01*speed,
			frandom(-pushfactor,pushfactor),
			0,CVF_RELATIVE
		);
		nexttic();
	}

	//impact
	virtual void BulletImpact(){
		bmissile=false;
		if(a && a.tracer){
			BulletImpactDamage();
			destroy();return;
		}else{
			//decal
			name decal="BulletChip";
			if(dmg<80)decal="BulletChipSmall";
			A_SprayDecal(decal,radius+4); //dunno why minimum is +4
				//if anyone knows how to prevent this from showing up on the wrong side, let me know!

			//ricochet
			if(!random(10,19)){
				bmissile=true;
				vel.xy=rotatevector(vel.xy,frandom(0,360));
				vel.z=frandom(-vel.z,vel.z*0.8);
				vel.xy*=0.9;
				Puff(speed*0.9);
			}

			//pierce
			else if(hd_penetrate && accuracy){
				Puff(speed*0.4);
				actor e;
				vector3 velp=(cos(pitch)*cos(angle),cos(pitch)*sin(angle),-sin(pitch));
				vector3 velpp=velp*2;
				velp*=accuracy;
				double oz=pos.z;
				setorigin(pos+velp,false);

				//disappear if stuck inside the floor or ceiling.
				//I have no idea why this doesn't work.
				if(ceilingz<pos.z||floorz>pos.z){
					destroy();return;
				}

				//find exact point of exit.
				angle+=180;pitch*=-1;
				addz(-shootz);[e,b]=LineAttack(
					angle,accuracy+2,pitch,0,"none","NewBulletMovePuff",
					flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT
				);addz(shootz);

				//exit hole.
				//I have no idea why this won't work for raised floors.
				A_SprayDecal(decal,max(5,accuracy+2));

				//reorient bullet.
				angle+=180;pitch*=-1;

				//place at point of exit, puff, continue.
				setorigin(e.pos+velpp,false);
				if(speed>500){
					actor pp=spawn("PenePuff",e.pos+velpp,ALLOW_REPLACE);
					pp.vel=vel*0.003;
				}else Puff(speed*1.4);
				vel*=0.9;
				accuracy=0;
				bmissile=true;
			}

			//final puff
			else{
				Puff();
				destroy();return;
			}
		}
	}
	//apply damage and blood
	void BulletImpactDamage(){
		dmg+=mass*speed*0.0003+woundhealth;
		int maxdmg=dmg*2;

		//supersonic shockwave damage
		if(speed>HDCONST_SPEEDOFSOUND)maxdmg*=1.2;

		//crit
		double cang=angle;
		double cpi=pitch;
		A_Face(a.tracer);
		if(abs(HDMath.AngleChange(cang,angle))<12){
			double th=a.tracer.height;
			double pz=pos.z-sin(cpi)*a.tracer.radius;
			pz=abs(a.tracer.pos.z+(th*0.61)-pz);
			if(pz*5<th){
				if(hd_debug)A_Log("CRIT!");
				maxdmg*=2;
			}
		}
		angle=cang;pitch=cpi;

		//apply damage
		dmg=random(dmg,maxdmg);
		if(hd_debug)A_Log(string.format("%s \ca%i \cj%s",self.getclassname(),dmg,a.tracer.getclassname()));

		//puff or bleed as appropriate
		if(bbloodlessimpact)return;
		else if(!a.tracer.bshootable||a.tracer.bnoblood) Puff();
		else for(int i=0;i<dmg;i+=40){
			a.tracer.A_SpawnItemEx(
				a.tracer.bloodtype,
				0,0,a.pos.z-a.tracer.pos.z, //comes out of actor itself. actually looks decent.
				random(3,6),random(-1,1),random(1,3),
				angle-180,
				SXF_USEBLOODCOLOR|
				SXF_NOCHECKPOSITION|
				SXF_ABSOLUTEPOSITION|
				SXF_ABSOLUTEANGLE
			);
		}

		//do this last, as it can destroy some actors leading to an address zero crash
		a.tracer.damagemobj(self,self.target,dmg,damagetype,DMG_THRUSTLESS);
	}
	//generate puff
	virtual void Puff(int sp=0){
		if(!sp)sp=speed;
		name pufftype="BulletPuffBig";
		if(sp>800){
			pufftype="BulletPuffBig";
		}else if(sp>512){
			pufftype="BulletPuffMedium";
		}else{
			pufftype="BulletPuffSmall";
		}
		A_SpawnItemEx(pufftype,flags:
			SXF_NOCHECKPOSITION
		);
	}
	//sets crack sound and damage type
	void CrackType(){
		if(speed>256){
			name b="HDNineMilTrail";
			if(speed>1000){
				A_SetDamageType("SmallArms3");
				if(mass>80) b="HDSevenMilTrail";
				else b="HDFourMilTrail";
			}else if(speed>800){
				A_SetDamageType("SmallArms2");
				b="HDFourMilTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				A_SetDamageType("SmallArms1");
				b="HDBuckTrail";
			}else if(speed>100){
				A_SetDamageType("SmallArms0");
				b="HDNineMilTrail";
			}else{
				A_SetDamageType("SmallArms0");
			}
			if(woundhealth>50)
				A_SetDamageType("SmallArms3");
			if(damagetype=="SmallArms1" && woundhealth>30)
				A_SetDamageType("SmallArms2");
			if(damagetype=="SmallArms0" && woundhealth>30)
				A_SetDamageType("SmallArms2");
			else if(damagetype=="SmallArms0" && woundhealth>10)
				A_SetDamageType("SmallArms1");

			crackvel=vel/hitdist*64;
			int k=hitdist*1/64;
			actor cracker=spawn("idledummy",pos);
			for(int j=0;j<k;j++){
				cracker.setorigin(cracker.pos-crackvel,false);
				bool p;p=false;
				for(int i=0;!p && i<MAXPLAYERS;i++){
					if(playeringame[i] && players[i].mo){
						if(
							cracker.distance3d(players[i].mo)<256
						){
							p=true;
							spawn(b,cracker.pos);
						}
					}
				}
			}
			cracker.destroy();
		}
	}
	virtual void Gunsmoke(){
		int j=max(1,speed*min(mass,100)*0.00001);
		for(int i=0;i<j;i++){
			A_SpawnItemEx("HDGunSmoke",cos(pitch)*i,0,-sin(pitch)*i,
				cos(pitch)*2,0,-sin(pitch)*2,flags:SXF_NOCHECKPOSITION
			);
		}
	}
	virtual void LongArmWobble(){
		if(countinv("IsMoving",AAPTR_TARGET)>=10){
			pitch+=frandom(-2,2);
			angle+=frandom(-1,1);
		}
	}
	virtual void Effect(class<Actor> trailtype="HDGunSmoke",int numactors=12,double spacing=4,double velmul=0.6){
		if(!bmissile || !speed) return;
		vector3 frac=-vel/speed*spacing;
		vector3 trvel=vel*0.6+(0,0,2);
		for(int i=numactors;i;i--){
			actor tr=spawn(trailtype,pos);
			tr.setorigin(pos+frac*i,true);
			tr.vel=trvel;
		}
	}
}
class NewBulletMovePuff:IdleDummy{
	default{
		+puffgetsowner +alwayspuff +puffonactors +bloodlessimpact +hittracer
		+skyexplode //important!
	}
	states{
	spawn:
		TNT1 A 1;
		stop;
	}
}




// transitional?

//special usage:accuracy=variation
//A_GiveInventory("DecoBulleter");
class DecoBulleter:ActionItem{
	default{
		missiletype "HDBullet";
	}
	states{
	pickup:
		TNT1 A 0{
			actor p=Spawn(invoker.missilename,pos+(0,0,height-6));
			p.target=self;p.angle=angle;p.pitch=pitch;
			if(invoker.speed)p.speed=invoker.speed;
			double pf=invoker.accuracy;
			if(p){
				if(pf){
					p.vel+=(
						frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
					);
					p.speed+=10*frandom(-pf,pf);
				}
				p.vel+=self.vel;
			}
		}fail;
	}
}
class DecoBulleter426:DecoBulleter{
	default{
		missiletype "HDBullet426";
	}
}
class DecoBulleter426s:DecoBulleter426{
	default{
		speed 1100;
		accuracy 2;
	}
}
class DecoBulleter776:DecoBulleter{
	default{
		missiletype "HDBullet776";
	}
}
class DecoBulleter776f:DecoBulleter776{
	default{
		speed 1400;
	}
	states{
	pickup:
		TNT1 A 0{
			actor p=Spawn("HDBullet776",pos+(0,0,height-6));
			p.target=self;p.angle=angle;p.pitch=pitch;
			p.speed=1400;
			p.vel+=self.vel;
			p.pitch-=countinv("BossMOA")*0.0083333;
		}fail;
	}
}
class DecoBulleter9:DecoBulleter{
	default{
		missiletype "HDBullet9";
		accuracy 5;
	}
}
class DecoBulleter9f:DecoBulleter9{
	default{
		speed 500;
		accuracy 1;
	}
}
class DecoBulleter00:DecoBulleter{
	default{
		missiletype "HDBullet00b";
		accuracy 1;
	}
}
class DecoBulleter00f:DecoBulleter00{
	default{
		missiletype "HDBullet00bf";
		accuracy 0;
	}
}
class DecoBulleter00f2:DecoBulleter00f{
	states{
	pickup:
		TNT1 A 0{
			for(double i=-1;i<2;i+=2){
				actor p=Spawn(invoker.missilename,pos+(0,0,height-6));
				p.setorigin(p.pos+(cos(angle-90),sin(angle+90),0)*i,false);
				p.target=self;p.angle=angle;p.pitch=pitch;
				if(invoker.speed)p.speed=invoker.speed;
				double pf=invoker.accuracy;
				if(p){
					if(pf){
						p.vel+=(
							frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
						);
						p.speed+=10*frandom(-pf,pf);
					}
					p.vel+=self.vel;
				}
			}
		}fail;
	}
}
class DecoBulleterGhost:DecoBulleter{
	default{
		missiletype "GhostBullet";
	}
}


class HDBullet426:HDBullet{
	default{
		pushfactor 0.6;
		mass 40;
		speed 1200;
		accuracy 6;
		woundhealth 6;
		missiletype "DistantRifle";
	}
}
class HDBullet776:HDBullet{
	default{
		pushfactor 0.3;
		mass 90;
		speed 1100;
		accuracy 17;
		woundhealth 7;
		missiletype "DoubleDistantRifle";
	}
}
class HDBullet00:HDBullet{
	default{
		pushfactor 0.9;
		mass 50;
		accuracy 8;
		woundhealth 0;
	}
	override void postbeginplay(){
		HDActor.postbeginplay();
		Gunsmoke();
		shootz = height*0.5+8;
		grav=getgravity();
	}
}
class HDBullet00b:HDBullet00{
	default{
		stamina 7; //claymores in the future?
		speed 700;
		pushfactor 0.5;
	}
	override void postbeginplay(){
		LongArmWobble();
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		actor bb;
		double p=pushfactor;
		if(target && !pitch)pitch=target.pitch;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(bb.speed*cos(bb.pitch),0,bb.speed*sin(-bb.pitch),CVF_RELATIVE);
		}
		destroy();
	}
}
class HDBullet00bf:HDBullet00b{
	default{
		speed 800;
		pushfactor 0.3;
	}
}
class HDBullet9:HDBullet{
	default{
		pushfactor 0.5;
		mass 90;
		speed 480;
		accuracy 9;
	}
}
class HDBulletFrag:HDBullet{
	default{
		woundhealth 2;
	}
	override void postbeginplay(){
		HDActor.PostBeginPlay();
		shootz = height*0.5+8;
		grav=getgravity();
		pushfactor=frandom(0.1,1);
		mass=random(1,4)*20;
		accuracy=random(0,2)*6;
	}
	override void Puff(int sp=0){
		A_SpawnItemEx("FragPuff",flags:
			SXF_NOCHECKPOSITION
		);
	}
}
class GhostBullet:HDBullet426{
	override void BulletImpact(){
		bmissile=false;
		spawn("FragPuff",pos,ALLOW_REPLACE); //no debris spawned
		if(a.tracer && a.tracer.bshootable && !a.tracer.bkilled){
			a.tracer.damagemobj(self,target,-1,"none");
			a.tracer.damagemobj(self,target,1,"none");
		}
		destroy();return;
	}
}




