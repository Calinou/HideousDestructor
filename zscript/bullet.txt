// ------------------------------------------------------------
// The Bullet!
// ------------------------------------------------------------

//testing performance when spamming
class HDBulletb:PlasmaBall replaces PlasmaBall{
	override void postbeginplay(){
		if(!hd_debug){super.postbeginplay();return;}
		for (int i=14;i;i--){
			A_SpawnItemEx("HDBullet",0,0,0,vel.x+frandom(-1,1),vel.y+frandom(-1,1),vel.z+frandom(-1,1),0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEMOMENTUM);
		}
		destroy();
	}
}

class HDBullet:HDActor{
	/*
		special usages:
		accuracy: hardness/pointiness.
		woundhealth: "extra" damage from frangibility, etc.
	*/
	double grav;
	double oneoverspeed;
	double speedsquared;
	bool inthesky;
	transient flinetracedata blt;
	sector othersector;
	actor throughthis;
	double penetration; //juvenile giggling

	class<actor> distantsounder;
	property distantsounder:distantsounder;

	enum BulletConsts{
		BULLET_TERMINALVELOCITY=-277,
		BULLET_CRACKINTERVAL=64,

		BLT_HITTOP=1,
		BLT_HITBOTTOM=2,
		BLT_HITMIDDLE=3,
		BLT_HITONESIDED=4,
	}
	default{
		projectile; -nogravity
		+noextremedeath +cannotpush +hittracer +forcexybillboard
		height 0.05;radius 0.05;
		maxstepheight 0;
		missileheight 0; projectilekickback 20;
		damagefunction(0);
		hdbullet.distantsounder "none";

		mass 40; //60 426
		speed 40;//accuracy 20;
		pushfactor 0.1;
	}
	override void beginplay(){
		damagetype="SmallArms0"; //how do you set this in the defaults???
		super.beginplay();
		othersector=null;
	}
	override void postbeginplay(){
		super.postbeginplay();
		throughthis=target;
		if(distantsounder!="none"){
			actor m=spawn(distantsounder,pos,ALLOW_REPLACE);
			m.target=target;
		}
		grav=getgravity();
		if(target && !pitch)pitch=target.pitch;

		//these are particular to true bullets and not grenades.
		LongArmWobble();
		Gunsmoke();
		/*
			this is included in initialization because all pre-ZScript weapon code
			would A_SpawnItemEx the bullets adding only the shooter's own momentum,
			leaving the bullet to set its own state.
			summoning a bullet will cause it to go twice as fast.
		*/
		A_ChangeVelocity(speed*cos(pitch),0,speed*sin(-pitch),CVF_RELATIVE);
	}
	states{
	spawn:
		BLET A -1 nodelay{
			if(hd_debug){
				tics=0;
			}else scale=(0.3,0.3);
		}
		BAL1 A -1;
	}
	override void tick(){
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			bnointeraction=true;
			actor.tick();
			return;
		}


		//if it's in the sky, do a separate thing instead
		if(inthesky){
			setorigin(pos+vel,true);
			if(ceilingz>pos.z)inthesky=false;
			if(vel.z>BULLET_TERMINALVELOCITY)vel.z-=grav;
			//nexttic
			if(CheckNoDelay()){
				if(tics>0)tics--;  
				while(!tics){
					if(!SetState(CurState.NextState)){
						return;
					}
				}
			}
			return;
		}


		//point actor in velocity
		//set some basic variables
		speed=vel.length();
		speedsquared=vel dot vel;
		penetration=speed*mass*accuracy*0.000002/pushfactor*frandom(0.9,1.1);
		A_FaceMovementDirection();

		//hack to escape shooter
		bool bsbak=false;
		if(throughthis){
			bsbak=throughthis.bshootable;
			throughthis.bshootable=false;
		}

		//get the line
		LineTrace(
			angle,
			speed,
			pitch,
			flags:0,
			data:blt
		);

		//reset hacks
		if(throughthis){
			throughthis.bshootable=bsbak;
			throughthis=null;
		}
		vector3 plushitdir=blt.hitlocation+blt.hitdir;


		//find points close to players and spawn crackers
		//also spawn trails if applicable
		if(speed>256){
			name b="";
			if(speed>1000){
				if(mass>200) b="SupersonicTrailBig";
				else b="SupersonicTrail";
			}else if(speed>800){
				b="SupersonicTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				b="SupersonicTrailSmall";
			}else if(speed>100){
				b="SubsonicTrail";
			}
			if(b!=""){
				vector3 crackbak=pos;
				vector3 crackinterval=blt.hitdir*BULLET_CRACKINTERVAL;
				int j=max(1,blt.distance*(1./BULLET_CRACKINTERVAL));
				for(int i=0;i<j;i++){
					setxyz(crackbak+crackinterval*i);
					if(hd_debug>1)A_SpawnParticle("yellow",SPF_RELVEL|SPF_RELANG,
						size:12,
						velx:speed*cos(pitch)*0.001,
						velz:-speed*sin(pitch)*0.001
					);
					if(missilename)spawn(missilename,pos);
					bool gotplayer=false;
					for(int k=0;!gotplayer && k<MAXPLAYERS;k++){
						if(playeringame[k] && players[k].mo){
							if(
								distance3d(players[k].mo)<256
							){
								gotplayer=true;
								spawn(b,pos);
							}
						}
					}
				}
				setxyz(crackbak);
			}
		}

		//move to new location
		vector3 posbak=blt.hitlocation;
		setorigin(blt.hitlocation,true);


		//hit actor, ignore all the wall geometry stuff below
		if(blt.hitactor){
			actor hitactor=blt.hitactor;
			tracer=hitactor;
			setorigin(blt.hitlocation+blt.hitdir*frandom(0,hitactor.radius*0.8),true);

			double hitresistance=(hitactor.radius*2+hitactor.spawnhealth()*0.2)*0.3;

			//damagetype?
			if(penetration>7)damagetype="SmallArms3";
			else if(penetration>5)damagetype="SmallArms2";
			else if(penetration>3)damagetype="SmallArms1";
			else if(penetration>0.1)damagetype="SmallArms0";
			else damagetype="Bashing";

			//if within actor, tumble
			if(
				max(abs(pos.x-hitactor.pos.x),abs(pos.y-hitactor.pos.y))
				<hitactor.radius*0.1*woundhealth
			)damagetype=random(0,1)?"SmallArms2":"SmallArms3";

			//crit?
			bool crit;
			double critangle=absangle(angleto(hitactor),angle);
			if(
				abs(
					(hitactor.pos.z+hitactor.height*0.6)-
					(blt.hitlocation.z+blt.hitdir.z*hitactor.radius)
				)<hitactor.height*0.2
				&&
				critangle<12.
			){
				if(hd_debug)A_Log("CRIT!");
				crit=true;
			}

			//pierce?
			bool pierce=false;
			double netpenetration=penetration;
			let hdp=hdplayerpawn(hitactor);
			if(hdp){
				netpenetration=max(0,
					netpenetration-hdp.armourlevel*frandom(1,2)
				);
			}
			netpenetration=min(0.9999,netpenetration/hitresistance);
			if(critangle>frandom(50,150*netpenetration)){
				if(hd_debug)A_Log("Ricochet!");
				throughthis=hitactor;
				angle+=frandom(50,310);pitch+=frandom(-40,40);
				A_ChangeVelocity(cos(pitch)*speed,0,sin(pitch)*-speed,CVF_RELATIVE);
			}
			else if(netpenetration>0.5){
				throughthis=hitactor;
				pierce=true;
			}else if(netpenetration>0.2){
				pierce=true;
			}

			//determine damage
			int dmg=(speed+mass)*0.0099;

			int maxdmg=dmg+woundhealth;
			if(pierce){
				dmg*=2;
				maxdmg+=woundhealth*3;
			}
			if(crit){
				if(pierce){
					dmg*=1.5;
					maxdmg=dmg+woundhealth*6;
				}else dmg*=1.2;
			}
			dmg=random(dmg,maxdmg);
			if(hd_debug){
				string targ="";
				if(hitactor.player)targ=hitactor.player.getusername();
					else targ=hitactor.getclassname();
				A_Log(string.format("%s \ca%i \cj%s  \cu(%s)",self.getclassname(),dmg,targ,damagetype));
			}

			//bleed
			if(
				hitactor.bnoblood
				||!hitactor.bshootable
			){
				Puff();
			}else{
				vector3 hitdir=blt.hitdir;
				for(int i=0;i<dmg;i+=60){
					bool gbg;actor blood;
					[gbg,blood]=A_SpawnItemEx(
						hitactor.bloodtype,
						flags:SXF_USEBLOODCOLOR|
						SXF_NOCHECKPOSITION|
						SXF_ABSOLUTEPOSITION
					);
					if(blood){
						blood.setorigin(pos,false);
						blood.vel=
							throughthis==hitactor?hitdir:-hitdir
							*dmg*0.01
						+(frandom(-2,2),frandom(-2,2),frandom(-2,2));
					}
				}
			}

			//apply damage
			if(hitactor.health<1){
				int gibs=max(randompick(0,0,0,1),dmg*0.05);
				hitactor.A_GiveInventory("SawGib",gibs);
			}else{
				hitactor.damagemobj(self,self.target,dmg,damagetype,DMG_THRUSTLESS);
			}

			//reduce speed
			vel*=netpenetration;
			double rvel=
				netpenetration*pushfactor*speed*0.2
			;
			vel+=(frandom(-rvel,rvel),frandom(-rvel,rvel),frandom(-rvel,rvel));

			//destroy if too slow
			if(vel dot vel<(50*50))destroy();
			return;
		}


		//it's (probably) not coming back up
		bool zricochet=false;
		if(blt.hittype==Trace_HitFloor){
			if(floorpic==skyflatnum){
				destroy();return;
			}
			zricochet=true;
		}
		//but it can come back down
		else if(blt.hittype==Trace_HitCeiling){
			if(ceilingpic==skyflatnum){
				setorigin(posbak+vel,true);
				inthesky=true;
				return;
			}
			zricochet=true;
		}
		//another way to come up or down
		if(zricochet){
			setz(clamp(pos.z,floorz+1,ceilingz-1));
			double velxy=max(abs(vel.x),abs(vel.y));
			if(
				frandom(-speed,frandom(-speed,velxy))
				>abs(vel.z)
			){
				Puff(speed*0.3);
				vel.z=-frandom(0.1,0.9)*vel.z;
				vel.xy=rotatevector(vel.xy,frandom(-45,45)*pushfactor);
				vel*=frandom(0.6,0.9);
				return;
			}
		}

		//this covers a few things that hittype does not
		int hitresult=0;
		if(blt.hitline){
			blt.hitline.activate(target,blt.lineside,SPAC_Impact);
			setorigin(blt.hitlocation-blt.hitdir,false);
			A_SprayDecal(penetration>4?"BulletChip":"BulletChipSmall",10);

			//ricochet
			if(!random(0,10)){
				flinetracedata ricosuave;
				LineTrace(
					angle-40,
					4,
					0,
					flags:TRF_THRUACTORS,
					offsetforward:-1,
					data:ricosuave
				);
				Puff(speed*0.3);
				vel.z=frandom(-0.9,0.9)*vel.z;
				vel.xy*=frandom(0.6,0.9);
				double rnd=frandom(0,90);
				if(ricosuave.hitline==blt.hitline){
					vel.xy=rotatevector((speed,0),angle+rnd);
				}else{
					vel.xy=rotatevector((speed,0),angle-rnd);
				}
				return;
			}
			setorigin(blt.hitlocation,true);

			//evaluate hitlineresult
			if(
				!blt.hitline.backsector
				&&blt.hitline.frontsector!=blt.hitsector
			)hitresult=BLT_HITONESIDED;
			else{
				othersector=hdmath.oppositesector(blt.hitline,blt.hitsector);

				if(!othersector)hitresult=BLT_HITONESIDED;else{
					vector2 zatpointer=plushitdir.xy;
					double otherceilingz=othersector.ceilingplane.zatpoint(zatpointer);
					double otherfloorz=othersector.floorplane.zatpoint(zatpointer);
	
					double hitz=blt.hitlocation.z;
					if(hitz>otherceilingz)hitresult=BLT_HITTOP;
					else if(hitz<otherfloorz)hitresult=BLT_HITTOP;
					else hitresult=BLT_HITMIDDLE;
				}
			}
		}else{
			if(blt.hittype==Trace_HitFloor)hitresult=BLT_HITBOTTOM;
			else if(blt.hittype==Trace_HitCeiling)hitresult=BLT_HITTOP;
		}
		//thin sheet of something that you can't walk through
		if(hitresult==BLT_HITMIDDLE){
			setorigin(plushitdir,true);
			return;
		}
		//have to drill through floor or ceiling
		else if(hitresult==BLT_HITTOP||hitresult==BLT_HITBOTTOM){
			//but first, sky check
			if(
				othersector&&
				othersector.gettexture(othersector.ceiling)==skyflatnum
				&&othersector.ceilingplane.zatpoint
					(plushitdir.xy)<blt.hitlocation.z
			){
				setorigin(pos+vel,true);
				inthesky=true;
				return;
			}
			bool areaclear=false;
			vector3 hitdir=blt.hitdir*4; //4 because we don't want to waste too much time
			vector3 hitloc=blt.hitlocation;
			for(int i=0;i<penetration;i+=4){
				hitloc+=hitdir;
				setorigin(hitloc,true);
				double posz=pos.z;
				if(posz>=floorz&&posz<=ceilingz){
					areaclear=true;
					break;
				}
			}
			if(areaclear){
				setorigin(blt.hitlocation,true);
				Puff(speed*0.6);
				emergefromimpact(hitloc);
				double vd=(blt.hitlocation-hitloc).length();
				if(vd>=penetration)dieonimpact(blt.hitlocation-blt.hitdir*4);
				else vel*=(penetration-vd)/max(penetration,1);
				return;
			}else{
				dieonimpact(blt.hitlocation-blt.hitdir*4);
				return;
			}
		}
		//into the void behind every rock
		else if(hitresult==BLT_HITONESIDED){
			if(blt.hitline.special==Line_Horizon){destroy();return;}
			setorigin(plushitdir,true);
			flinetracedata voidprobe;
			LineTrace(
				angle,
				penetration*0.6, //these are usually structural rather than doors
				pitch,
				flags:0,
				data:voidprobe
			);
			if(voidprobe.hitline&&voidprobe.distance<penetration){
				Puff(speed*0.6);
				emergefromimpact(voidprobe.hitlocation+voidprobe.hitdir);
				double vd=voidprobe.distance;
				vel*=(penetration-vd)/max(penetration,1);
				return;
			}else{
				//splat against a very thick wall
				dieonimpact(blt.hitlocation-blt.hitdir*4);
				return;
			}
		}

		//drop and wobble
		if(vel.z>BULLET_TERMINALVELOCITY)vel.z-=grav;
		if(pushfactor)A_Changevelocity(
			-frandom(0,pushfactor)*0.01*speed,
			frandom(-pushfactor,pushfactor),
			0,CVF_RELATIVE
		);
		//nexttic
		if(CheckNoDelay()){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}

	virtual void DieOnImpact(vector3 deathspot){
		setorigin(deathspot,true);
		Puff();
		destroy();
	}
	virtual void EmergeFromImpact(vector3 emergespot){
		setorigin(emergespot+blt.hitdir,true);
		if(max(abs(pos.x),abs(pos.y))>=32678){destroy();return;}
		angle+=180;pitch=-pitch;
		A_SprayDecal("BulletChip",10);
		A_SpawnItemEx("PenePuff",
			xvel:-1,zvel:vel.z/max(speed,1),
			flags:SXF_NOCHECKPOSITION
		);
		angle+=180;pitch=-pitch;
		setorigin(emergespot,true);

		double rvel=
			penetration*pushfactor*speed*0.0006
		;
		vel+=(frandom(-rvel,rvel),frandom(-rvel,rvel),frandom(-rvel,rvel));
	}

	virtual actor Puff(int sp=0){
		if(max(abs(pos.x),abs(pos.y))>=32678)return null;
		if(!sp)sp=speed;
		name pufftype="BulletPuffBig";
		if(sp>800){
			pufftype="BulletPuffBig";
		}else if(sp>512){
			pufftype="BulletPuffMedium";
		}else{
			pufftype="BulletPuffSmall";
		}
		bool gbg;actor ppp;
		[gbg,ppp]=A_SpawnItemEx(pufftype,flags:
			SXF_NOCHECKPOSITION
		);
		return ppp;
	}
	virtual void Gunsmoke(){
		actor gs;
		double j=cos(pitch);
		vector3 vk=(j*cos(angle),j*sin(angle),-sin(pitch));
		j=max(1,speed*min(mass,100)*0.00001);
		for(int i=0;i<j;i++){
			gs=spawn("HDGunSmoke",pos+i*vk,ALLOW_REPLACE);
			gs.pitch=pitch;gs.angle=angle;gs.vel=vk*j;
		}
	}
	void LongArmWobble(){
		let hdp=hdplayerpawn(target);
		if(hdp&&hdp.scopecamera){
			pitch+=deltaangle(hdp.pitch,hdp.scopecamera.pitch);
			angle+=deltaangle(hdp.angle,hdp.scopecamera.angle);
		}else if(countinv("IsMoving",AAPTR_TARGET)>=10){
			pitch+=frandom(-2,2);
			angle+=frandom(-1,1);
		}
	}
}
class NewBulletMovePuff:CheckPuff{
	default{
		+skyexplode //important!
	}
}
class SupersonicTrail:IdleDummy{
	states{
	spawn:
		TNT1 A 10;stop;
	}
	override void postbeginplay(){
		if(!random(0,2))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.32);
	}
}
class SupersonicTrailBig:SupersonicTrail{
	override void postbeginplay(){
		A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",CHAN_AUTO,0.42);
	}
}
class SupersonicTrailSmall:SupersonicTrail{
	override void postbeginplay(){
		if(!random(0,4))A_AlertMonsters();
		A_PlaySound("weapons/bulletcrack",0,0.1);
	}
}
class SubsonicTrail:SupersonicTrail{
	override void postbeginplay(){
		A_PlaySound("weapons/subfwoosh",0,0.03);
	}
}






// transitional?

//special usage:accuracy=variation
//A_GiveInventory("DecoBulleter");
class DecoBulleter:ActionItem{
	default{
		missiletype "HDBullet";
	}
	states{
	pickup:
		TNT1 A 0{
			actor p=spawn(invoker.missilename,pos+(0,0,height-6));
			if(!p)return;
			p.target=self;p.angle=angle;p.pitch=pitch;
			if(invoker.speed)p.speed=invoker.speed;
			double pf=invoker.accuracy;
			if(pf){
				p.vel+=(
					frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
				);
				p.speed+=10*frandom(-pf,pf);
			}
			p.vel+=self.vel;
		}fail;
	}
}
class DecoBulleter9f:DecoBulleter{
	default{
		missiletype "HDBullet9";
		speed 500;
		accuracy 1;
	}
}



//the actual bullets!
class HDBulletFrag:HDBullet{
	default{
		woundhealth 2;
	}
	override void postbeginplay(){
		HDActor.PostBeginPlay();

		grav=getgravity();
		pushfactor=frandom(0.8,2.);
		mass=random(100,150);
		accuracy=random(3,6);
	}
	override actor Puff(int sp){
		if(max(abs(pos.x),abs(pos.y))>=32678)return null;
		actor ppp;
		[sp,ppp]=A_SpawnItemEx("FragPuff",flags:
			SXF_NOCHECKPOSITION
		);
		return ppp;
	}
}
class HDBullet9:HDBullet{
	default{
		pushfactor 0.5;
		mass 1539;
		speed 420;
		accuracy 4;
		woundhealth 1;
	}
}
class HDBullet426:HDBullet{
	default{
		pushfactor 0.6;
		mass 320;
		speed 1200;
		accuracy 6;
		woundhealth 6;
		hdbullet.distantsounder "DistantRifle";
	}
}
class HDBullet776:HDBullet{
	default{
		pushfactor 0.3;
		mass 1176;
		speed 1100;
		accuracy 12;
		woundhealth 6;
		hdbullet.distantsounder "DoubleDistantRifle";
	}
}
class HDBullet00:HDBullet{
	default{
		pushfactor 0.9;
		mass 576;
		accuracy 5;
		woundhealth 0;
	}
	override void postbeginplay(){
		HDActor.postbeginplay();
		Gunsmoke();
		grav=getgravity();
	}
}
class HDBullet00b:HDBullet00{
	default{
		stamina 7; //claymores in the future?
		speed 700;
		pushfactor 0.5;
	}
	override void postbeginplay(){
		LongArmWobble();
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		actor bb;
		double p=pushfactor;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			hdbullet(bb).throughthis=target;
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(bb.speed*cos(bb.pitch),0,bb.speed*sin(-bb.pitch),CVF_RELATIVE);
		}
		destroy();
	}
}
class HDBullet00bfl:HDBullet00b{
	default{
		speed 800;
		pushfactor 0.3;
		accuracy -1;
	}
	override void postbeginplay(){
		LongArmWobble();
		setorigin(pos+(cos(angle-90),sin(angle-90),0)*accuracy,false);
		spawn("DistantShotgun",pos,ALLOW_REPLACE);
		angle+=accuracy*0.1;

		actor bb;
		double p=pushfactor;
		for(int i=stamina;i;i--){
			bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
			hdbullet(bb).throughthis=target;
			bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
			bb.speed=speed+speed*frandom(-p,p);
			bb.pitch+=frandom(-p,p);
			bb.angle+=frandom(-p,p);
			bb.A_ChangeVelocity(
				bb.speed*cos(bb.pitch),0,
				bb.speed*sin(-bb.pitch),CVF_RELATIVE
			);
		}
		destroy();
	}
}
class HDBullet00bfr:HDBullet00bfl{
	default{
		accuracy 1;
	}
}
class HDBullet00bf:HDBullet00bfl{ //used for super shotgun guys
	default{
		accuracy 0;
	}
}
class HDBullet00bf2:HDBullet00bfl{
	override void postbeginplay(){
		LongArmWobble();
		for(double i=-1;i<=3;i+=3){
			setorigin(pos+(cos(angle-90),sin(angle-90),0)*i,false);
			spawn("DistantShotgun",pos,ALLOW_REPLACE);
			angle+=i*0.1;

			actor bb;
			double p=pushfactor;
			for(int ii=stamina;ii;ii--){
				bb=spawn("HDBullet00",pos,ALLOW_REPLACE);
				hdbullet(bb).throughthis=target;
				bb.target=target;bb.pitch=pitch;bb.angle=angle;if(target)bb.vel=target.vel;
				bb.speed=speed+speed*frandom(-p,p);
				bb.pitch+=frandom(-p,p);
				bb.angle+=frandom(-p,p);
				bb.A_ChangeVelocity(
					bb.speed*cos(bb.pitch),0,
					bb.speed*sin(-bb.pitch),CVF_RELATIVE
				);
			}
		}
		destroy();
	}
}


