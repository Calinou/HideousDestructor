// ------------------------------------------------------------
// The Bullet!
// ------------------------------------------------------------

#include "zscript/oldbullet.txt"

//testing performance when spamming
class nbb:PlasmaBall replaces PlasmaBall{
	override void postbeginplay(){
		if(!hd_debug){super.postbeginplay();return;}
		for (int i=14;i;i--){
			A_SpawnItemEx("nb",0,0,0,vel.x+frandom(-1,1),vel.y+frandom(-1,1),vel.z+frandom(-1,1),0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEMOMENTUM);
		}
		destroy();
	}
}

class nb:HDActor{
	/*
		special usages:
		accuracy: penetration distance.
		woundhealth: "extra" damage from frangibility, etc.
	*/
	actor a;int b;
	vector3 crackvel;
	double grav;
	double hitdist;
	double oneoverspeed;
	int dmg;
	bool inthesky;
	default{
		projectile; -nogravity
		+bloodsplatter +noextremedeath +cannotpush +hittracer +forcexybillboard
		height 0.05;radius 0.05;
//		scale 0.3;
		maxstepheight 0;
		missileheight 0; projectilekickback 20;
		damagefunction(0);

		mass 40; //40 426, 50 00, 80 776, 90 9mil, 600 40mm
		speed 1240;//accuracy 20;
		pushfactor 0.1;
	}
	void A_Gunsmoke(){
		int j=max(1,speed*min(mass,100)*0.0001);
		for(int i=j;i;i--){
			A_SpawnItemEx("HDGunSmoke",cos(pitch)*i,0,-sin(pitch)*i,
				cos(pitch)*2,0,-sin(pitch)*2,flags:SXF_NOCHECKPOSITION
			);
		}
	}
	override void postbeginplay(){
		super.postbeginplay();
		A_Gunsmoke();
		grav=getgravity();
		if(target && !pitch)pitch=target.pitch;
		A_ChangeVelocity(speed*cos(pitch),0,speed*sin(-pitch),CVF_RELATIVE);
	}
	states{
	spawn:
		BAL1 A -1 nodelay{
			if(!hd_debug){
				tics=0;
				scale=(0.3,0.3);
			}
		}
		BLET A -1;
	}
	override void tick(){
		ClearInterpolation();
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			nexttic();
			return;
		}

		//if it's in the sky, do a separate thing instead
		if(inthesky){
			setxyz(pos+vel);
			if(ceilingz>pos.z) inthesky=false;
			vel.z-=grav;
			nexttic();
			return;
		}

		//move based on hitscan result
		A_FaceVector(vel);
		speed=vel.length();

		//so hacky
		if(!bseeinvisible && target)target.bshootable=false;
		setxyz((pos.x,pos.y,pos.z-8));
		[a,b]=LineAttack(angle,speed,pitch,0,"none",
			"NewBulletMovePuff",flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT);
		setxyz((pos.x,pos.y,pos.z+8));
		if(!bseeinvisible && target)target.bshootable=true;
		bseeinvisible=true;

		if(a){
			hitdist=distance3d(a);

			//it got shot into the sky!
			if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
				inthesky=true;
			}
			else{
				setorigin(a.pos,true);

				//find points close to players and spawn crackers
				CrackType();


				//NOW test for impacts...

				//lower sky ceiling check
				vector3 backcheck=(cos(angle),sin(angle),0);
				a.setxyz(a.pos+backcheck);
				if(a.ceilingpic==skyflatnum && a.ceilingz-a.pos.z<height){
					setorigin(a.pos,false);
					inthesky=true;
					return;
				}else a.setxyz(a.pos-backcheck);

				//SUPER HACKY horizon line check
				vector3 posbak=pos;
				a_setsize(12,4);
				if(!trymove(posbak.xy+1*(cos(angle),sin(angle)),true,true)){
					if(blockingline && blockingline.special == Line_Horizon){
						destroy();return;
					}
				}else setorigin(posbak,false);
				a_setsize(0.05,0.05);

				//finally, the "real" impacts
				if(floorz>pos.z || ceilingz<=pos.z+height){
					Puff();destroy();return;
				}else if((a && abs(hitdist-speed)>radius)){
					BulletImpact();
					if(bdestroyed)return;
				}
			}
		}
		if(!a || (floorz>pos.z && floorpic==skyflatnum)){
			destroy();
			return;
		}

		//drop and wobble
		vel.z-=grav;
		if(pushfactor)A_Changevelocity(
			-frandom(0,pushfactor)*0.01*speed,
			frandom(-pushfactor,pushfactor),
			0,CVF_RELATIVE
		);
		nexttic();
	}

	//impact
	void BulletImpact(){
		bmissile=false;
		if(a.tracer){
			BulletImpactDamage();
			destroy();return;
		}
		else{
			//decal
			name decal="BulletChip";
			if(speed<400)decal="BulletChipSmall";
			A_SprayDecal(decal);

			//ricochet
			if(!random(0,19)){
				bmissile=true;
				vel.xy=rotatevector(vel.xy,frandom(0,360));
				vel.z=frandom(-vel.z,vel.z*0.8);
				vel.xy*=0.9;
				Puff(speed*0.9);
			}

			//pierce
			else if(accuracy){
				Puff(speed*0.4);
				actor e;
				vector3 velp;
				velp.xy=rotatevector((cos(pitch),0),angle);
				velp.z=-sin(pitch);
				velp*=accuracy;
				setorigin(pos+velp,false);
				if(ceilingz<pos.z||floorz>pos.z){ //abort if inside ceiling or floor
					destroy();return;
				}
				angle+=180;pitch*=-1;
				addz(-8);
				[e,b]=LineAttack(
					angle,accuracy*2,pitch,0,"none","NewBulletMovePuff",
					flags:LAF_NORANDOMPUFFZ|LAF_NOINTERACT
				);
				addz(8);
				if((pos-e.pos).length()<accuracy-1)A_SprayDecal(decal);
				setorigin((e.pos+pos)*0.5,false);
				Puff(speed*1.4);
				angle+=180;pitch*=-1;
				vel*=0.9;
				accuracy=random(0,accuracy);
				bmissile=true;
			}

			//final puff
			else{
				Puff();
				destroy();return;
			}
		}
	}
	//apply damage and blood
	void BulletImpactDamage(){
		dmg=mass*speed*speed*0.0000005+woundhealth;
		int maxdmg=dmg*2;

		//supersonic shockwave damage
		if(speed>HDCONST_SPEEDOFSOUND)maxdmg*=1.2;

		//crit
		double cang=angle;
		double cpi=pitch;
		A_Face(a.tracer);
		if(abs(HDMath.AngleChange(cang,angle))<12){
			double th=a.tracer.height;
			double pz=pos.z-sin(cpi)*a.tracer.radius;
			pz=abs(a.tracer.pos.z+(th*0.61)-pz);
			if(pz*5<th){
				if(hd_debug)A_Log("CRIT!");
				maxdmg*=2;
			}
		}
		angle=cang;pitch=cpi;

		//apply damage
		dmg=random(dmg,maxdmg);
		if(hd_debug)A_LogInt(dmg);
		a.tracer.damagemobj(self,self.target,dmg,damagetype);//,DMG_THRUSTLESS);

		//puff or bleed as appropriate
		if(bbloodlessimpact)return;
		else if(!a.tracer.bshootable||a.tracer.bnoblood) Puff();
		else for(int i=0;i<dmg;i+=40){
			a.tracer.A_SpawnItemEx(
				a.tracer.bloodtype,
				0,0,a.pos.z-a.tracer.pos.z,//a.pos.x,a.pos.y,a.pos.z,
				random(3,6),random(-1,1),random(1,3),
				angle-180,
				SXF_USEBLOODCOLOR|
				SXF_NOCHECKPOSITION|
				SXF_ABSOLUTEPOSITION|
				SXF_ABSOLUTEANGLE
			);
		}
	}
	//generate puff
	void Puff(int sp=0){
		if(!sp)sp=speed;
		name pufftype="BulletPuffBig";
		if(sp>800){
			pufftype="BulletPuffBig";
		}else if(sp>512){
			pufftype="BulletPuffMedium";
		}else if(sp>256){
			pufftype="BulletPuffSmall";
		}else{
			pufftype="FragPuff";
		}
		A_SpawnItemEx(pufftype,flags:
			SXF_NOCHECKPOSITION
		);
	}
	//sets crack sound and damage type
	void CrackType(){
		if(speed>256){
			name b="HDNineMilTrail";
			if(speed>1000){
				A_SetDamageType("SmallArms3");
				if(mass>80) b="HDSevenMilTrail";
				else b="HDFourMilTrail";
			}else if(speed>800){
				A_SetDamageType("SmallArms2");
				b="HDFourMilTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				A_SetDamageType("SmallArms1");
				b="HDBuckTrail";
			}else if(speed>100){
				A_SetDamageType("SmallArms0");
				b="HDNineMilTrail";
			}else{
				A_SetDamageType("SmallArms0");
			}
			if(woundhealth>50)
				A_SetDamageType("SmallArms3");
			if(damagetype=="SmallArms1" && woundhealth>30)
				A_SetDamageType("SmallArms2");
			if(damagetype=="SmallArms0" && woundhealth>30)
				A_SetDamageType("SmallArms2");
			else if(damagetype=="SmallArms0" && woundhealth>10)
				A_SetDamageType("SmallArms1");

			crackvel=vel/hitdist*64;
			int k=hitdist*1/64;
			for(int j=0;j<k;j++){
				a.setxyz(a.pos-crackvel);
				bool p;p=false;
				for(int i=0;!p && i<MAXPLAYERS;i++){
					if(playeringame[i] && players[i].mo){
						if(
							a.distance3d(players[i].mo)<256
						){
							p=true;
							spawn(b,a.pos);
						}
					}
				}
			}
		}
	}
}
class NewBulletMovePuff:IdleDummy{
	default{
		+puffgetsowner +alwayspuff +puffonactors +bloodlessimpact +hittracer
		+skyexplode //important!
	}
	states{
	spawn:
		TNT1 A 1;
		stop;
	}
}




// transitional?

//special usage:accuracy=variation
//A_GiveInventory("DecoBulleter");
class DecoBulleter:ActionItem{
	default{
		missiletype "nb";
	}
	states{
	pickup:
		TNT1 A 0{
			int numbu=max(invoker.stamina,1);
			for (int i=numbu;i;i--){
				actor p=Spawn(invoker.missilename,pos+(0,0,height-6));
				p.target=self;p.angle=angle;p.pitch=pitch;
				if(invoker.speed)p.speed=invoker.speed;
				double pf=invoker.accuracy;
				if(p){
					if(pf){
						p.vel+=(
							frandom(-pf,pf),frandom(-pf,pf),frandom(-pf,pf)
						);
						p.speed+=10*frandom(-pf,pf);
					}
					p.vel+=self.vel;
				}
			}
		}fail;
	}
}
class DecoBulleter426:DecoBulleter{
	default{
		missiletype "nb426";
	}
}
class DecoBulleter426s:DecoBulleter426{
	default{
		speed 1100;
		accuracy 2;
	}
}
class DecoBulleter776:DecoBulleter{
	default{
		missiletype "nb776";
	}
}
class DecoBulleter776f:DecoBulleter776{
	default{
		speed 1200;
	}
}
class DecoBulleter9:DecoBulleter{
	default{
		missiletype "nb9";
		accuracy 5;
	}
}
class DecoBulleter9f:DecoBulleter9{
	default{
		speed 500;
		accuracy 1;
	}
}
class DecoBulleter00:DecoBulleter{
	default{
		missiletype "nb00";
		stamina 7;
		accuracy 6;
	}
}
class DecoBulleter00f:DecoBulleter00{
	default{
		speed 900;
		accuracy 4;
	}
}


class nb426:nb{
	default{
		pushfactor 0.6;
		mass 40;
		speed 1200;
		accuracy 4;
	}
}
class nb00:nb{
	default{
		pushfactor 0.9;
		mass 50;
		speed 800;
		accuracy 7;
	}
}
class nb776:nb{
	default{
		pushfactor 0.3;
		mass 80;
		speed 1100;
		accuracy 17;
	}
}
class nb9:nb{
	default{
		pushfactor 0.5;
		mass 90;
		speed 480;
		accuracy 4;
	}
}


