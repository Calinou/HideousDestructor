// ------------------------------------------------------------
//   Radius damage effect combos!
// ------------------------------------------------------------

//need to do a new explosion to immolate things properly
//...can we do a combo exploder (blast, frags and immolate)?
extend class HDActor{
	void A_Blast(
		int blastradius=0,int blastdamage=0,int fullblastradius=0,name blastdamagetype="None",
		int pushradius=0,double pushamount=0,int fullpushradius=0,bool pushmass=true,
		int fragradius=0,int fragdamage=0,name fragdamagetype="SmallArms1",
		int immolateradius=0,int immolateamount=1,int immolatechance=100,
		int gibradius=0,int gibamount=1,
		bool hurtspecies=true,
		actor source=null,
		bool passwalls=false
	){
		//get the biggest radius
		int bigradius=max(
			blastradius,
			fragradius,
			immolateradius,
			gibradius
		);

		//initialize things to be used in the iterator
		int dmg=0;
		vector3 orig=self.pos+(0,0,self.height*0.5);
		actor it=null;
		actor its=null;
		bool ontop=false;
		double divdist=0;
		if(!source){
			if(target)source=target;
			else if(master)source=master;
			else source=self;
		}

		//do all this from the centre
		addz(height*0.5);

		blockthingsiterator itt=blockthingsiterator.create(self,bigradius);
		while(itt.Next()){
			it=itt.thing;
			double losmul=0;

			if(	//abort all checks if no hurt species
				!it || it==self ||
				(!hurtspecies && (source && it.species==source.species))
			)continue;

			it=itt.thing;
			double ithalfheight=it.height*0.5;
			it.addz(ithalfheight); //get the middle not the bottom
			double dist=distance3d(it);
			it.addz(-ithalfheight); //reset its position

			if(!dist || dist<min(it.radius,ithalfheight)){
				ontop=true;
				divdist=1;
			}else{
				ontop=false;
				divdist=clamp(1./dist,0.,1.);
			}

			//check LOS
			if(passwalls)losmul=1.;
			else{
				its=spawn("idledummy",it.pos);
				if(its){
					its.a_setsize(1,1);if(checksight(its))losmul+=0.34;
					its.addz(ithalfheight);if(checksight(its))losmul+=0.34;
					its.addz(ithalfheight);if(checksight(its))losmul+=0.34;
					its.destroy();
				}losmul=min(losmul,1.);
			}
//				if(losmul){A_Log(it.getclassname());A_LogFloat(losmul);}

			if(!losmul)continue;
			double divmass=1.;if(it.mass>0)divmass=1./it.mass;

			//immolate before all damage, to avoid bypassing player death transfer
			if(!it)continue;if(dist<=immolateradius){
				if(immolatechance>=random(1,100)*losmul){
					A_Immolate(it,target,immolateamount);
				}
			}
			//gibbing
			if(!it)continue;if(dist<=gibradius && it.bcorpse && it.bshootable){
				it.a_giveinventory("sawgib",gibamount-dist);
				for(int i=0;i<gibamount;i+=3){
					A_SpawnItemEx(it.bloodtype,
						random(1,it.radius),
						random(-it.radius,it.radius)*0.5,
						random(4,it.height),
						it.vel.x+(random(-4,4)),
						it.vel.y+(random(-4,4)),
						it.vel.z+random(1,7),
						0,SXF_ABSOLUTEMOMENTUM|SXF_NOCHECKPOSITION
					);
				}
				if(!it.bdontthrust)it.vel+=(it.pos-self.pos)*divdist*divmass*10;
			}
			//push
			if(!it)continue;if(dist<=pushradius && it.bshootable && !it.bdontthrust){
				if(it.radiusdamagefactor)pushamount*=it.radiusdamagefactor;
				vector3 push=(it.pos-self.pos)*divdist
					*clamp(pushamount-clamp(dist-fullpushradius,0,dist),0,pushamount);
				if(pushmass){
					if(pushamount<=it.mass)push=(0,0,0);
					else{
						push*=divmass;
						if(push.z>0)push-=(0,0,mass*it.gravity);
					}
				}
				it.vel+=push;
			}
			//blast damage
			if(!it)continue;if(dist<=blastradius && (it.bshootable||it.bvulnerable)){
				if(it.radiusdamagefactor)blastdamage*=it.radiusdamagefactor;
				if(dist>fullblastradius){
					dmg=clamp(dist-fullblastradius,0,dist);
					dmg=blastdamage-dmg;
				}else dmg=blastdamage;
				dmg*=losmul;
				it.DamageMobj(self,source,dmg,blastdamagetype,DMG_THRUSTLESS,0);
			}
			//frag damage
			if(!it)continue;if(dist<=fragradius
				&&(it.bsolid || it.bshootable || it.bvulnerable)
			){
				if(it.radiusdamagefactor)fragdamage*=it.radiusdamagefactor;
				A_Face(it);
				if(
					it!=self
					&&(
						it.bvulnerable ||(
							it.bshootable
							&& it.radius
							&& it.height
						)
					)
				){
					//determine size of arc exposed to frags
					vector3 badpos=(rotatevector((0,it.radius),angle),0);

					it.setxyz(it.pos+badpos);
					A_Face(it,0,0,flags:FAF_BOTTOM,z_ofs:0);
					double pitchcover=pitch;double angcover=angle;
					it.setxyz(it.pos-2*badpos);
					A_Face(it,0,0,flags:FAF_TOP,z_ofs:0);
					angcover=(
							deltaangle(pitchcover,pitch),
							deltaangle(angcover,angle)
						).length();
					it.setxyz(it.pos+badpos);

					angcover*=losmul;
					dmg=ceil(fragdamage*min(1.,angcover*(1./40.)));
					if(random(1,720)<angcover)dmg=max(dmg,random(1,fragdamage));

						//SO MUCH BLOOD
					A_Face(it,0,0);
					name bld="FragPuff";
					if(!it.bnoblood&&it.bloodtype)bld=it.bloodtype;
					int gbg;actor blaaa;vector2 blooddir=(pos.xy-it.pos.xy).unit();
					for(int i=0;i<dmg;i+=12){
						[gbg,blaaa]=it.A_SpawnItemEx(bld,
							random(-1,it.radius),
							random(-it.radius,it.radius)*0.6,
							random(4,it.height),
							blooddir.x*frandom(-1,4),
							blooddir.y*frandom(-4,4),
							frandom(1,4),
							-self.angle,SXF_USEBLOODCOLOR
							|SXF_ABSOLUTEANGLE
							|SXF_NOCHECKPOSITION
						);
						blaaa.vel+=it.vel;
					}

					//limit damage to non-gibbing levels
					//can still gib, just takes a lot more
					if(
						it.health>0&&
						it.gibhealth>0
					){
						int gh=it.health+it.gibhealth;
						if(dmg>gh){
							dmg=min(gh,gh-it.gibhealth*3);
							if(dmg<1)dmg=it.health+1;
						}
					}


					//and finally the good stuff
					if(hd_debug)A_Log(
						string.format("%s fragged for %i damage",
							it.getclassname(),dmg
						)
					);
					it.DamageMobj(self,source,dmg,
						fragdamagetype,DMG_THRUSTLESS,0
					);
				}
			}
		}
		//reset position
		if(self)addz(-height*0.5);
	}
}
