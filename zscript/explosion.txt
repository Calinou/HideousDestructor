// ------------------------------------------------------------
//   Radius damage effect combos!
// ------------------------------------------------------------

//need to do a new explosion to immolate things properly
//...can we do a combo exploder (blast, frags and immolate)?
extend class HDActor{
	void A_Blast(
		int blastradius=0,int blastdamage=0,int fullblastradius=0,name blastdamagetype="None",
		int pushradius=0,double pushamount=0,int fullpushradius=0,bool pushmass=true,
		int fragradius=0,int fragdamage=0,name fragdamagetype="SmallArms1",
		int immolateradius=0,int immolateamount=1,int immolatechance=100,
		int gibradius=0,int gibamount=1,
		bool hurtspecies=true,
		actor source=null,
		bool passwalls=false
	){
		//get the biggest radius
		int bigradius=max(
			blastradius,
			fragradius,
			immolateradius,
			gibradius
		);

		//initialize things to be used in the iterator
		int dist;
		int dmg;
		vector3 orig=self.pos+(0,0,self.height*0.5);
		actor its; //top
		actor itr; //bottom
		bool ontop;
		double divdist;
		double divmass;
		double losmul;
		if(!source){
			if(target)source=target;
			else if(master)source=master;
			else source=self;
		}

		//do all this from the centre
		addz(height*0.5);

		blockthingsiterator itt=blockthingsiterator.create(self,bigradius);
		while(itt.Next()){

			if(	//abort all checks if no hurt species
				itt.thing &&
				(hurtspecies || (itt.thing.species!=source.species))
			){

				actor it=itt.thing;
				int dist=distance3d(it);
				int ithalfheight=it.height*0.5;
				if(!dist || dist<(it.radius,it.radius,ithalfheight).length()){
					ontop=true;
					divdist=1;
				}else{
					ontop=false;
					divdist=clamp(1./dist,0.,1.);
				}

				//check LOS
				if(passwalls)losmul=1.;
				else{
					its=spawn("idledummy",it.pos+(0,0,it.height)); //top
					itr=spawn("idledummy",it.pos+(0,0,ithalfheight)); //middle
					its.a_setsize(1,1,1);itr.a_setsize(1,1,1);
					losmul=clamp(0.34*(
						checksight(it)+
						checksight(its)+
						checksight(itr)
					),0,1.0);
					//destroy these now, they won't be used again
					its.destroy();itr.destroy();
				}

				if(it.mass>0) divmass=1./it.mass;else divmass=1.;

				//immolate before all damage, to avoid bypassing player death transfer
				if(it && losmul && dist<=immolateradius){
					if(immolatechance>=random(1,100)*losmul){
						A_Immolate(it,target,immolateamount);
					}
				}
				if(it && losmul>0 && dist<=pushradius && it.bshootable && !it.bdontthrust){
					vector3 push=(it.pos-self.pos)*divdist
						*clamp(pushamount-clamp(dist-fullpushradius,0,dist),0,pushamount);
					if(pushmass){
						if(pushamount<=it.mass) push=(0,0,0);
						else{
							push*=divmass;
							if(push.z>0)push-=(0,0,mass*it.gravity);
						}
					}
					it.vel+=push;
				}
				if(it && losmul && dist<=blastradius && (it.bshootable||it.bvulnerable)){
					if(dist>fullblastradius){
						dmg=clamp(dist-fullblastradius,0,dist);
						dmg=blastdamage-dmg;
					}else dmg=blastdamage;
					dmg*=losmul;
					it.DamageMobj(self,source,dmg,blastdamagetype,DMG_THRUSTLESS,0);
				}
				if(it && losmul && dist<=fragradius && (it.bsolid || it.bshootable)){
					A_Face(it);
					if(
						it!=self
						&&(
							it.bvulnerable ||(
								it.bshootable
								&& it.radius
								&& it.height
							)
						)
					){
						//determine damage as proportion of distance and size
						//get lines to centre and one of the corners
						vector3 dv=it.pos+(0,0,ithalfheight)-self.pos; //self to centre
						vector3 dc=dv+(it.radius,it.radius,ithalfheight); //self to corner

						double dvl=dv.length(); //distance to centre
						double dcl=dc.length(); //distance to corner

						if(dcl)dc*=dvl/dcl; //equalize the two line lengths
						double dfl=(dv-dc).length(); //corner to middle as "flattened"

						if(dfl){ //target must have some surface area exposed!
							//don't kill Godzilla with firecracker
							dfl=clamp(dfl,1,fragradius*2);

							double dvld=1/dvl; //used multiple times

							//if inside, double max damage on this guy only
							if(dvl>dfl){  
								int mindmg=fragdamage*dfl*dvld;
								dmg=ceil(random(2,3)*mindmg);

								//reduce dmg if partially occluded
								dmg*=losmul;
							}else dmg=fragdamage+random(1,dmg);

							//SO MUCH BLOOD
							A_FaceVector(dv);
							name bld="FragPuff";
							if(!it.bnoblood) bld=it.bloodtype;
							for(int i=0;i<dmg;i+=15){
								double xymod=frandom(1,4)*dvld;
								it.A_SpawnItemEx(bld,
									random(1,it.radius),
									random(-it.radius,it.radius)*0.5,
									random(4,it.height),
									it.vel.x-dv.x*xymod,
									it.vel.y-dv.y*xymod,
									it.vel.z+frandom(1,7),
									-self.angle,SXF_USEBLOODCOLOR|SXF_ABSOLUTEANGLE|
									SXF_ABSOLUTEMOMENTUM|SXF_NOCHECKPOSITION
								);
							}

							//and finally the good stuff
							it.DamageMobj(self,source,dmg,fragdamagetype,DMG_THRUSTLESS,0);
						}
					}
				}
				if(it && losmul && dist<=gibradius && it.bcorpse && it.bshootable){
					//HDMob has its own corpse-gibbing so no sawgib for it
					if(!(it is "HDMob"))it.a_giveinventory("sawgib",gibamount-dist);
					for(int i=0;i<gibamount;i+=3){
						A_SpawnItemEx(it.bloodtype,
							random(1,it.radius),
							random(-it.radius,it.radius)*0.5,
							random(4,it.height),
							it.vel.x+(random(-4,4)),
							it.vel.y+(random(-4,4)),
							it.vel.z+random(1,7),
							0,SXF_ABSOLUTEMOMENTUM|SXF_NOCHECKPOSITION
						);
					}
					if(!it.bdontthrust) it.vel+=(it.pos-self.pos)*divdist*divmass*10;
				}
			}
		}
		//reset position
		if(self)addz(-height*0.5);
	}
}
