// ------------------------------------------------------------
//   Radius damage effect combos!
// ------------------------------------------------------------

//need to do a new explosion to immolate things properly
//...can we do a combo exploder (blast, frags and immolate)?
extend class HDActor{
	void A_Blast(
		int blastradius=0,int blastdamage=0,int fullblastradius=0,name blastdamagetype="None",
		int pushradius=0,double pushamount=0,int fullpushradius=0,bool pushmass=true,
		int fragradius=0,int fragdamage=0,name fragdamagetype="SmallArms1",
		int immolateradius=0,int immolateamount=1,int immolatechance=100,
		int gibradius=0,int gibamount=1,
		bool hurtspecies=true,
		actor source=null,
		bool passwalls=false
	){
		//get the biggest radius
		int bigradius=max(
			blastradius,
			fragradius,
			immolateradius,
			gibradius
		);

		//initialize things to be used in the iterator
		int dmg=0;
		vector3 orig=self.pos+(0,0,self.height*0.5);
		actor it=null;
		actor its=null;
		bool ontop=false;
		double divdist=0;
		if(!source){
			if(target)source=target;
			else if(master)source=master;
			else source=self;
		}

		//do all this from the centre
		addz(height*0.5);

		blockthingsiterator itt=blockthingsiterator.create(self,bigradius);
		while(itt.Next()){
			it=itt.thing;
			double losmul=0;

			if(	//abort all checks if no hurt species
				!it || it==self ||
				(!hurtspecies && (source && it.species!=source.species))
			)continue;

			it=itt.thing;
			double ithalfheight=it.height*0.5;
			it.addz(ithalfheight); //get the middle not the bottom
			double dist=distance3d(it);
			it.addz(-ithalfheight); //reset its position

			if(!dist || dist<min(it.radius,ithalfheight)){
				ontop=true;
				divdist=1;
			}else{
				ontop=false;
				divdist=clamp(1./dist,0.,1.);
			}

			//check LOS
			if(passwalls)losmul=1.;
			else{
				its=spawn("idledummy",it.pos);
				if(its){
					its.a_setsize(1,1);if(checksight(its))losmul+=0.34;
					its.addz(ithalfheight);if(checksight(its))losmul+=0.34;
					its.addz(ithalfheight);if(checksight(its))losmul+=0.34;
					its.destroy();
				}losmul=min(losmul,1.);
			}
//				if(losmul){A_Log(it.getclassname());A_LogFloat(losmul);}

			if(!losmul)continue;
			double divmass=1.;if(it.mass>0)divmass=1./it.mass;

			//immolate before all damage, to avoid bypassing player death transfer
			if(it && dist<=immolateradius){
				if(immolatechance>=random(1,100)*losmul){
					A_Immolate(it,target,immolateamount);
				}
			}
			//push
			if(it && dist<=pushradius && it.bshootable && !it.bdontthrust){
				vector3 push=(it.pos-self.pos)*divdist
					*clamp(pushamount-clamp(dist-fullpushradius,0,dist),0,pushamount);
				if(pushmass){
					if(pushamount<=it.mass)push=(0,0,0);
					else{
						push*=divmass;
						if(push.z>0)push-=(0,0,mass*it.gravity);
					}
				}
				it.vel+=push;
			}
			//blast damage
			if(it && dist<=blastradius && (it.bshootable||it.bvulnerable)){
				if(dist>fullblastradius){
					dmg=clamp(dist-fullblastradius,0,dist);
					dmg=blastdamage-dmg;
				}else dmg=blastdamage;
				dmg*=losmul;
				it.DamageMobj(self,source,dmg,blastdamagetype,DMG_THRUSTLESS,0);
			}
			//frag damage
			if(it && dist<=fragradius && (it.bsolid || it.bshootable || it.bvulnerable)){
				A_Face(it);
				if(
					it!=self
					&&(
						it.bvulnerable ||(
							it.bshootable
							&& it.radius
							&& it.height
						)
					)
				){
					//determine damage as proportion of distance and size
					//get lines to centre and one of the corners
					vector3 dv=it.pos+(0,0,ithalfheight)-self.pos; //self to centre
					vector3 dc=dv+(it.radius,it.radius,ithalfheight); //self to corner

					double dvl=dv.length(); //distance to centre
					double dcl=dc.length(); //distance to corner

					if(dcl)dc*=dvl/dcl; //equalize the two line lengths
					double dfl=(dv-dc).length(); //corner to middle as "flattened"


					//determine size of arc exposed to frags
					double apr=it.radius;
					it.setxyz(it.pos+(apr,apr,0));
					A_Face(it,0,0,flags:FAF_BOTTOM,z_ofs:0);
					double pitchcover=pitch;double angcover=angle;
					it.setxyz(it.pos-2*(apr,apr,0));
					A_Face(it,0,0,flags:FAF_TOP,z_ofs:0);
					angcover=(
							deltaangle(pitchcover,pitch),
							deltaangle(angcover,angle)
						).length();
					it.setxyz(it.pos+(apr,apr,0));

angcover*=losmul;
int dmg2=fragdamage*min(1.,angcover*(1./90.));
if(random(1,720)<angcover)dmg2=max(dmg2,random(1,fragdamage));


					if(dfl){ //target must have some surface area exposed!
						//don't kill Godzilla with firecracker
						dfl=clamp(dfl,1,fragradius*2);

						double dvld=0; //used multiple times
						if(dvl)dvld=1/dvl;

						//if inside, double max damage on this guy only
						if(dvl<dfl)dmg=fragdamage;
						else{
							int mindmg=fragdamage*dfl*dvld;
							dmg=ceil(random(2,3)*mindmg);

							//reduce dmg if partially occluded
							dmg*=losmul;
						}
dmg=dmg2;

						//SO MUCH BLOOD
						A_FaceVector(dv);
						name bld="FragPuff";
						if(!it.bnoblood&&it.bloodtype)bld=it.bloodtype;
						for(int i=0;i<dmg;i+=12){
							double xymod=frandom(1,4)*dvld;
							it.A_SpawnItemEx(bld,
								random(-1,it.radius),
								random(-it.radius,it.radius)*0.5,
								random(4,it.height),
								it.vel.x-dv.x*xymod,
								it.vel.y-dv.y*xymod,
								it.vel.z+frandom(1,4),
								-self.angle,SXF_USEBLOODCOLOR
								|SXF_ABSOLUTEANGLE
								|SXF_ABSOLUTEMOMENTUM
								|SXF_NOCHECKPOSITION
							);
						}

						//limit damage to non-gibbing levels
						//can still gib, just takes a lot more
						if(
							it.health>0&&
							it.gibhealth>0&&
							dmg>it.health+it.gibhealth
						)dmg=max(health+gibhealth,dmg-gibhealth*3);

						//and finally the good stuff
						if(hd_debug)A_Log(
							string.format("%s fragged for %i damage",
								it.getclassname(),dmg
							)
						);
						it.DamageMobj(self,source,dmg,
							fragdamagetype,DMG_THRUSTLESS,0
						);
					}
				}
			}
			//gibbing
			if(it && dist<=gibradius && it.bcorpse && it.bshootable){
				it.a_giveinventory("sawgib",gibamount-dist);
				for(int i=0;i<gibamount;i+=3){
					A_SpawnItemEx(it.bloodtype,
						random(1,it.radius),
						random(-it.radius,it.radius)*0.5,
						random(4,it.height),
						it.vel.x+(random(-4,4)),
						it.vel.y+(random(-4,4)),
						it.vel.z+random(1,7),
						0,SXF_ABSOLUTEMOMENTUM|SXF_NOCHECKPOSITION
					);
				}
				if(!it.bdontthrust)it.vel+=(it.pos-self.pos)*divdist*divmass*10;
			}
		}
		//reset position
		if(self)addz(-height*0.5);
	}
}
