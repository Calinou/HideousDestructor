// ------------------------------------------------------------
// Death and corpses
// ------------------------------------------------------------
extend class HDPlayerPawn{
	bool silentdeath;
	states{
	death.bleedout:
	death.invisiblebleedout:
	death.internal:
		---- A 0{
			if(playercorpse)playercorpse.A_StopSound(CHAN_VOICE);
			A_StopSound(CHAN_VOICE);
		}
	death:
	xdeath:
		---- A 50{
			binvisible=true;
			A_NoBlocking();
		}
		---- A 20 A_CheckPlayerDone();
		wait;
	}
	override void Die(actor source,actor inflictor,int dmgflags=0){
		if(player&&player.readyweapon&&deathmatch&&!sv_weapondrop&&!barehanded)
				A_DropInventory(player.readyweapon.getclassname());
		if(player.attacker is "HDFire")player.attacker=null;
		playercorpse=spawn("HDPlayerCorpse",pos);
		playercorpse.vel=vel;playercorpse.master=self;
		if(height<40)playercorpse.sprite=GetSpriteIndex("PLYCA0");
			else playercorpse.sprite=GetSpriteIndex("PLAYA0");
		playercorpse.translation=translation;
		playercorpse.A_SetSize(12,52);
		if(-health>gibhealth||aggravateddamage>40) playercorpse.A_Die("extreme");
		else{
			playercorpse.A_Die();
			if(!silentdeath){
				A_PlayerScream();
			}
		}

		//drop parting gifts
		if(countinv("FragOut")){  
			A_GiveInventory("HDGrenadeToss",1);
			A_TakeInventory("FragOut");
			A_TakeInventory("SpoonOff");
		}
		if(countinv("BFG9k")){
			let bfg=bfg9k(findinventory("bfg9k"));
			if(bfg&&bfg.weaponstatus[BFGS_CRITTIMER]>0){
				bfg.buntossable=false;
				A_DropInventory("BFG9k");
			}
		}
		if(countinv("ZM66AssaultRifle")){
			let zzz=zm66assaultrifle(findinventory("ZM66AssaultRifle"));
			if(zzz&&zzz.weaponstatus[ZM66S_HEAT]>HDCONST_ZM66COOKOFF){
				A_DropInventory("ZM66AssaultRifle");
			}
		}

		super.die(source,inflictor,dmgflags);
	}
}


//event handlers for wipe, etc.
class WipedOut:InventoryFlag{}
extend class HDHandlers{
	bool endgame;
	int coopdeaths;
	int teamdeaths[255];
	int ffadeaths[MAXPLAYERS];
	int fl;
	bool wiped[MAXPLAYERS];
	override void PlayerDied(PlayerEvent e){
		fl=fraglimit>=100?fraglimit-100:fraglimit;
		let eee=PlayerPawn(players[e.playernumber].mo);
		if(!eee)return;
		let hde=HDPlayerPawn(eee);

		eee.A_TakeInventory("WoundCount");

		//transfer fires to corpse
		actor pc=null;
		if(hde)pc=hde.playercorpse;
		HDF.TransferFire(players[e.playernumber].mo,pc);

		if(fraglimit && !deathmatch){
			coopdeaths++;

			//update counter for each player
			for(int i=0;i<MAXPLAYERS;i++){
				if(playeringame[i]&&players[i].mo)players[i].mo.A_SetInventory("HDLives",fl-coopdeaths);
			}

			if(fl<coopdeaths){
				wiped[e.playernumber]=true;
				eee.A_GiveInventory("WipedOut");
				if(!endgame){
					if(fraglimit<100){
						endgame=true;
						eee.ACS_NamedExecuteAlways("CoopFail",0,0,0);
					}else{
						int wipecount=0;actor pmo;
						int playercount=0; //what is the REAL way to do this???
						for(int i=0;i<MAXPLAYERS;i++){
							if(playeringame[i]){
								playercount++;
								pmo=players[i].mo;
								if(
									pmo.countinv("WipedOut")
								)wipecount++;
							}
						}
						if(wipecount>=playercount){
							endgame=true;
							eee.ACS_NamedExecuteAlways("CoopWipe",0,0,0);
						}
					}
				}
			}
		}
		else if(deathmatch && teamplay && fraglimit>=100){
			int gtm=players[e.playernumber].getteam();
			if(fl<=teamdeaths[gtm]){
				wiped[e.playernumber]=true;
				eee.A_Log(string.format("%s is OUT!",players[e.playernumber].getusername()));
			}

			teamdeaths[gtm]++;
			int lives=fl-teamdeaths[gtm];
			if(hd_debug)eee.A_Log(string.format("Team %i has %i %s left.",
				gtm,
				lives,
				lives==1?"life":"lives"
			));

			//update counters for each player
			int standingteam=-1;bool twoteamsleft;int gtmi;
			for(int i=0;i<MAXPLAYERS;i++){
				if(playeringame[i]){
					gtmi=players[i].getteam();
					players[i].fragcount=max(0,fl-teamdeaths[gtmi]);
					if(players[i].getteam()==gtm)
						players[i].mo.A_SetInventory("HDLives",players[i].fragcount);
	
					//figure out which teams remain
					if(!wiped[i]){
						if(standingteam<0)standingteam=gtmi;else{
							if(standingteam!=gtmi)twoteamsleft=true;
						}
					}
				}
			}
			if(standingteam<0||(!endgame&&!twoteamsleft)){
				endgame=true;
				if(standingteam<0)eee.ACS_NamedExecuteAlways("CoopWipe",0,0,0);
				else eee.ACS_NamedExecuteAlways("TDMEndWin",0,standingteam,0);
			}
		}
		else if(deathmatch && !teamplay && fraglimit>=100){
			int gpn=e.playernumber;
			if(fl<=ffadeaths[gpn]){
				wiped[gpn]=true;
				eee.A_Log(string.format("%s is OUT!",players[gpn].getusername()));
			}

			ffadeaths[gpn]++;
			int lives=fl-ffadeaths[gpn];
			if(hd_debug)eee.A_Log(string.format("%s has %i %s left.",
				players[gpn].getusername(),
				lives,
				lives==1?"life":"lives"
			));

			//update counters for each player
			int standingplayer=-1;bool twoplayers;
			for(int i=0;i<MAXPLAYERS;i++){
				if(playeringame[i]){
					//don't set fragcount - so individualistic!
					players[i].mo.A_SetInventory("HDLives",max(0,fl-ffadeaths[i]));

					//see if any other players remain
					if(!wiped[i]){
						if(standingplayer<0)standingplayer=i;
						else if(standingplayer!=i)twoplayers=true;
					}
				}
			}
			if(standingplayer<0||(!endgame&&!twoplayers)){
				endgame=true;
				if(standingplayer<0)eee.ACS_NamedExecuteAlways("CoopWipe",0,0,0);
				else players[standingplayer].mo.ACS_NamedExecuteAlways("FFAWin",0,standingplayer+1,0);
			}
		}
	}
}


//corpse substituter
class HDPlayerCorpse:HDActor{
	default{
		monster; -countkill +solid +friendly
		height 52;radius 12;health 100;mass 160;
	}
	states{
	spawn:
		#### A -1 nodelay A_Die();
	death:
		#### H 10{
			A_NoBlocking();
			bshootable=true;
			scale.x*=randompick(-1,1);
		}
		#### IJ 8;
		#### K 3 A_SetSize(12,13);
	deadfall:
		#### K 2;
		#### LM 4 A_JumpIf(abs(vel.z)>1,"deadfall");
	dead:
		#### N 2 canraise A_JumpIf(abs(vel.z)>2,"deadfall");
		wait;
	xdeath:
		#### O 0{
			A_XScream();
			scale.x=1;
		}
		#### OPQRSTUV 5;
		---- A 0{
			A_SpawnItemEx("ReallyDeadRifleman",flags:
				SXF_NOCHECKPOSITION|
				SXF_TRANSFERPOINTERS|
				SXF_TRANSFERTRANSLATION
			);
		}
		stop;
	raise:
		#### MLKJIH 5;
		---- A 0{
			A_SpawnItemEx("UndeadRifleman",flags:
				SXF_NOCHECKPOSITION|
				SXF_TRANSFERPOINTERS|
				SXF_TRANSFERTRANSLATION
			);
		}
		stop;
	}
	override void Tick(){
		if(
			hdplayerpawn(master)
			&&hdplayerpawn(master).playercorpse==self
		){
			//keep the corpse just behind the player's view
			setorigin(
				(master.pos.xy-angletovector(master.angle),master.pos.z),true
			);
		}else master=null;
		super.Tick();
	}
}


