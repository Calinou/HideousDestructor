//why the fuck is everything so complicated :(
extend class HDPlayerPawn{
	bool silentdeath;
	states{
	death.yokai:
	death.bleedout:
	death.invisiblebleedout:
	death.internal:
		---- A 0{
			if(playercorpse)playercorpse.A_StopSound(CHAN_VOICE);
		}
	death:
	xdeath:
		---- A 50{
			A_GiveInventory("CheckLiveRound");
			binvisible=true;
			A_NoBlocking();
		}
		---- A 20 A_CheckPlayerDone();
		wait;
	}
	override void Die(actor source,actor inflictor,int dmgflags=0){
		if(player.attacker is "HDFire")player.attacker=null;
		playercorpse=spawn("HDPlayerCorpse",pos);
		playercorpse.vel=vel;playercorpse.master=self;
		if(height<40)playercorpse.sprite=GetSpriteIndex("PLYCA0");
			else playercorpse.sprite=GetSpriteIndex("PLAYA0");
		playercorpse.translation=translation;
		playercorpse.A_SetSize(12,52);
		if(-health>gibhealth||aggravateddamage>40) playercorpse.A_Die("extreme");
		else{
			playercorpse.A_Die();
			if(!silentdeath){
				A_PlayerScream();
			}
		}
		A_TakeInventory("IsAlive");
		super.die(source,inflictor,dmgflags);
	}
}


//event handlers for wipe, etc.
extend class HDHandlers{
	bool endgame;
	int coopdeaths;
	override void PlayerDied(PlayerEvent e){
		actor pc;
		let hde=HDPlayerPawn(players[e.playernumber].mo);
		if(!hde)return;

		hde.A_TakeInventory("WoundCount");
		hde.A_TakeInventory("LethalDamage");

		//transfer fires to corpse
		pc=hde.playercorpse;
		HDF.TransferFire(players[e.playernumber].mo,pc);

		if(fraglimit && !deathmatch){
			coopdeaths++;
			int fl=fraglimit>100?fraglimit-100:fraglimit;

			//update counter for each player
			for(int i=0;i<MAXPLAYERS;i++){
				players[i].mo.A_SetInventory("HDLives",fl-coopdeaths);
			}

			if(fl<coopdeaths){
				hde.A_GiveInventory("WipedOut");
				if(!endgame){
					if(fraglimit>100){
						endgame=true;
						hde.ACS_NamedExecuteAlways("CoopFail",0,0,0);
					}else{
						int wiped=0;actor pmo;
						int playercount=0; //what is the REAL way to do this???
						for(int i=0;i<MAXPLAYERS;i++){
							if(playeringame[i]){
								playercount++;
								pmo=players[i].mo;
								if(
									pmo.countinv("WipedOut")
								)wiped++;
							}
						}
						if(wiped>=playercount){
							endgame=true;
							hde.ACS_NamedExecuteAlways("CoopWipe",0,0,0);
						}
					}
				}
			}
		}
	}
}


//corpse substituter
class HDPlayerCorpse:HDActor{
	default{
		monster; -countkill +solid
		height 52;radius 12;health 100;mass 100;
	}
	override void Die(actor source,actor inflictor,int dmgflags=0){
		super.die(source,inflictor,dmgflags);
	}
	states{
	spawn:
		#### A -1 nodelay A_Die();
	death:
		#### H 10{
			A_NoBlocking();
			bshootable=true;
			scale.x*=randompick(-1,1);
		}
		#### IJ 8;
		#### K 3 A_SetSize(12,13);
	deadfall:
		#### K 2;
		#### LM 4 A_JumpIf(abs(vel.z)>1,"deadfall");
	dead:
		#### N 2 canraise A_JumpIf(abs(vel.z)>2,"deadfall");
		wait;
	xdeath:
		#### O 0{
			A_XScream();
			scale.x=1;
		}
		#### OPQRSTUV 5;
		---- A 0{
			A_SpawnItemEx("ReallyDeadRifleman",flags:
					SXF_NOCHECKPOSITION|
					SXF_TRANSFERPOINTERS|
					SXF_TRANSFERTRANSLATION
			);
		}
		stop;
	raise:
		#### MLKJIH 5;
		---- A 0{
			A_SpawnItemEx("UndeadRifleman",flags:
					SXF_NOCHECKPOSITION|
					SXF_TRANSFERPOINTERS|
					SXF_TRANSFERTRANSLATION
			);
		}
		stop;
	}
	override void Tick(){
		if(master){ //keep the corpse just behind the player's view
			let p=PlayerPawn(master);
			if(p && p.player && p.player.mo==p){
				if(p.getplayerinput(MODINPUT_BUTTONS)&BT_USE){
					master=null;
				}else{
					setorigin(master.pos+(-cos(master.angle),-sin(master.angle),0),true);
				}
			}
		}
		super.Tick();
	}
}





