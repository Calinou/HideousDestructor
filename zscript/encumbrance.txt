// ------------------------------------------------------------
// Encumbrance
// ------------------------------------------------------------

//a battery should be about the size of your old flip phone but significantly heavier.
const ENC_BATTERY=12;
const ENC_BATTERY_LOADED=ENC_BATTERY*0.4;

//a ZM66 mag should be roughly the size of a battery.
const ENC_426MAG=10;
const ENC_426MAG_LOADED=ENC_426MAG*0.4;
//50 single rounds should inconvenience you far more than a single mag.
const ENC_426=ENC_426MAG*0.03;
const ENC_426_LOADED=ENC_426*0.3;

const ENC_776MAG=30;
const ENC_776MAG_LOADED=ENC_776MAG*0.5;
//cased rounds are easier to keep in your pocket and fit where a mag will not.
const ENC_776=ENC_776MAG*0.032;
const ENC_776B=ENC_776*0.5;
const ENC_776_LOADED=ENC_776*0.3;
//clips take up more space than 10 assorted rounds.
const ENC_776CLIP=ENC_776*12;

const ENC_9MAG=6;
//it's almost entirely inside the handle!
const ENC_9MAG_LOADED=ENC_9MAG*0.2;
const ENC_9MAG30=23;
//the opposite of that...
const ENC_9MAG30_LOADED=ENC_9MAG30*0.6;
const ENC_9=ENC_9MAG*0.07;
const ENC_9_LOADED=ENC_9*0.3;

//other things
const ENC_SHELL=1;
const ENC_SHELLLOADED=0.3;
const ENC_ROCKET=7;
const ENC_ROCKETLOADED=ENC_ROCKET*0.5;
const ENC_HEATROCKET=ENC_ROCKET*1.2;
const ENC_HEATROCKETLOADED=ENC_ROCKETLOADED;
const ENC_BRONTOSHELL=ENC_426MAG*0.4;
const ENC_BRONTOSHELLLOADED=ENC_BRONTOSHELL*0.4;
const ENC_FRAG=ENC_ROCKET*1.6;

//more things
const ENC_BLUEARMOUR=220;
const ENC_GREENARMOUR=70;
const ENC_RADSUIT=50;
const ENC_IEDKIT=3;
const ENC_SQUADSUMMONER=7;
const ENC_BLUEPOTION=12;
const ENC_LITEAMP=20;
const ENC_MEDIKIT=45;
const ENC_STIMPACK=7;
const ENC_LADDER=70;
const ENC_DERP=55;
const ENC_HERP=125;


extend class HDPlayerPawn{
	double enc;
	double CheckEncumbrance(){
		if(!player)return 0;
		enc=0;

		//backpack
		let hdbp=HDBP(findinventory("HDBP"));
		if(hdbp)enc+=max(100,(hdbp.bulk)*0.62);

		//booleans for reference
		bool forcefull=(
			deathmatch
			||!hd_onemanarmy
			||skill>=5
		);
		bool use9=forcefull||countinv("DERPUsable");
		bool use12=forcefull;
		bool use776=forcefull;
		bool use426=forcefull;
		bool usebronto=forcefull;
		bool usebattery=forcefull||countinv("HERPUsable")||countinv("PortableLiteAmp");
		bool userocket=forcefull||countinv("HDIEDKit");
		bool useheat=forcefull;
		bool usesecondpistol=forcefull;

		//scriptified weapons
		for(inventory hdww=inv;hdww!=null;hdww=hdww.inv){
			let hdw=hdweapon(hdww);
			if(!hdw)continue;
			bool thisweapon=(
				hdw==lastweapon||
				hdw==player.readyweapon
			);
			if(
				thisweapon
				||forcefull
			){
				int blx=0;
				if(hdw is "Lumberjack"){
					blx+=100;
					if(hdw.weaponstatus[CSAWS_BATTERY]>=0)blx+=ENC_BATTERY_LOADED;
					usebattery=true;
				}else if(hdw is "HDPistol"){
					blx+=30+hdw.weaponstatus[PISS_MAG]*ENC_9MAG_LOADED;
					use9=true;
					usesecondpistol=true;
				}else if(hdw is "HDSMG"){
					int mg=hdw.weaponstatus[SMGS_MAG];
					if(mg<0)blx+=120-ENC_9MAG30_LOADED;
					else blx+=120+mg*ENC_9_LOADED;
					use9=true;
				}else if(hdw is "Hunter"){
					int bluh=hdw.weaponstatus[HUNTS_TUBE];
					if(bluh>4)bluh+=(bluh-4)*2;
					bluh+=bluh+hdw.weaponstatus[HUNTS_SIDESADDLE];
					blx+=125+bluh*ENC_SHELLLOADED;
					use12=true;
				}else if(hdw is "Slayer"){
					blx+=100+hdw.weaponstatus[SLAYS_SIDESADDLE]*ENC_SHELLLOADED;
					use12=true;
				}else if(hdw is "ZM66AssaultRifle"){
					if(!(hdw.weaponstatus[0]&ZM66F_NOLAUNCHER)){
						blx+=125;
						if(
							hdw.weaponstatus[0]&ZM66F_GRENADELOADED
						)blx+=ENC_ROCKETLOADED;
						userocket=true;
					}else blx+=100;
					blx+=hdw.weaponstatus[ZM66S_MAG]*ENC_426_LOADED;
					use426=true;
				}else if(hdw is "Vulcanette"){
					blx+=225;
					if(hdw.weaponstatus[VULCS_BATTERY]>=0)blx+=ENC_BATTERY_LOADED;
					let vvv=vulcanette(hdw);
					for(int i=0;i<5;i++){
						if(vvv.vulcmag[i]>=0)
							blx+=ENC_426MAG_LOADED*min(10,vvv.vulcmag[i]);
					}
					usebattery=true;
					use426=true;
				}else if(hdw is "Blooper"){
					blx+=75;
					if(hdw.weaponstatus[0]&BLOPF_LOADED)blx+=ENC_ROCKETLOADED;
					userocket=true;
				}else if(hdw is "HDRL"){
					blx+=175+hdw.weaponstatus[RLS_MAG]*ENC_ROCKETLOADED;
					int chmb=hdw.weaponstatus[RLS_CHAMBER];
					if(chmb>1)blx+=ENC_HEATROCKETLOADED;
					else if(chmb==1)blx+=ENC_ROCKETLOADED;
					userocket=true;
					useheat=true;
				}else if(hdw is "LiberatorRifle"){
					if(!(hdw.weaponstatus[0]&LIBF_NOLAUNCHER)){
						blx+=150;
						if(
							hdw.weaponstatus[0]&LIBF_GRENADELOADED
						)blx+=ENC_ROCKETLOADED;
						userocket=true;
					}else blx+=125;
					blx+=hdw.weaponstatus[LIBS_MAG]*ENC_776_LOADED;
					use776=true;
				}else if(hdw is "ThunderBuster"){
					blx+=175;
					if(hdw.weaponstatus[1]>=0)blx+=ENC_BATTERY_LOADED;
					usebattery=true;
				}else if(hdw is "Brontornis"){
					blx+=75+(
						hdw.weaponstatus[BRONS_CHAMBER]>1?
						ENC_BRONTOSHELLLOADED:0
					);
					usebronto=true;
				}else if(hdw is "BFG9k"){
					if(hdw.weaponstatus[0]&BFGF_STRAPPED)blx+=200;
					else blx+=240;
					if(hdw.weaponstatus[BFGS_BATTERY]>=0)blx+=ENC_BATTERY_LOADED;
					usebattery=true;
				}else if(hdw is "BossRifle"){
					blx+=144+hdw.weaponstatus[BOSSS_MAG]*ENC_776_LOADED;
					use776=true;
				}
				if(thisweapon){
					enc+=blx;
					if(!forcefull)break;
				}else enc+=blx*1.6;
			}
		}

		//because herps are special
		let herp=HERPUsable(findinventory("HERPUsable"));
		if(herp){
			enc+=ENC_HERP+herp.ammo<0?0:ENC_426MAG*0.4;
			use426=true;
		}enc+=countinv("HERPDEAD")*ENC_HERP;

		//mag manager
		let hdmm=MagManager(findinventory("MagManager"));
		if(hdmm)enc+=
			(hdmm.weaponstatus[HDMMS_PIST]+hdmm.weaponstatus[HDMMS_SMG])*ENC_9+
			(hdmm.weaponstatus[HDMMS_LIB]+hdmm.weaponstatus[HDMMS_BOSS])*ENC_776;


		//and now for stuff that should just be listed
		enc+=

		//second pistol
		(
			(usesecondpistol&&countinv("HDSecondPistol"))?30
			+HDSecondPistol(
				findinventory("HDSecondPistol")
			).weaponstatus[PISS_MAG]*ENC_9MAG_LOADED:0
		)

		//armour
		+armourlevel*7
		+countinv("PortableRadsuit")*ENC_RADSUIT
		+(countinv("HDArmour")?(
			findinventory("HDArmour").meleethreshold==3?200:80
		):0)

		//usables
		+countinv("HDIEDKit")*ENC_IEDKIT
		+(countinv("PortableStimpack")+countinv("PortableBerserkPack"))*ENC_STIMPACK
		+countinv("SquadSummoner")*ENC_SQUADSUMMONER
		+countinv("BluePotion")*ENC_BLUEPOTION
		+countinv("PortableLiteAmp")*ENC_LITEAMP
		+countinv("PortableMedikit")*ENC_MEDIKIT
		+countinv("PortableLadder")*ENC_LADDER
		+countinv("DERPUsable")*ENC_DERP
		+countinv("DERPDEAD")*ENC_DERP

		//magged ammo
		+(use9?(
			countinv("HDPistolAmmo")*ENC_9
			+countinv("HDPistolMag")*ENC_9MAG
			+countinv("HDSMGMag")*ENC_9MAG30
		):0)
		+(use776?(
			countinv("SevenMilAmmo")*ENC_776
			+countinv("SevenMilBrass")*ENC_776B
			+countinv("BossClip")*ENC_776CLIP
			+countinv("LiberatorMag")*ENC_776MAG
		):0)
		+((use776||use426)?(
			countinv("FourMilAmmo")*ENC_426
		):0)
		+(use426?(
			countinv("FourMilAmmo")*ENC_426
			+countinv("ZM66RifleMags")*ENC_426MAG
		):0)
		+(usebattery?(
			countinv("HDCellAmmo")*ENC_BATTERY*0.3
			+countinv("HDCellPacks")*ENC_BATTERY
		):0)

		//single loose ammo
		+(use12?(
			countinv("HDShellAmmo")*ENC_SHELL
		):0)
		+(userocket?(
			countinv("HDRocketAmmo")*ENC_ROCKET
		):0)
		+(usebronto?(
			countinv("BrontornisRound")*ENC_BRONTOSHELL
		):0)
		+(useheat?(
			countinv("HEATAmmo")*ENC_HEATROCKET
		):0)
		+countinv("HDFragGrenadeAmmo")*ENC_FRAG

		//i will no longer protect you from your hoarding
		+countinv("DudRocketAmmo")*ENC_ROCKET
		+countinv("HDCellPackEmpty")*ENC_BATTERY
		;

		double carrymax=
			400+
			countinv("PowerStrength")*100+
			min(regenblues,150)+
			stimcount*2
		;
		return enc/carrymax;
	}
}



class doordestroyer:hdactor{
	default{
		+solid +nogravity +dontgib +ghost
		+actlikebridge
		height 0.1;radius 0.1;
	}
	vector2 v1pos;
	vector2 v2pos;
	vector2 vfrac;
	double llength;
	int llit;
	override void postbeginplay(){
		super.postbeginplay();
		vector2 vvv=(v2pos-v1pos);
		llength=vvv.length();
		llit=max(1,llength/10); //see chunkspeed
		vfrac=vvv/llit;

		A_HDBlast(
			pushradius:llength,pushamount:24,
			fragradius:llength,fragdamage:42,
			immolateradius:llength,
			immolateamount:random(10,30),
			immolatechance:12,
			gibradius:llength*0.4,gibamount:10
		);
	}
	void DoorChunk(class<actor>chunktype,int numpercolumn=1,double chunkspeed=10){
		chunkspeed*=0.1; //see vfrac
		for(int i=0;i<llit;i++){
			for(int j=0;j<numpercolumn;j++){
				actor aaa=spawn(chunktype,(
					(v1pos+vfrac*i),
					frandom(floorz,ceilingz)
				));
				aaa.vel.xy=rotatevector(
						vfrac,randompick(90,-90)+frandom(-60,60)
					)*chunkspeed*frandom(0.4,1.4);
				aaa.vel.z=frandom(-6,12);
				spawn("HDSmoke",(
					(v1pos+vfrac*i),
					floorz+frandom(1,32)
				));
			}
		}
	}
	states{
	spawn:
		TNT1 A 0;
		TNT1 A 0 DoorChunk("HDExplosion",3,3);
		TNT1 A 0 DoorChunk("HDSmoke",5,3);
		TNT1 AAA 1 DoorChunk("HugeWallChunk",20,15);
		TNT1 A 0 DoorChunk("HDSmoke",5,3);
		TNT1 A 0 DoorChunk("HDSmokeChunk",random(0,3),7);
		TNT1 AAAA 1 DoorChunk("HDSmoke",5,3);
		TNT1 A 0 DoorChunk("HDSmoke",5,3);
		TNT1 A 0 DoorChunk("HDSmokeChunk",random(0,3),7);
		TNT1 AAAA 2 DoorChunk("HugeWallChunk",20);
		TNT1 A -1;
		stop;
	}
	static const int doorspecials[]={
		//from LineSpecials[] in p_lnspec.cpp
		10,11,12,13,14, 85, 105,106, 202, 249, 274
	};
	static bool checkdoorspecial(int linespecial){
		int dlsl=doordestroyer.doorspecials.size();
		for(int i=0;i<dlsl;i++){
			if(linespecial==doordestroyer.doorspecials[i]){
				return true;
				break;
			}
		}
		return false;
	}
	static void destroydoor(actor caller){
		flinetracedata dlt;
		caller.linetrace(
			caller.angle,caller.radius*1.44,0,
			flags:TRF_THRUACTORS,
			offsetz:caller.height*0.5,data:dlt
		);
		if(dlt.hitline){
			sector othersector=hdmath.oppositesector(dlt.hitline,dlt.hitsector);
			if(
				othersector
				&&othersector.ceilingplane.zatpoint(dlt.hitlocation.xy+dlt.hitdir.xy)<dlt.hitlocation.z
			){
				//see if a door special applies
				bool isdoor=checkdoorspecial(dlt.hitline.special);

				//then do the above for all other lines tagging this sector :(
				if(!isdoor){
					//HOW THE FUCK DO YOU FIND A SECTOR TAG
					int brutalforcery=0;
					bool gotit=false;
					for(brutalforcery=0;brutalforcery<100;brutalforcery++){
						sectortagiterator sss=
							sectortagiterator.create(brutalforcery);
						int ssss=sss.next();
						while(!gotit&&ssss>-1){
							if(level.sectors[ssss]==othersector)gotit=true;
							ssss=sss.next();
						}
						if(gotit)break;
					}

					lineiditerator lll=lineiditerator.create(brutalforcery);
					int l=lll.next();
					while(!isdoor&&l>-1){
						isdoor=checkdoorspecial(level.lines[l].special);
						l=lll.next();
					}
				}

				if(!isdoor)return;

				//see how wide the door is
				vector2 doorline=dlt.hitline.v1.p-dlt.hitline.v2.p;
				double maxdoor=frandom(64,1128);
				if(doorline dot doorline > maxdoor*maxdoor)return;

				//see how thick the door is
				//what is the proper way of doing this
				vector3 posbak=caller.pos;
				caller.setorigin(caller.pos+((dlt.hitlocation.xy+dlt.hitdir.xy)*frandom(14,34),0),false);
				isdoor=(caller.cursector!=othersector);
				caller.setorigin(posbak,false);

				if(!isdoor)return;

				//not intended by the mapper
				textureid shwal=texman.checkfortexture("ASHWALL2",texman.type_any);
				if(int(shwal)<1)
					shwal=texman.checkfortexture("ASHWALL",texman.type_any);
				othersector.settexture(sector.ceiling,shwal,true);
				for(int i=0;i<othersector.lines.size();i++){
					othersector.lines[i].flags|=line.ML_DONTPEGTOP;
					for(int j=0;j<2;j++){
						side sdd=othersector.lines[i].sidedef[j];
						if(
							sdd
							&&int(sdd.gettexture(side.top))<1
						){
							sdd.settexture(side.top,shwal);
						}
					}
				}

				//blow that shit up
				othersector.flags|=sector.SECF_SILENTMOVE;
				double blockpoint=
					dlt.hitsector.ceilingplane.zatpoint(dlt.hitlocation.xy);
				othersector.MoveCeiling(100,blockpoint+random(3,12),0,1,false);

				let db=doordestroyer(spawn("doordestroyer",(
					(dlt.hitlocation.xy+dlt.hitdir.xy*2),blockpoint
				)));
				db.setz(blockpoint);
				db.v1pos=dlt.hitline.v1.p;
				db.v2pos=dlt.hitline.v2.p;
				db.target=caller.target;
			}
		}
	}
}
class doorball:doomimpball{
	states{
	death:
		BAL1 C 0{doordestroyer.destroydoor(self);}
		goto super::death;
	}
}

