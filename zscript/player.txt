// ------------------------------------------------------------
//   The player!
// ------------------------------------------------------------

class HDPlayerPawn:PlayerPawn{
	vector3 lastpos;double lastangle;double lastpitch;
	vector3 poschange;double anglechange;double pitchchange;
	actor playercorpse;
	states{
	see0:
		"----" A 0{
			A_TakeInventory("IsSupported");
			ACS_NamedExecuteAlways("Pain",0, 0,0, 4);
			if((getzat()>=pos.z)&&(random(1,3)==3)){  
				if(health<random(35,45)){
					if(countinv("IsCrouching")<1){A_ChangeVelocity(random(-4,2),frandom(-3,3),random(-1,0),CVF_RELATIVE);}
					A_ScaleVelocity(frandom(0.7,1.0));
				}else if(health<random(60,65)){
					if(countinv("IsCrouching")<1){A_ChangeVelocity(random(-2,1),frandom(-1,1),random(-1,0),CVF_RELATIVE);}
					A_ScaleVelocity(frandom(0.9,1.0));
				}
			}
			if(countinv("StunCount")>0){
				viewbob=1.4;
				return resolvestate("seestun");
			}
			else if(
				(countinv("IsSprinting")>0)&&
				(countinv("WasSprinting")>0)
			){
				viewbob=1.2;
				return resolvestate("seesprint");
			}
			else if(countinv("IsWalking")>0){
				return resolvestate("seewalk");
			}
			return resolvestate(null);
		}
		"####" ABCD 4{
			if(viewbob>0.8){viewbob-=0.1;}
			else if(viewbob<0.8){viewbob+=0.1;}
		}
		"----" A 0{return resolvestate("spawn");}
	seestun:
		"####" ABCD random(2,10) {
			A_GiveInventory("IsMoving",2);
		}
		"----" A 0{return resolvestate("spawn");}
	seewalk:
		"####" ABCD 6 {
			if((height>30)&&(countinv("IsWalking")>0)){
				A_TakeInventory("IsMoving",5);
				if(viewbob>1.2){viewbob=1.2;}
				else if(viewbob>0.2){viewbob-=0.1;}
			}
			else if(height<30){viewbob=1.8;}
			else if(viewbob<0.8){viewbob+=0.1;}
		}
		"----" A 0{return resolvestate("spawn");}
	seesprint:
		"----" A 4 {
			A_TakeInventory("PowerFrightener");
		}
		"####" B 2;
		"####" C 4;
		"####" D 2;
		"----" A 0{return resolvestate("spawn");}
	}
	override void PostBeginPlay(){
		super.PostBeginPlay();
		lastpos=pos;
		lastangle=angle;
		lastpitch=pitch;
	}
	//HIGHLY EXPERIMENTAL: ignore some collisions in the space between head and shoulders
	override bool cancollidewith(actor other,bool passive){
		if(height<40) return super.cancollidewith(other,passive); //ignore if crouched
		int dx=floor(abs(other.pos.x-self.pos.x));
		int dy=floor(abs(other.pos.y-self.pos.y));
		if(dy>dx) dx=dy;  
		int dz=floor(other.pos.z-self.pos.z);
		if(
			dz>44 //bottom of head
			&& dx>other.radius+3 //head radius
		){
			return false;
		}
		return super.cancollidewith(other,passive);
	}
	override void Tick(){
		if (!player||!player.mo||player.mo!= self){Super.Tick();return;} //anti-voodoodoll

		poschange=lastpos-pos;
		anglechange=HDMath.AngleChange(lastangle,angle);
		pitchchange=lastpitch-pitch;
		lastpos=pos;
		lastangle=angle;
		lastpitch=pitch;

		if(getcvar("gender")==0){A_GiveInventory("IsMale");A_TakeInventory("IsFemale");}
		else if(getcvar("gender")==1){A_GiveInventory("IsFemale");A_TakeInventory("IsMale");}
		else {A_TakeInventory("IsFemale");A_TakeInventory("IsMale");}

		super.Tick();
		//gotta translate everything from all those acs loops. yaaaaaaayyyy

		//only do anything below this while the player is alive!
		if(bkilled) return;

		//jumping/mantling
		JumpCheck();

		//move pivot point a little behind the player's view
		if(getzat()-pos.z==0){
			if(abs(anglechange)>1){
				int dir=90;
				if(anglechange<0) dir=-90;
				trymove(self.pos.xy+(cos(angle+dir)*0.8,sin(angle+dir)*0.8),false);
			}
			if(abs(pitchchange)>1 && -30<pitch<30){
				double rate=0.1;
				trymove(self.pos.xy-(cos(angle)*rate*pitchchange,
				sin(angle)*rate*pitchchange),false);
			}
		}

		//check use key
		if(
			getplayerinput(MODINPUT_BUTTONS) & BT_USE
			&& !(getplayerinput(MODINPUT_OLDBUTTONS) & BT_USE)
		){
			vector3 ap=(
				cos(pitch)*cos(angle),
				cos(pitch)*sin(angle),
				-sin(pitch)
			);
			actor a=spawn("userpickerupper",ap+(0,0,height-12));
			a.target=self;
			a.vel=ap*4;
		}
	}
}



//Camera actor for player's scope
class ViewDummy:IdleDummy{
	override void postbeginplay(){
		A_CheckProximity("spawndropped","PlayerPawn",10,1, CPXF_COUNTDEAD|CPXF_SETMASTER|CPXF_ANCESTOR|CPXF_CLOSEST|CPXF_NOZ);
	}
	override void Tick(){
		if(!master){
			destroy();
			return;
		}else{
			self.angle=master.angle;
			self.pitch=master.pitch;
			self.setxyz(master.pos+(
				cos(pitch)*cos(angle)*6,
				cos(pitch)*sin(angle)*6,
				sin(-pitch)*6+master.height-4
			));
			nexttic();
		}
	}
}

//Projectile for using things that aren't switches and doors
class userpickerupper:hdactor{
	default{
		projectile;
		height 3;radius 3;+solid;
	}
	states{
	spawn:
		BLET A 1 nodelay{
			if(vel.xy==(0,0))vel.x=minvel;
			for(int i=0;i<10;i++){
				if(!trymove(pos.xy+vel.xy,true)){
					if(blockingline) return;
					if(blockingmobj){
						if( (//blockingmobj.findstate("grabbed",true) && (
							blockingmobj is "Weapon"
							|| blockingmobj is "CustomInventory"
							|| blockingmobj is "Inventory")
						){
							blockingmobj.target=self.target;
							blockingmobj.vel-=vel*2+(0,0,target.height);
							blockingmobj.vel+=target.vel;
						}
					}
				}
				addz(vel.z);
			}
		}stop;
	}
}