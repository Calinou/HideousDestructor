// ------------------------------------------------------------
//   Setting things on fire
// ------------------------------------------------------------

class HDFireEnder:InventoryFlag{
	default{
		inventory.maxamount 5;
	}
}
class HDFireDouse:InventoryFlag{
	default{
		inventory.maxamount 70;
	}
	override void Tick(){
		super.Tick();
		if(amount>0){
			amount--;
		}
	}
}


class HDFireStarter:ActionItem{
	states{
	pickup:
		TNT1 A 0{
			if(!self) return;
			if(hd_debug)a_log("deprecated fire. please use A_Immolate() directly.");
			actor f=spawn("HDFire",pos);
			f.target=self;f.master=self.target;
			f.stamina=random(40,80);
			return;
		}fail;
	}
}


//how to immolate
extend class HDActor{
	//should be in HDActor once all conversions are done
	//A_Immolate(tracer,target);
	virtual void A_Immolate(
		actor victim,
		actor perpetrator,
		int duration=0
	){
		actor f=victim.spawn("HDFire",victim.pos);
		f.target=victim;f.master=perpetrator;
		if(duration<1) f.stamina=random(40,80);
		else f.stamina=duration;
		if(victim is "PlayerPawn")f.changetid(-7677);
	}
}
//fire actor
class HDFire:IdleDummy{
	int halfrad;int minz;int maxz;int lastheight;
	default{
		obituary "%o was burned by %k.";
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(target){
			stamina=target.ApplyDamageFactor("Thermal",stamina);
			if(target is "PlayerPawn" || target is "HDPlayerCorpse"){
				changetid(-7677);
				if(!skill||hd_lowdamage)stamina=max(1,stamina*0.3);
			}
		}
		if(A_CheckProximity("null","HDFire",64,12,CPXF_CHECKSIGHT|CPXF_SETTRACER)){
			tracer.stamina+=stamina;
			destroy();
			return;
		}
		if(hd_debug)A_Log(string.format("fire duration \ci%i",stamina));
	}
	override void ondestroy(){
		if(target && target is "PersistentDamager") target.destroy();
		super.ondestroy();
	}
	states{
	spawn:
		TNT1 A 3{
			A_Warp(AAPTR_TARGET);
			if(waterlevel){
				destroy();
				if(waterlevel<2)spawn("HDSmoke",pos);
				return;
			}
			if(!master)master=self;
			if(!target){
				target=spawn("PersistentDamager",self.pos);
				target.target=master;
				if(stamina>20)stamina=20;
			}
			A_SetTics(clamp(random(8,30-stamina*0.1),4,12));
			if(stamina<=0 || target.countinv("HDFireEnder")){
				A_TakeFromTarget("HDFireEnder");
				spawn("HDSmoke",pos);
				destroy();
				return;
			}
			int ds=target.countinv("HDFireDouse");
			if(ds){
				target.A_TakeInventory("HDFireDouse",ds);
				stamina-=ds;
			}
			stamina--;

			//set flame spawn point
			if(lastheight!=target.height){ //poll only height
				halfrad=max(4,target.radius*0.5);
				lastheight=target.height;
				minz=lastheight*0.2;
				maxz=max(lastheight*0.75,4);
			}

			//position and spawn flame
			setorigin(pos+(
					random(-halfrad,halfrad),
					random(-halfrad,halfrad),
					random(minz,maxz)
			),false);
			actor sp=spawn("HDFlameRed",pos);
			sp.vel+=target.vel+(frandom(-2,2),frandom(-2,2),frandom(-1,3));
			A_PlaySound("misc/firecrkl",CHAN_AUTO,0.4,0,6);

			//check if player
			let tgt=HDPlayerPawn(target);
			if(tgt){
				A_AlertMonsters();
				A_TakeFromTarget("PowerFrightener");
				A_TakeFromTarget("IsWeaponReady");
				A_GiveToTarget("IsHurt",1);
				A_GiveToTarget("IsMoving",4);
			}
			//damage the target
			//don't touch the bsolid, else crash trying to hurt the plasma beamspot
			if(target.bsolid)
				target.damagemobj(self,master,1,"Thermal",flags:DMG_NO_FACTOR);
		}
		wait;
	}
}




//an invisible actor that constantly damages anything it collides with
/* special uses:
	threshold = damage interval
	damage = *exact* damage amount each time
	accuracy = temporary number tracking interval
	gibhealth = % chance to immolate
*/
class PersistentDamager:HDActor{
	vector3 relpos;
	default{
		+noblockmap +missile
		height 8;radius 8;threshold 35;damage 1;accuracy 0;gibhealth 5;
		damagetype "thermal";
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(master) relpos=self.pos-master.pos;
	}
	override void tick(){
		if(globalfreeze||level.Frozen) return;

		if(master) setorigin(master.pos+relpos,false);
		trymove(pos.xy+(minvel,0),true);

		nexttic();
	}
	override bool CanCollideWith(actor other,bool passive){
		if(
			passive
			||!other.bsolid
			||(
				target &&
				target.bdontharmspecies &&
				other.getspecies()==target.getspecies()
			)
		){
			return false;
		}
		if(!random(0,threshold)){
				other.damagemobj(self,target,damage,damagetype);
				if(gibhealth && gibhealth>=random(1,100)){
					A_Immolate(other,target,random(1,gibhealth));
				}
		}
		return false;
	}
	states{
	spawn:
		TNT1 A -1;
	}
}




//This is as yet unused: a different way of setting things on fire.
//Apparently it causes immediate desync.
class fffire:inventory{
	int tttimer;
	default{
		+inventory.untossable
		inventory.maxamount 10000;
		obituary "Everyone! %o was on fire!";
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(!master)master=self;
	}
	override void attachtoowner(actor user){
		if(!user.bsolid&&!user.bshootable){destroy();return;}
		super.attachtoowner(user);
	}
	override void doeffect(){
		//because obituaries and respawn :(
		if(owner.health<1){
			let onr=HDPlayerPawn(owner);
			if(onr){
				if(onr.playercorpse)owner=onr.playercorpse;
				else goawayanddie();
				return;
			}
		}
		if(!tttimer){
			tttimer=min(4,100/amount);
			int times=clamp(amount*0.01,1,20); //adjust numbers to taste
			while(times){
				times--;
				int rad=max(4,owner.radius*0.5);
				int hit=max(8,owner.height*0.6);
				actor p=spawn("HDFlameRed",
					owner.pos+(
						random[fff](-rad,rad),
						random[fff](-rad,rad),
						random[fff](1,hit)
					),ALLOW_REPLACE
				);
				p.vel+=owner.vel*0.7+(0,0,4);
				owner.A_PlaySound("vile/firecrkl",CHAN_AUTO,max(1.,amount*0.01));
				owner.damagemobj(self,master,1,"fire",DMG_NO_ARMOR|DMG_THRUSTLESS);
				if(!owner){goawayanddie();return;}
			}
			amount--;
			if(owner.waterlevel>1){
				amount-=10*owner.waterlevel;
				if(owner.waterlevel<2)spawn("HDSmoke",owner.pos);
			}
			if(!amount)goawayanddie();
		}
		else tttimer--;
	}
}

