// ------------------------------------------------------------
// Setting things on fire
// ------------------------------------------------------------
class ImmunityToFire:InventoryFlag{
	override void attachtoowner(actor user){
		super.attachtoowner(user);
		if(owner){
			actoriterator it=actoriterator.create(-7677,"HDFire");
			actor fff;
			while(fff=it.next()){
				if(fff.target==owner){
					fff.destroy();
				}
			}
		}
	}
}
class HDFireEnder:InventoryFlag{
	default{
		inventory.maxamount 5;
	}
}
class HDFireDouse:InventoryFlag{
	default{
		inventory.maxamount 20;
	}
	override void DoEffect(){
		if(amount>0)amount--;
	}
}


class HDFireStarter:ActionItem{
	states{
	pickup:
		TNT1 A 0{
			if(!self) return;
			if(hd_debug)a_log("deprecated fire. please use A_Immolate() directly.");
			actor f=spawn("HDFire",pos);
			f.target=self;f.master=self.target;
			f.stamina=random(40,80);
			return;
		}fail;
	}
}


//how to immolate
extend class HDActor{
	//should be in HDActor once all conversions are done
	//A_Immolate(tracer,target);
	virtual void A_Immolate(
		actor victim,
		actor perpetrator,
		int duration=0
	){
		if(!victim
			||(
				perpetrator&&
				perpetrator.bdontharmspecies&&
				perpetrator.getspecies()==victim.getspecies()
			)
		){
			victim=spawn("PersistentDamager",self.pos);
			victim.target=perpetrator;
		}
		actor f=victim.spawn("HDFire",victim.pos);
		f.target=victim;f.master=perpetrator;
		if(duration<1) f.stamina=random(40,80);
		else f.stamina=duration;
		if(victim is "PlayerPawn")f.changetid(-7677);
	}
}
//fire actor
class HDFire:IdleDummy{
	int halfrad;int minz;int maxz;int lastheight;
	default{
		+bloodlessimpact
		obituary "%o was burned by %k.";
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(target){
			stamina=target.ApplyDamageFactor("Thermal",stamina);
			if(target is "PlayerPawn" || target is "HDPlayerCorpse"){
				changetid(-7677);
				if(!skill||hd_lowdamage)stamina=max(1,stamina*0.3);
			}
			if(!target.bshootable && stamina>20)stamina=20;
		}
		if(
			A_CheckProximity("null","HDFire",64,12,CPXF_CHECKSIGHT|CPXF_SETTRACER)
			&&(!target||tracer.target==target)
		){
			tracer.stamina+=stamina;
			destroy();
			return;
		}
		if(hd_debug)A_Log(string.format("fire duration \ci%i",stamina));
	}
	override void ondestroy(){
		if(target&&target is "PersistentDamager")target.destroy();
		super.ondestroy();
	}
	states{
	spawn:
		TNT1 A 3{
			if(target&&target.countinv("ImmunityToFire")){
				destroy();return;
			}

			if(waterlevel){
				destroy();
				if(waterlevel<2)spawn("HDSmoke",pos);
				return;
			}
			if(!master)master=self;
			if(!target){
				target=spawn("PersistentDamager",self.pos);
				target.target=master;
				if(stamina>20)stamina=20;
			}
			setorigin(target.pos,false);
			A_SetTics(clamp(random(3,30-stamina*0.1),2,12));
			if(stamina<=0 || target.countinv("HDFireEnder")){
				A_TakeFromTarget("HDFireEnder");
				spawn("HDSmoke",pos);
				destroy();
				return;
			}
			int ds=target.countinv("HDFireDouse");
			if(ds){
				target.A_TakeInventory("HDFireDouse",ds);
				stamina-=ds;
			}
			stamina--;

			//set flame spawn point
			if(lastheight!=target.height){ //poll only height
				halfrad=max(4,target.radius*0.5);
				lastheight=target.height;
				minz=lastheight*0.2;
				maxz=max(lastheight*0.75,4);
			}

			//position and spawn flame
			setorigin(pos+(
					random(-halfrad,halfrad),
					random(-halfrad,halfrad),
					random(minz,maxz)
			),false);
			actor sp=spawn("HDFlameRed",pos);
			sp.vel+=target.vel+(frandom(-2,2),frandom(-2,2),frandom(-1,3));
			A_PlaySound("misc/firecrkl",CHAN_AUTO,0.4,0,6);

			//check if player
			let tgt=HDPlayerPawn(target);
			if(tgt){
				if(tgt.playercorpse){
					target=tgt.playercorpse;
				}
				A_AlertMonsters();
				A_TakeFromTarget("PowerFrightener");
				A_GiveToTarget("WeaponBusy",1);
				A_GiveToTarget("IsMoving",4);
			}else stamina-=3; //monsters assumed to be trying to douse
			//damage the target
			target.A_GiveInventory("Heat",clamp(stamina,20,random(20,80)));
//			target.damagemobj(self,master,randompick(0,0,0,1),"Thermal",flags:DMG_NO_FACTOR);
		}
		wait;
	}
}




//an invisible actor that constantly damages anything it collides with
/* special uses:
	accuracy = amount of heat to give each cycle
*/
class PersistentDamager:HDActor{
	vector3 relpos;
	default{
//		+noblockmap +missile
		+solid
		damagetype "Thermal";

		height 8;radius 8;
		stamina 8;
	}
	override void postbeginplay(){
		super.postbeginplay();
		if(master)relpos=self.pos-master.pos;
	}
	override bool cancollidewith(actor other,bool passive){
		if(passive&&!ticker&&other.bshootable&&!other.bnodamage){
			if(damagetype=="Thermal"){
				HDF.Give(other,"Heat",stamina*10);
				stamina--;
				if(accuracy<1){destroy();return false;}
			}else other.damagemobj(self,target,stamina,damagetype);
		}
		return false;
	}
	int ticker;
	override void tick(){
		if(globalfreeze||level.Frozen) return;

		if(master)setorigin(master.pos+relpos,false);
		if(ticker<4)ticker++;else ticker=0;

		//nexttic
		if(CheckNoDelay()){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}
	states{
	spawn:
		TNT1 A -1;
	}
}


//new shit

class Heat:Inventory{
	double volume;
	double volumeratio;
	double inversevolumeratio;
	double baseinversevolumeratio;
	double realamount;
	int burnoutthreshold;
	actor heatfield;
	enum HeatNumbers{
		HEATNUM_DEFAULTVOLUME=12*12*48*4,
	}
	states{spawn:TNT1 A 0;stop;}
	default{
		+inventory.untossable //for some reason this works without it
		inventory.amount 1;
		inventory.maxamount 9999999;
		obituary "%o was too hot to handle.";
	}
	static double GetAmount(actor heated){
		let htt=Heat(heated.findinventory("Heat"));
		if(!htt)return 0;
		return htt.realamount;
	}
	override void attachtoowner(actor user){
		super.attachtoowner(user);
		volume=(user.radius*user.radius*user.height)*4;
		baseinversevolumeratio=HEATNUM_DEFAULTVOLUME/max(0.000001,volume);
		inversevolumeratio=baseinversevolumeratio;
		volumeratio=1/baseinversevolumeratio;
		burnoutthreshold=max(user.gibhealth,user.spawnhealth(),100);
		A_SetSize(owner.radius,owner.height);
	}
	override void DoEffect(){
		if(!owner){destroy();return;}
		if(!owner.player&&(globalfreeze||level.Frozen))return;

		//make adjustments based on armour and player status
		let hdp=hdplayerpawn(owner);
		if(hdp){
			inversevolumeratio=baseinversevolumeratio;
			int al=hdp.armourlevel;
			if(al==1){
				inversevolumeratio*=0.4;
				amount=max(0,amount-5);
			}else if(al==3)inversevolumeratio*=0.6;
			if(
				hdp.health<1&&
				hdp.playercorpse
			){
				hdp.playercorpse.A_GiveInventory("Heat",1);
				Heat(hdp.playercorpse.findinventory("Heat")).realamount+=realamount;
				destroy();
				return;
			}
		}

		//convert given to real
		if(amount){
			realamount+=amount*inversevolumeratio;
			amount=0;
		}
		//clamp number to zero
		if(realamount<1){
			realamount=0;
			return;
		}
		int ticker=level.time;

		//flame
		if(
			!(ticker%3)
			&&realamount>frandom(100,140)
			&&!owner.bnodamage
			&&!owner.countinv("ImmunityToFire")
			&&owner.countinv("SawGib")<burnoutthreshold*frandom(0.8,1.2)
		){
			if(owner.bshootable){
				realamount+=frandom(1.2,3.0);
				if(realamount>random(150,1000))hdf.give(owner,"SawGib",1);
				if(!random(0,15))owner.A_TakeInventory("VileCount",1);
			}
			actor aaa;
			if(
				realamount<500
				||countinv("SawGib")/burnoutthreshold>0.99
			)aaa=spawn("HDFlameRed",owner.pos+(
				frandom(-radius,radius),
				frandom(-radius,radius),
				frandom(2,owner.height)
			));else{
				aaa=spawn("HDFlameRedBig",owner.pos+(
					frandom(-radius,radius)*0.6,
					frandom(-radius,radius)*0.6,
					frandom(5,owner.height*0.2)
				));
				spawn("HDSmoke",aaa.pos);
				aaa.scale=(frandom(0.9,1.2),randompick(-1,1)*frandom(0.9,1.1))*min(realamount*0.001,3.);
			}
			aaa.target=owner;
			aaa.A_PlaySound("misc/firecrkl",CHAN_BODY,clamp(realamount*0.001,0,0.2));
		}

		//damage
		if(
			!(ticker%3)
			&&owner.bshootable&&!owner.bnodamage
			&&(owner.countinv("WornRadsuit")?realamount*0.1:realamount)>random(random(7,12),70)
		){
			double dmgamt=realamount*0.01;
			if(
				dmgamt<1.
				&&(frandom(0.,1.)<dmgamt)
			)dmgamt=1.;
			setxyz(owner.pos);
			owner.damagemobj(self,self,dmgamt,"thermal",DMG_NO_ARMOR);
			if(!owner)return;
		}


		//convection, kinda
		if(ticker>20&&!(ticker%2)){
			flinetracedata hlt;
			double aimdist=realamount*0.1;
			owner.linetrace(
				frandom(0,360),aimdist,frandom(-80,-90),
				offsetz:0,
				data:hlt
			);
			if(
				hlt.hitactor
				&&(
					!hlt.hitactor.findinventory("Heat")
					||heat(hlt.hitactor.findinventory("Heat")).realamount<realamount
				)
			){
				let htt=heat(hlt.hitactor.findinventory("Heat"));
				if(!htt)htt=heat(hlt.hitactor.GiveInventoryType("heat"));
				double distdiff=hlt.distance/aimdist;
				double togive=realamount*(1.-distdiff)*0.01*volume/max(1.,htt.volume);
				htt.realamount+=togive;
				realamount-=togive;
			}
		}

		//cooldown
		double reduce=inversevolumeratio;
		if(owner.vel dot owner.vel > 4)reduce*=1.6;
		double aang=absangle(angle,owner.angle);
		if(aang>4.)reduce*=clamp(aang*0.4,1.,4.);
		if((!skill||hd_lowdamage)&&owner.player)reduce*=3;
		realamount-=reduce;
		angle=owner.angle;

//if(owner.player)A_LogFloat(realamount);
	}
}





