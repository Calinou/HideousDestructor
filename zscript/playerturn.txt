// ------------------------------------------------------------
//   Stuff related to player turning
// ------------------------------------------------------------

extend class HDPlayerPawn{
	vector2 muzzledrift;
	bool muzzlehit;

	void TurnCheck(){

		//temporary variables
		double anglechange=0;
		double pitchchange=0;

		//get input
		double yaw=iyaw*(360./65536.);
		double ptch=ipitch*(360./65536.);


		//delete when overriding directly
		//revisit jitter issue when this is gone
		lastangle=angle-yaw;
		lastpitch=pitch+ptch;
		A_SetAngle(lastangle,SPF_INTERPOLATE);
		A_SetPitch(lastpitch,SPF_INTERPOLATE);


		//reduced turning while supported.
		if(countinv("IsSupported") && !getcvar("cl_run") && abs(yaw)<8 && !countinv("IsMoving")){
			yaw*=0.1;ptch*=0.1;
		}
		//reduced turning while crouched.
		else if(height<40 && abs(yaw)>5){
			yaw*=0.6;ptch*=0.6;
		}
		anglechange+=yaw;pitchchange-=ptch;

		if(1){
			//get weapon size
			double amt=0;
			int barrellength=0;
			double barrelwidth=0;
			int barreldepth=0;
			let wp=HDWeapon(player.readyweapon);
			if(wp && wp.gunmass>0){
				amt=wp.gunmass;
				barrellength=wp.barrellength;
				barrelwidth=wp.barrelwidth;
				barreldepth=wp.barreldepth;
			}else if(wp is "Lumberjack"){
				amt=8+
					(countinv("LumberCell")||countinv("LumberEmptyCell")?1:0)
				;
				barrellength=30;
				barrelwidth=1.5;
				barreldepth=2;
			}else if(wp is "HDSMG"){
				amt=5+
					countinv("HDSMGLoaded")*0.02+
					(countinv("HDSMGNoMag")?0:0.5)
				;
				barrellength=26;
				barrelwidth=0.5;
				barreldepth=1;
			}else if(wp is "Hunter"){
				amt=8+
					countinv("ShotgunTube")*0.4+
					countinv("ShotgunQuickAmmo")*0.07
				;
				barrellength=30;
				barrelwidth=0.5;
				barreldepth=2;
			}else if(wp is "Slayer"){
				amt=6+countinv("ShotgunQuickAmmo2")*0.08;
				barrellength=26;
				barrelwidth=1;
				barreldepth=1;
			}else if(wp is "ZM66Rifle" || wp is "ZM66SemiRifle"){
				amt=7+countinv("ZM66Loaded")*0.03;
				barrellength=25;
				barrelwidth=0.5;
				barreldepth=1;
			}else if(wp is "ZM66GrenadeRifle"){
				amt=8+
					countinv("ZM66Loaded")*0.03+
					countinv("ZM66GLoaded")
				;
				barrellength=28;
				barrelwidth=1;
				barreldepth=3;
			}else if(wp is "Vulcanette"){
				amt=14+
					(countinv("VulcLoaded1")?1:0)+
					(countinv("VulcLoaded2")?1:0)+
					(countinv("VulcLoaded3")?1:0)+
					(countinv("VulcLoaded4")?1:0)+
					(countinv("VulcLoaded5")?1:0)+
					(countinv("VulcJuice")?1:0)+
					(countinv("VulcEmptyCell")?1:0)
				;
				barrellength=30;
				barrelwidth=2;
				barreldepth=7;
			}else if(wp is "RocquetteLauncher"){
				amt=10+
					countinv("RocketMag")+
					countinv("HEATLoaded")*2
				;
				barrellength=32;
				barrelwidth=2;
				barreldepth=8;
			}else if(wp is "Blooper"){
				amt=4+countinv("BloopChamber");
				barrellength=24;
				barrelwidth=1.6;
				barreldepth=3;
			}else if(wp is "LiberatorRifle"){
				amt=9+
					countinv("LiberatorLoaded")*0.1
				;
				barrellength=26;
				barrelwidth=0.5;
				barreldepth=1;
			}else if(wp is "LiberatorGrenadeRifle"){
				amt=10+
					countinv("LiberatorLoaded")*0.02+
					(countinv("LiberatorGrenadeChamber")?1:0)
				;
				barrellength=29;
				barrelwidth=1;
				barreldepth=3;
			}else if(wp is "ThunderBuster"){
				amt=10+
					(countinv("PlasmaBattery")||countinv("PlasmaEmptyCell")?2:0)
				;
				barrellength=28;
				barrelwidth=1.6;
				barreldepth=3;
			}else if(wp is "Brontornis"){
				amt=6+countinv("BrontornisMag");
				barrellength=24;
				barrelwidth=1;
				barreldepth=2;
			}else if(wp is "BFG9k"){
				amt=19+
					(countinv("BFGLoaded")||countinv("BFGChamber")?1:0)
				;
				barrellength=32;
				barrelwidth=3.5;
				barreldepth=12;
			}else if(wp is "BossRifle"){
				amt=12;
				barrellength=40;
				barrelwidth=1;
				barreldepth=2;
			}

			//inertia adjustments for other things
			if(stunned){
				amt=max(17,amt);
			}else if(countinv("PowerStrength")||countinv("PowerInvulnerable")){
				amt*=0.2;
			}
			if(countinv("WeaponBusy")){
				barrellength=0;
				amt=min(amt*1.5,20);
			}


			//muzzle inertia

			//how much to scale movement
			double proportion=1-min(0.042*amt,0.99);
			double proportion2=0.05*amt;
			double proportion3=1-proportion*0.7;

			//take the proportion and use that OR crouch+support, whichever is LESS
			double yawcap=abs(yaw*proportion);
			double ptchcap=abs(ptch*proportion);
			anglechange=clamp(anglechange,-yawcap,yawcap);
			pitchchange=clamp(pitchchange,-ptchcap,ptchcap);


			//see if there's any change in velocity overall
			vector3 muzzlevel=lastvel-vel;

			//apply crouch/jump
			double curheight=height;
			muzzlevel.z-=(lastheight-curheight)*0.3;
			lastheight=curheight;

			//determine velocity-based horizontal drift
			//how to tell if it is to left or right?
			//rotate vector so that player is facing east
			//the y value is what we need
			muzzlevel.xy=rotatevector(muzzlevel.xy,-angle);

			muzzledrift+=(muzzlevel.y,muzzlevel.z)*proportion2;


			//NOW apply the drift!
			muzzledrift+=(anglechange,pitchchange);
			anglechange+=muzzledrift.x*proportion2;
			pitchchange+=muzzledrift.y*proportion2;
			muzzledrift*=proportion3;



			//good old jitters!
			//gotta do this after inertia and before collision,
			//to keep this from clipping your gun into the geometry.
			if(
				bloodpressure>20||
				health<33
			){
				double jitter=0.3;
				if(countinv("IsSupported"))jitter=0.05;
				else if(health<20)jitter=1;
				anglechange+=frandom(-jitter,jitter);
				pitchchange+=frandom(-jitter,jitter);
			}




			//weapon collision

			//temporarily set attackzoffset
			double azobak=attackzoffset;
			vector3 posbak=pos;
			vector3 posgunorigin=pos+(0,0,height-6);
			attackzoffset=height*0.5-6;
			vector3 posadj=(cos(angle+90),sin(angle+90),0)*barrelwidth; //starts to the LEFT
			vector3 posadj2=(-cos(angle)*cos(pitch+90),-sin(angle)*cos(pitch+90),-sin(pitch+90))*barreldepth;

			//and now uh do stuff
			actor muzpuf;
			int stuff;
			int muzhit=0;

			double distleft=barrellength;;
			double distright=barrellength;;
			double disttop=barrellength;
			double distbottom=barrellength;

			//left
			setxyz(posbak+posadj);
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distleft=(muzpuf.pos-(posgunorigin+posadj)).length();
				muzpuf.destroy();
			}else muzhit++;
			//right
			setxyz(posbak-posadj);
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distright=(muzpuf.pos-(posgunorigin-posadj)).length();
				muzpuf.destroy();
			}else muzhit++;

			//top
			setxyz(posbak);
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				disttop=(muzpuf.pos-posgunorigin).length();
				muzpuf.destroy();
			}else muzhit++;
			//bottom
			setxyz(posbak+posadj2);
			attackzoffset-=barreldepth;
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distbottom=(muzpuf.pos-(posgunorigin-(0,0,barreldepth))).length();
				muzpuf.destroy();
			}else muzhit++;
			attackzoffset+=barreldepth;

			//restore position
			setxyz(posbak);

			//set angles
	
			bool mvng;if(lastheight!=height || vel.length()<0.5)mvng=true;
			bool hitsnd;
			if(max(abs(anglechange),abs(pitchchange))>1)hitsnd=true;

			if(distleft<distright){
				anglechange=max(distleft-barrellength,mvng?0:-4);
			}else if(distleft>distright){
				anglechange=min(barrellength-distright,mvng?0:4);
			}

			if(disttop>distbottom){
				pitchchange=max(distbottom-barrellength,mvng?0:-4);
			}else if(disttop<distbottom){
				pitchchange=min(barrellength-disttop,mvng?0:4);
			}

			if(!muzhit){
				double blah=(barrellength-disttop)*0.02;
				A_Recoil(blah);
			}


			//bump
			if(muzhit>=4){
				muzzlehit=false;
			}else if(!muzzlehit){
				if(hitsnd)A_PlaySound("weapons/rifleclick2",CHAN_AUTO,0.6);
				muzzlehit=true;
			}

			//reset attackzoffset and position
			setxyz(posbak);
			attackzoffset=azobak;
		}



//if(anglechange)A_LogFloat(anglechange);



		//set everything and update old
		A_SetAngle(lastangle+anglechange,SPF_INTERPOLATE);
		A_SetPitch(lastpitch+pitchchange,SPF_FORCECLAMP|SPF_INTERPOLATE);


		//feet angle
		double fac=hdmath.anglechange(angle,feetangle);
		if(pos.z==zat && abs(fac)>50-(height<40?20:0)){
			vel+=rotatevector((0,fac/abs(fac)*0.1),angle);
			A_GiveInventory("IsMoving",2);
			feetangle+=clamp(angle-feetangle,-10,10);
			if(
				instatesequence(curstate,resolvestate("spawn"))
			)setstatelabel("see");

			int chancetodouse=63;
			//if on appropriate terrain, easier to quench a fire
			if(CheckLiquidTexture())chancetodouse*=0.4;
			if(height<40 && floorz==pos.z && !random(0,chancetodouse)){
				if(A_CheckProximity("null","HDFire",20,1,CPXF_SETTRACER)){
					tracer.A_SpawnItemEx("HDSmoke",
						random(-3,3),random(-3,3),random(3,7),
						vel.x,vel.y,vel.z,
						flags:SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM
					);
					tracer.destroy();
				}
			}
		}

		//move pivot point a little behind the player's view
		anglechange=HDMath.AngleChange(lastangle,angle);
		if(zat-pos.z==0){
			if(abs(anglechange)>1){    
				int dir=90;
				if(anglechange<0) dir=-90;
				trymove(self.pos.xy+(cos(angle+dir)*0.8,sin(angle+dir)*0.8),false);
			}
			if(abs(pitchchange)>1 && -30<pitch<30){    
				double rate=0.1;
				trymove(self.pos.xy-(cos(angle)*rate*pitchchange,
				sin(angle)*rate*pitchchange),false);
			}
		}
	}




	//seeing if you're standing on a liquid texture
	static const String lq[]={
		"MFLR8_4","MFLR8_2",
		"SFLR6_1","SFLR6_4",
		"SFLR7_1","SFLR7_4",
		"FWATER1","FWATER2","FWATER3","FWATER4",
		"BLOOD1","BLOOD2","BLOOD3",
		"SLIME1","SLIME2","SLIME3","SLIME4",
		"SLIME5","SLIME6","SLIME7","SLIME8"
	};
	bool standingonliquid;
	bool CheckLiquidTexture(){
		int lqlength=lq.size();
		for (int i=0; i<lqlength; i++){
			TextureID tx = TexMan.CheckForTexture(lq[i], TexMan.Type_Flat);
			if (tx && floorpic == tx){
				return true;
			}
		}
		return false;
	}

	//Muzzle climb!
	void MuzzleClimb(
		double down,
		double left,
		bool doublemoving=true
	){
		if(doublemoving && countinv("ismoving")){down*=2;left*=2;}
		muzzledrift+=(left,down);
	}
}

class MuzzleBlockerPuff:IdleDummy{
	default{
		+nodecal +puffonactors +notrigger
	}
}

