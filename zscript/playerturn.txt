// ------------------------------------------------------------
//   Stuff related to player turning
// ------------------------------------------------------------

extend class HDPlayerPawn{
	vector2 muzzledrift;

	void TurnCheck(){

		//temporary variables
		double anglechange=0;
		double pitchchange=0;

		//get input
		double yaw=iyaw*(360./65536.);
		double ptch=ipitch*(360./65536.);


		//delete when overriding directly
		//revisit jitter issue when this is gone
		lastangle=angle-yaw;
		lastpitch=pitch+ptch;
		A_SetAngle(lastangle,SPF_INTERPOLATE);
		A_SetPitch(lastpitch,SPF_INTERPOLATE);


		//reduced turning while supported.
		if(countinv("IsSupported") && !getcvar("cl_run") && abs(yaw)<8 && !countinv("IsMoving")){
			yaw*=0.1;ptch*=0.1;
		}
		//reduced turning while crouched.
		else if(height<40 && abs(yaw)>5){
			yaw*=0.6;ptch*=0.6;
		}
		anglechange+=yaw;pitchchange-=ptch;

		if(!barehanded){
			//get weapon mass (for weapon inertia)
			int amt=20;

			//get barrel size (for weapon collision)
			int barrellength=30;
			int barrelwidth=2;
			int barreldepth=3;


			//muzzle inertia

			//how much to scale movement
			double proportion=1.-min(0.042*amt,0.99);
			double proportion2=0.03*amt;

			//take the proportion and use that OR crouch+support, whichever is LESS
			double yawcap=abs(yaw*proportion);
			double ptchcap=abs(ptch*proportion);
			anglechange=clamp(anglechange,-yawcap,yawcap);
			pitchchange=clamp(pitchchange,-ptchcap,ptchcap);


			//see if there's any change in velocity overall
			vector3 muzzlevel=lastvel-vel;

			//apply crouch/jump
			double curheight=height;
			muzzlevel.z-=(lastheight-curheight)*0.3;
			lastheight=curheight;

			//determine velocity-based horizontal drift
			//how to tell if it is to left or right?
			//rotate vector so that player is facing east
			//the y value is what we need
			muzzlevel.xy=rotatevector(muzzlevel.xy,-angle);

			muzzledrift+=(muzzlevel.y,muzzlevel.z)*proportion2;


			//NOW apply the drift!
			muzzledrift+=(anglechange,pitchchange);
			anglechange+=muzzledrift.x*proportion2;
			pitchchange+=muzzledrift.y*proportion2;
			muzzledrift*=-(proportion-1);


			//weapon collision

			//temporarily set attackzoffset
			double azobak=attackzoffset;
			vector3 posbak=pos;
			vector3 posgunorigin=pos+(0,0,height-6);
			attackzoffset=height*0.5-6;
			vector3 posadj=(cos(angle+90),sin(angle+90),0)*barrelwidth; //starts to the LEFT

			//and now uh do stuff
			actor muzpuf;
			int stuff;

			double distleft=barrellength;;
			double distright=barrellength;;
			double disttop=barrellength;
			double distbottom=barrellength;

			//left
			setxyz(posbak+posadj);
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distleft=(muzpuf.pos-(posgunorigin+posadj)).length();
			}
			//right
			setxyz(posbak-posadj);
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distright=(muzpuf.pos-(posgunorigin-posadj)).length();
			}
			setxyz(posbak);

			//top
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				disttop=(muzpuf.pos-posgunorigin).length();
			}
			//bottom
			attackzoffset-=barreldepth;
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ
			);
			if(muzpuf){
				distbottom=(muzpuf.pos-(posgunorigin-(0,0,barreldepth))).length();
			}
			attackzoffset+=barreldepth;

			//set angles
			//FIGURE OUT WHICH WAY GOES WHICH
	
			bool mvng;if(vel.length()<0.5)mvng=true;
			if(distleft<distright){
				anglechange=max(distleft-barrellength,mvng?-abs(anglechange):-3);
			}else if(distleft>distright){
				anglechange=min(barrellength-distright,mvng?abs(anglechange):3);
			}
			else if(distleft<barrellength){
				A_ChangeVelocity(-1,0,0,CVF_RELATIVE);
			}

			if(disttop<distbottom){
				muzzledrift.y+=min(barrellength-disttop,mvng?abs(pitchchange):3);
			}else if(disttop>distbottom){
				muzzledrift.y-=max(distbottom-barrellength,mvng?abs(pitchchange):-3);
			}

			//reset attackzoffset and position
			setxyz(posbak);
			attackzoffset=azobak;
		}



//if(anglechange)A_LogFloat(anglechange);



		//set everything and update old
		A_SetAngle(lastangle+anglechange,SPF_INTERPOLATE);
		A_SetPitch(lastpitch+pitchchange,SPF_FORCECLAMP|SPF_INTERPOLATE);


		//feet angle
		double fac=hdmath.anglechange(angle,feetangle);
		if(pos.z==zat && abs(fac)>50-(height<40?20:0)){
			vel+=rotatevector((0,fac/abs(fac)*0.1),angle);
			A_GiveInventory("IsMoving",2);
			feetangle+=clamp(angle-feetangle,-10,10);
			if(
				instatesequence(curstate,resolvestate("spawn"))
			)setstatelabel("see");

			int chancetodouse=63;
			//if on appropriate terrain, easier to quench a fire
			if(CheckLiquidTexture())chancetodouse*=0.4;
			if(height<40 && floorz==pos.z && !random(0,chancetodouse)){
				if(A_CheckProximity("null","HDFire",20,1,CPXF_SETTRACER)){
					tracer.A_SpawnItemEx("HDSmoke",
						random(-3,3),random(-3,3),random(3,7),
						vel.x,vel.y,vel.z,
						flags:SXF_NOCHECKPOSITION|SXF_ABSOLUTEMOMENTUM
					);
					tracer.destroy();
				}
			}
		}

		//move pivot point a little behind the player's view
		anglechange=HDMath.AngleChange(lastangle,angle);
		if(zat-pos.z==0){
			if(abs(anglechange)>1){    
				int dir=90;
				if(anglechange<0) dir=-90;
				trymove(self.pos.xy+(cos(angle+dir)*0.8,sin(angle+dir)*0.8),false);
			}
			if(abs(pitchchange)>1 && -30<pitch<30){    
				double rate=0.1;
				trymove(self.pos.xy-(cos(angle)*rate*pitchchange,
				sin(angle)*rate*pitchchange),false);
			}
		}
	}




	//seeing if you're standing on a liquid texture
	static const String lq[]={
		"MFLR8_4","MFLR8_2",
		"SFLR6_1","SFLR6_4",
		"SFLR7_1","SFLR7_4",
		"FWATER1","FWATER2","FWATER3","FWATER4",
		"BLOOD1","BLOOD2","BLOOD3",
		"SLIME1","SLIME2","SLIME3","SLIME4",
		"SLIME5","SLIME6","SLIME7","SLIME8"
	};
	bool standingonliquid;
	bool CheckLiquidTexture(){
		int lqlength=lq.size();
		for (int i=0; i<lqlength; i++){
			TextureID tx = TexMan.CheckForTexture(lq[i], TexMan.Type_Flat);
			if (tx && floorpic == tx){
				return true;
			}
		}
		return false;
	}

	//Muzzle climb!
	void MuzzleClimb(
		double down,
		double left,
		bool doublemoving=true
	){
		if(doublemoving && countinv("ismoving")){down*=2;left*=2;}
		muzzledrift+=(left,down);
	}
}


class MuzzleBlockerPuff:IdleDummy{
	default{
		+puffonactors
	}
}
class MuzzleBlockerMissile:IdleDummy{
	default{
		projectile;
		decal "none";
	}
}

