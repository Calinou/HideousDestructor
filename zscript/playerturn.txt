// ------------------------------------------------------------
// Stuff related to player turning
// ------------------------------------------------------------
extend class HDPlayerPawn{
	vector2 muzzleclimb1;
	vector2 muzzleclimb2;
	vector2 muzzleclimb3;
	vector2 muzzleclimb4;
	vector2 muzzledrift;
	bool muzzlehit;
	bool totallyblocked;

	void TurnCheck(){
		//get input based on previous angle
		//do NOT use input because that breaks recoil
		double yaw=deltaangle(lastangle,angle);
		double ptch=deltaangle(lastpitch,pitch);

		//reduced turning while supported.
		if(
			player.cmd.buttons&BT_USE&&
			gunbraced&&
			!countinv("IsMoving")
		){
			yaw-=iyaw*0.9;ptch+=ipitch*0.9;
		}
		//reduced turning while crouched.
		else if(height<40 && abs(yaw)>5){
			yaw-=iyaw*0.4;ptch-=ipitch*0.4;
		}


		//temporary variables
		double anglechange=yaw;
		double pitchchange=ptch;


		//get weapon size
		double amt=0;
		int barrellength=0;
		double barrelwidth=0;
		int barreldepth=0;
		let wp=HDWeapon(player.readyweapon);
		if(wp && wp.gunmass>0){
			amt=wp.gunmass;
			barrellength=wp.barrellength;
			barrelwidth=wp.barrelwidth;
			barreldepth=wp.barreldepth;
		}else if(wp is "Lumberjack"){
			amt=5+
				(countinv("LumberCell")||countinv("LumberEmptyCell")?1:0)
			;
			barrellength=26;
			barrelwidth=1.;
			barreldepth=2;
		}else if(wp is "HDSMG"){
			amt=5+
				(wp.weaponstatus[SMGS_MAG]<0)?-0.5:(wp.weaponstatus[SMGS_MAG]*0.02)
			;
			barrellength=26;
			barrelwidth=0.5;
			barreldepth=1;
		}else if(wp is "Hunter"){
			int tube=wp.weaponstatus[HUNTS_TUBE];
			if(tube>4)tube+=(tube-4)*2;
			amt=8+
				tube*0.3+
				wp.weaponstatus[HUNTS_SIDESADDLE]*0.08
			;
			barrellength=30;
			barrelwidth=0.5;
			barreldepth=2;
		}else if(wp is "Slayer"){
			amt=6+wp.weaponstatus[SLAYS_SIDESADDLE]*0.06;
			barrellength=26;
			barrelwidth=1;
			barreldepth=1;
		}else if(wp is "ZM66AssaultRifle"){
			if(wp.weaponstatus[0]&ZM66F_NOLAUNCHER){
				amt=6.5+wp.weaponstatus[ZM66S_MAG]*0.02;
				barrellength=25;
				barrelwidth=0.5;
				barreldepth=1;
			}else{
				amt=8+wp.weaponstatus[ZM66S_MAG]*0.01
					+(wp.weaponstatus[0]&ZM66F_GRENADELOADED?1.:0.);
				barrellength=28;
				barrelwidth=1;
				barreldepth=3;
			}
		}else if(wp is "Vulcanette"){
			amt=14+wp.weaponstatus[1]<0?0:1;
			vulcanette vvv=vulcanette(wp);
			for(int i=0;i<5;i++){
				if(vvv.vulcmag[i]>=0)amt+=3.3;
			}
			barrellength=30;
			barrelwidth=3;
			barreldepth=4;
		}else if(wp is "HDRL"){
			amt=10+
				wp.weaponstatus[RLS_MAG]+
				wp.weaponstatus[RLS_CHAMBER]
			;
			barrellength=32;
			barrelwidth=2.5;
			barreldepth=5;
		}else if(wp is "Blooper"){
			amt=wp.weaponstatus[0]&BLOPF_LOADED?5:4;
			barrellength=24;
			barrelwidth=1.6;
			barreldepth=3;
		}else if(wp is "LiberatorRifle"){
			if(wp.weaponstatus[0]&LIBF_NOLAUNCHER){
				amt=9+wp.weaponstatus[LIBS_MAG]*0.02;
				barrellength=27;
				barrelwidth=0.5;
				barreldepth=2;
			}else{
				amt=10+wp.weaponstatus[LIBS_MAG]*0.02
					+(wp.weaponstatus[0]&LIBF_GRENADELOADED?1.:0.);
				barrellength=29;
				barrelwidth=1;
				barreldepth=3;
			}
		}else if(wp is "ThunderBuster"){
			amt=10+(wp.weaponstatus[TBS_BATTERY]<0?0:2);
			barrellength=28;
			barrelwidth=1.6;
			barreldepth=3;
		}else if(wp is "Brontornis"){
			amt=wp.weaponstatus[BRONS_CHAMBER];
			amt=amt*amt+6;
			barrellength=24;
			barrelwidth=1;
			barreldepth=2;
		}else if(wp is "BFG9k"){
			amt=15
				+(wp.weaponstatus[BFGS_BATTERY]>=0?1:0)
				+(wp.weaponstatus[0]&BFGF_STRAPPED?0:4)
			;
			barrellength=32;
			barrelwidth=3.5;
			barreldepth=7;
		}else if(wp is "BossRifle"){
			amt=12;
			barrellength=40;
			barrelwidth=1;
			barreldepth=2;
		}else if(wp is "NullWeapon"){
			barrellength=40;
			barrelwidth=4;
			barreldepth=7;
		}

		//inertia adjustments for other things
		if(stunned){
			amt=max(17,amt);
		}else if(hd_noturninertia==1){
			amt=0;
		}else if(countinv("PowerStrength")||countinv("PowerInvulnerable")){
			amt*=0.2;
		}
		if(countinv("WeaponBusy")){
			barrellength=radius+2;
			barrelwidth=2;
			amt=min(amt*1.5,20);
		}


		//muzzle inertia
		//how much to scale movement
		double proportion=1-min(0.042*amt,0.99);
		double proportion2=0.05*amt;
		double proportion3=1-proportion*0.7;

		//take the proportion and use that OR crouch+support, whichever is LESS
		if(hd_noturninertia==2)proportion2*=0.1;else{
				double yawcap=abs(yaw*proportion);
				double ptchcap=abs(ptch*proportion);
				anglechange=clamp(anglechange,-yawcap,yawcap);
				pitchchange=clamp(pitchchange,-ptchcap,ptchcap);
		}

		//see if there's any change in velocity overall
		vector3 muzzlevel=lastvel-vel;

		//apply crouch/jump
		double curheight=height;
		muzzlevel.z-=(lastheight-curheight)*0.3;
		lastheight=curheight;

		//determine velocity-based horizontal drift
		//how to tell if it is to left or right?
		//rotate vector so that player is facing east
		//the y value is what we need
		muzzlevel.xy=rotatevector(muzzlevel.xy,-angle);

		muzzledrift+=(muzzlevel.y,muzzlevel.z)*proportion2;


		//NOW apply the drift!
		muzzledrift+=(anglechange,pitchchange);
		anglechange+=muzzledrift.x*proportion2;
		pitchchange+=muzzledrift.y*proportion2;
		muzzledrift*=proportion3;


		//good old jitters!
		//gotta do this after inertia and before collision,
		//to keep this from clipping your gun into the geometry.
		if(
			beatmax<10||
			fatigue>20||
			bloodpressure>20||  
			health<33
		){
			double jitter=0.3;
			if(fatigue)jitter=clamp(0.01*fatigue,0.3,6.);
			if(gunbraced)jitter=0.05;
			else if(health<20)jitter=1;
			anglechange+=frandom(-jitter,jitter);
			pitchchange+=frandom(-jitter,jitter);
		}


		//muzzle climb - gotta keep this here to make it subject to caps
		pitchchange+=muzzleclimb1.y;
		anglechange+=muzzleclimb1.x;
		muzzleclimb1=muzzleclimb2;
		muzzleclimb2=muzzleclimb3;
		muzzleclimb3=muzzleclimb4;
		muzzleclimb4=(0,0);


		//weapon collision
		if(!(player.cheats&CF_NOCLIP2 || player.cheats&CF_NOCLIP)){
			double highheight=height-6;
			double midheight=highheight-barreldepth*0.5;
			double lowheight=highheight-max(1,barreldepth);

			//and now uh do stuff
			vector3 barrelbase=pos+(0,0,midheight);
			actor muzpuf;
			int stuff;
			int muzhit=0;

			double distleft=barrellength;;
			double distright=barrellength;;
			double disttop=barrellength;
			double distbottom=barrellength;

			//left
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:midheight,offsetside:-barrelwidth
			);
			if(muzpuf){
				if(!muzpuf.tracer||!muzpuf.tracer.bcorpse)
				distleft=(levellocals.vec3diff(muzpuf.pos,barrelbase).length());
				muzpuf.destroy();
			}else muzhit++;
			//right
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:midheight,offsetside:+barrelwidth
			);
			if(muzpuf){
				if(!muzpuf.tracer||!muzpuf.tracer.bcorpse)
				distright=(levellocals.vec3diff(muzpuf.pos,barrelbase).length());
				muzpuf.destroy();
			}else muzhit++;

			//top
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:highheight,offsetside:0
			);
			if(muzpuf){
				if(!muzpuf.tracer||!muzpuf.tracer.bcorpse)
				disttop=(levellocals.vec3diff(muzpuf.pos,barrelbase).length());
				muzpuf.destroy();
			}else muzhit++;
			//bottom
			[muzpuf,stuff]=LineAttack(lastangle+anglechange,barrellength,
				lastpitch+pitchchange,0,"none",
				"MuzzleBlockerPuff",flags:LAF_NORANDOMPUFFZ|LAF_OVERRIDEZ,
				offsetz:lowheight,offsetside:0
			);
			if(muzpuf){
				if(!muzpuf.tracer||!muzpuf.tracer.bcorpse)
				distbottom=(levellocals.vec3diff(muzpuf.pos,barrelbase).length());
				muzpuf.destroy();
			}else muzhit++;


			//totally caught
			if(!muzhit)totallyblocked=true;
			else totallyblocked=false;


			//set angles
			bool mvng;if(lastheight!=height || vel.length()<0.5)mvng=true;
			bool hitsnd;
			if(max(abs(anglechange),abs(pitchchange))>1)hitsnd=true;  

//A_Log(string.format("%i %i %i %i",distleft,distright,disttop,distbottom));

			if(!(wp is "NullWeapon")){
				if(distleft<barrellength){
					anglechange=max(distleft-barrellength,mvng?0:-4);
				}
				if(distright<barrellength){
					anglechange=min(barrellength-distright,mvng?0:4);
				}
	
				if(disttop<barrellength){
					pitchchange=max(distbottom-barrellength,mvng?0:-4);
				}
				if(distbottom<barrellength){
					pitchchange=min(barrellength-disttop,mvng?0:4);
				}
				pitchchange=clamp(pitchchange,-45,45);

				if(totallyblocked){
					vector2 cv=angletovector(pitch,
						clamp(barrellength-disttop,0,barrellength)*0.01);
					A_ChangeVelocity(-cv.x,0,cv.y,CVF_RELATIVE);
				}
			}



			//bump
			if(muzhit>=4){  
				muzzlehit=false;
			}else if(!muzzlehit){
				if(hitsnd)A_PlaySound("weapons/rifleclick2",CHAN_AUTO,0.6);
				muzzlehit=true;
			}
		}

//if(abs(anglechange)>45)A_Log(string.format("angle %i",anglechange));
//if(abs(pitchchange)>45)A_Log(string.format("pitch %i",pitchchange));

//if(anglechange)A_Log(string.format("angle %i",anglechange));


		//set everything and update old
		A_SetAngle(lastangle+anglechange,SPF_INTERPOLATE);
		A_SetPitch(
			clamp(lastpitch+pitchchange,player.minpitch,player.maxpitch),
			SPF_INTERPOLATE
		);


		//feet angle
		double fac=deltaangle(feetangle,angle);
		if(abs(fac)>(player.crouchfactor<0.7?30:50)){
			vel+=rotatevector((0,fac>0?0.1:-0.1),angle);  
			A_GiveInventory("IsMoving",2);
			feetangle=angle;
			PlayRunning();

			//if on appropriate terrain, easier to quench a fire
			if(player.crouchfactor<0.7){
				int douse=2;
				//the below is equivalent to "if(CheckLiquidTexture())douse=5;"
				//replicated because of the virtual subfunction processing problem
				int lqlength=lq.size();
				for(int i=0;i<lqlength;i++){
					TextureID tx=TexMan.CheckForTexture(lq[i],TexMan.Type_Flat);
					if (tx && floorpic==tx)douse=5;
				}
				A_GiveInventory("HDFireDouse",douse);
			}
		}

		//move pivot point a little behind the player's view
		anglechange=deltaangle(angle,lastangle);
		if(player.onground && zat-pos.z==0){
			if(abs(anglechange)>1){      
				int dir=90;
				if(anglechange<0) dir=-90;
				trymove(self.pos.xy-(cos(angle+dir),sin(angle+dir))*0.8,false);
			}
			int ptchch=clamp(abs(pitchchange),0,10); //THE CLAMP IS A BANDAID
			if(ptchch>1 && -30<pitch<30){  
				trymove(pos.xy-(cos(angle)*ptchch,sin(angle)*ptchch)*0.1,false);
				PlayRunning();
			}
		}
	}



	//seeing if you're standing on a liquid texture
	static const string lq[]={
		"MFLR8_4","MFLR8_2",
		"SFLR6_1","SFLR6_4",
		"SFLR7_1","SFLR7_4",
		"FWATER1","FWATER2","FWATER3","FWATER4",
		"BLOOD1","BLOOD2","BLOOD3",
		"SLIME1","SLIME2","SLIME3","SLIME4",
		"SLIME5","SLIME6","SLIME7","SLIME8"
	};
	bool CheckLiquidTexture(){
		int lqlength=lq.size();
		let fp=floorpic;
		for(int i=0;i<lqlength;i++){
			TextureID tx=TexMan.CheckForTexture(lq[i],TexMan.Type_Flat);
			if (tx&&fp==tx){
				return true;
			}
		}
		return false;
	}

	//Muzzle climb!
	void A_MuzzleClimb(vector2 mc1,vector2 mc2,vector2 mc3,vector2 mc4){
		double mult=1.;
		if(gunbraced)mult=0.2;
		else if(countinv("IsMoving"))mult=1.6;
		if(stunned)mult*=1.6;
		if(mult){
			mc1*=mult;
			mc2*=mult;
			mc3*=mult;
			mc4*=mult;
		}
		muzzleclimb1+=mc1;
		muzzleclimb2+=mc2;
		muzzleclimb3+=mc3;
		muzzleclimb4+=mc4;
	}
}

class MuzzleBlockerPuff:IdleDummy{
	default{
		+nodecal +puffonactors +notrigger +bloodlessimpact +hittracer
	}
}

