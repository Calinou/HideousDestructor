// ------------------------------------------------------------
// HD's modified FastProjectile
// Because "fast" means something else entirely
// For reference, the rocket can go up to just under 400
// ------------------------------------------------------------

class SlowProjectile:HDBullet{
	/*
		special usages:
		accuracy: amount, in DUs, that the nose extends beyond the base radius.
	*/
	default{
		+bloodlessimpact -noteleport +forcexybillboard
//		missiletype "BulletTail"; //testing and random eye candy

		radius 1.;height 1.;
		missileheight 8; projectilekickback 20; damagetype "SmallArms0";
		speed 18;
	}
	override void PostBeginPlay(){
		HDActor.PostBeginPlay();
		grav=getgravity();
		LongArmWobble();
		Gunsmoke();
		if(target){
			master=target;
			throughthis=target;
		}
		accuracy+=radius;
	}
	override void Tick(){
		if(globalfreeze||level.Frozen) return;
		if(!bmissile){
			//nexttic
			if(CheckNoDelay()){
				if(tics>0)tics--;  
				while(!tics){
					if(!SetState(CurState.NextState)){
						return;
					}
				}
			}
			return;
		}

		//point actor in velocity
		//set some basic variables
		speed=vel.length();
		speedsquared=vel dot vel;
		penetration=speedsquared*mass*accuracy*0.000000001/pushfactor*frandom(0.9,1.1);
		A_FaceMovementDirection();

		//hack to escape shooter
		bool bsbak=false;
		if(throughthis){
			bsbak=throughthis.bshootable;
			throughthis.bshootable=false;
		}

		//get the lines
		flinetracedata blttop;
		flinetracedata bltbottom;
		flinetracedata bltleft;
		flinetracedata bltright;
		actor hitactor=null;
		line hitline=null;
		LineTrace(
			angle,speed,pitch,flags:0,
			offsetz:radius,
			offsetforward:accuracy,
			data:blt
		);
		if(!hitline)hitline=blt.hitline;if(!hitactor)hitactor=blt.hitactor;
		LineTrace(
			angle,speed,pitch,flags:0,
			offsetz:height,
			data:blttop
		);
		if(!hitline)hitline=blttop.hitline;if(!hitactor)hitactor=blttop.hitactor;
		LineTrace(
			angle,speed,pitch,flags:0,
			data:bltbottom
		);
		if(!hitline)hitline=bltbottom.hitline;if(!hitactor)hitactor=bltbottom.hitactor;
		LineTrace(
			angle,speed,pitch,flags:0,
			offsetz:radius,
			offsetside:-radius,
			data:bltleft
		);
		if(!hitline)hitline=bltleft.hitline;if(!hitactor)hitactor=bltleft.hitactor;
		LineTrace(
			angle,speed,pitch,flags:0,
			offsetz:radius,
			offsetside:-radius,
			data:bltright
		);
		if(!hitline)hitline=bltright.hitline;if(!hitactor)hitactor=bltright.hitactor;

		//reset hacks (copypasted from bullet less plushitdir)
		if(throughthis){
			throughthis.bshootable=bsbak;
			throughthis=null;
		}

		//find points close to players and spawn crackers
		//also spawn trails if applicable
		//(copypasted from bullet)
		if(speed>256){
			name b="";
			if(speed>1000){
				if(mass>200) b="SupersonicTrailBig";
				else b="SupersonicTrail";
			}else if(speed>800){
				b="SupersonicTrail";
			}else if(speed>HDCONST_SPEEDOFSOUND){
				b="SupersonicTrailSmall";
			}else if(speed>100){
				b="SubsonicTrail";
			}
			if(b!=""){
				vector3 crackbak=pos;
				vector3 crackinterval=blt.hitdir*BULLET_CRACKINTERVAL;
				int j=max(1,blt.distance*(1./BULLET_CRACKINTERVAL));
				for(int i=0;i<j;i++){
					setxyz(crackbak+crackinterval*i);
					if(missilename)spawn(missilename,pos);
					bool gotplayer=false;
					for(int k=0;!gotplayer && k<MAXPLAYERS;k++){
						if(playeringame[k] && players[k].mo){
							if(
								distance3d(players[k].mo)<256
							){
								gotplayer=true;
								spawn(b,pos);
							}
						}
					}
				}
				setxyz(crackbak);
			}
		}

		//move to new location
		setorigin(bltbottom.hitlocation-bltbottom.hitdir*radius,true);

		//see if it hit right on the nose
		bool frontal=(
			blttop.hittype==TRACE_HitNone
			&&bltbottom.hittype==TRACE_HitNone
			&&bltleft.hittype==TRACE_HitNone
			&&bltright.hittype==TRACE_HitNone
		);


		//explode missile
		if(
			!frontal||
			(frontal&&blt.hittype!=TRACE_HitNone)
		){
			if(hitactor){
				int dmg=(vel dot vel)*max(mass,radius*radius)*0.000002;
				A_LogInt(dmg);
				hitactor.damagemobj(self,target,
					random(dmg,dmg*2),
					"Bashing"
				);
			}
			ExplodeSlowMissile(hitline,hitactor,frontal);
		}
		if(bdestroyed)return;


		//gravity, etc.
		vel.z-=grav;

		//nexttic
		if(CheckNoDelay()){
			if(tics>0)tics--;  
			while(!tics){
				if(!SetState(CurState.NextState)){
					return;
				}
			}
		}
	}
	virtual void ExplodeSlowMissile(line hitline=null,actor hitactor=null,bool frontal=true){
		actor aaa=hitactor;
		if(!hitactor){
			aaa=spawn("IdleDummy",pos);
			aaa.stamina=10;
		}else{
		}
		aaa.A_PlaySound(speed>50?"misc/punch":"misc/fragknock",CHAN_AUTO);

		explodemissile(null,null);
	}
	states{
	spawn:
		BAL1 A 1 nodelay;
		BAL1 A -1{
			//so that you can kill yourself by shooting into the sky
			if(target && !master) master=target;target=null;
		}
	death:
		BAL1 BCD 4;
		stop;
	}
}
class BulletTail:IdleDummy{
	default{
		scale 0.5; renderstyle "add"; alpha 0.3; +forcexybillboard;
	}
	states{
	spawn:
		BAL7 A 10 A_FadeOut(0.1);
		wait;
	}
}