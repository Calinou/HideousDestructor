// ------------------------------------------------------------
// Because sometimes, things get caught in map geometry.
// ------------------------------------------------------------
class doordestroyer:hdactor{
	default{
		+solid +nogravity +dontgib +ghost
		+actlikebridge
		height 0.1;radius 0.1;
	}
	vector2 v1pos;
	vector2 v2pos;
	vector2 vfrac;
	double llength;
	int llit;
	override void postbeginplay(){
		super.postbeginplay();
		vector2 vvv=(v2pos-v1pos);
		llit=max(1,llength/10); //see chunkspeed
		vfrac=vvv/llit;
	}
	void DoorChunk(class<actor>chunktype,int numpercolumn=1,double chunkspeed=10){
		chunkspeed*=0.1; //see vfrac
		for(int i=0;i<llit;i++){
			for(int j=0;j<numpercolumn;j++){
				actor aaa=spawn(chunktype,(
					(v1pos+vfrac*i),
					frandom(floorz,ceilingz)
				));
				aaa.vel.xy=rotatevector(
						vfrac,randompick(90,-90)+frandom(-60,60)
					)*chunkspeed*frandom(0.4,1.4);
				aaa.vel.z=frandom(-6,12);
			}
			spawn("HDSmoke",(
				(v1pos+vfrac*i),
				floorz+frandom(1,32)
			));
		}
	}
	states{
	spawn:
		TNT1 A 0;
		TNT1 A 0 DoorChunk("HDExplosion",3,3);
		TNT1 A 0 DoorChunk("HDSmoke",5,3);
		TNT1 AAA 1 DoorChunk("HugeWallChunk",20,15);
		TNT1 A 0 DoorChunk("HDSmoke",5,2);
		TNT1 A 0 DoorChunk("HDSmokeChunk",random(0,3),7);
		TNT1 AAAA 1 DoorChunk("HDSmoke",5,1);
		TNT1 A 0 DoorChunk("HDSmoke",5,1);
		TNT1 A 0 DoorChunk("HDSmokeChunk",random(0,3),7);
		TNT1 AAAA 2 DoorChunk("HugeWallChunk",20);
		TNT1 A -1;
		stop;
	}
	static const int doorspecials[]={
		//from LineSpecials[] in p_lnspec.cpp
		10,11,12,13,14, 85, 105,106, 202, 249, 274
	};
	static bool checkdoorspecial(int linespecial){
		int dlsl=doordestroyer.doorspecials.size();
		for(int i=0;i<dlsl;i++){
			if(linespecial==doordestroyer.doorspecials[i]){
				return true;
				break;
			}
		}
		return false;
	}
	static bool destroydoor(actor caller,double range=0){
		if(!range)range=caller.radius*2;
		flinetracedata dlt;
		caller.linetrace(
			caller.angle,range,0,
			flags:TRF_THRUACTORS,
			offsetz:caller.height*0.5,data:dlt
		);
		if(!dlt.hitline)return false;
		sector othersector=hdmath.oppositesector(dlt.hitline,dlt.hitsector);
		if(
			!othersector
			||othersector.ceilingplane.zatpoint(dlt.hitlocation.xy+dlt.hitdir.xy)>dlt.hitlocation.z
		)return false;

		//see how wide the door is
		vector2 doorline=dlt.hitline.v1.p-dlt.hitline.v2.p;
		double maxdoor=frandom(64,256);
		if(doorline dot doorline > maxdoor*maxdoor)return false;

		bool isdoor=false;

		//see how thick the door is
		//what is the proper way of doing this
		vector3 posbak=caller.pos;
		caller.setorigin(caller.pos+(
			(dlt.hitlocation.xy+dlt.hitdir.xy)*frandom(14,34),0
		),false);
		isdoor=(caller.cursector!=othersector);
		caller.setorigin(posbak,false);
		if(!isdoor)return false;

		//see if a door special applies
		isdoor=checkdoorspecial(dlt.hitline.special);

		//see if door special applies for all other lines tagging this sector
		if(!isdoor){
			//HOW THE FUCK DO YOU FIND A SECTOR TAG
			int brutalforcery=0;
			bool gotit=false;
			for(brutalforcery=0;brutalforcery<100;brutalforcery++){
				sectortagiterator sss=
					sectortagiterator.create(brutalforcery);
				int ssss=sss.next();
				while(!gotit&&ssss>-1){
					if(level.sectors[ssss]==othersector)gotit=true;
					ssss=sss.next();
				}
				if(gotit)break;
			}

			if(brutalforcery>0){
				lineiditerator lll=lineiditerator.create(brutalforcery);
				int l=lll.next();
				while(!isdoor&&l>-1){
					isdoor=checkdoorspecial(level.lines[l].special);
					l=lll.next();
				}
			}
		}

		if(!isdoor)return false;

		//not intended by the mapper
		textureid shwal=texman.checkfortexture("ASHWALL2",texman.type_any);
		if(int(shwal)<1)
			shwal=texman.checkfortexture("ASHWALL",texman.type_any);
		othersector.settexture(sector.ceiling,shwal,true);
		for(int i=0;i<othersector.lines.size();i++){
			othersector.lines[i].flags|=line.ML_DONTPEGTOP;
			for(int j=0;j<2;j++){
				side sdd=othersector.lines[i].sidedef[j];
				if(
					sdd
					&&int(sdd.gettexture(side.top))<1
				){
					sdd.settexture(side.top,shwal);
				}
			}
		}

		//blow that shit up
		othersector.flags|=sector.SECF_SILENTMOVE;
		double blockpoint=
			dlt.hitsector.ceilingplane.zatpoint(dlt.hitlocation.xy);
		othersector.MoveCeiling(100,blockpoint+frandom(-12,12),0,1,false);

		let db=doordestroyer(spawn("doordestroyer",(
			(dlt.hitlocation.xy+dlt.hitdir.xy*2),blockpoint
		)));
		db.setz(blockpoint);
		db.v1pos=dlt.hitline.v1.p;
		db.v2pos=dlt.hitline.v2.p;
		db.target=caller.target;

		double doorwidth=doorline.length();
		db.llength=doorwidth;
		hdactor.HDBlast(caller,
			pushradius:doorwidth,pushamount:24,
			fragradius:doorwidth,fragdamage:doorwidth,
			immolateradius:doorwidth,
			immolateamount:random(10,30),
			immolatechance:12,
			gibradius:doorwidth*0.4,gibamount:10
		);
		return true;
	}
}
class doorball:doomimpball{
	states{
	death:
		BAL1 C 0{if(doordestroyer.destroydoor(self))A_Log("Ding dong, motherfucker!");}
		goto super::death;
	}
}
