//-------------------------------------------------
// Environment/Radiation Suit
//-------------------------------------------------
class WornRadsuit:InventoryFlag{
	override void attachtoowner(actor owner){	
		if(!owner.countinv("PortableRadsuit"))owner.A_GiveInventory("PortableRadsuit");
		super.attachtoowner(owner);
	}
	override void DetachFromOwner(){
		owner.A_TakeInventory("PortableRadsuit",1);
		owner.A_PlaySound("weapons/pocket",CHAN_AUTO);
		let onr=HDPlayerPawn(self);
		if(onr)onr.stunned+=60;
		super.DetachFromOwner();
	}
	override void DoEffect(){
		if(stamina>0)stamina--;
	}
}
class PortableRadsuit:HDPickup replaces RadSuit{
	default{
		inventory.maxamount 2;
		inventory.interhubamount 2;
		inventory.pickupmessage "Environmental shielding suit.";
		inventory.pickupsound "weapons/pocket";
		inventory.icon "SUITB0";
		accuracy 1;
	}
	override void DetachFromOwner(){
		owner.A_TakeInventory("WornRadsuit");
		target=owner;
		super.DetachFromOwner();
	}
	override void actualpickup(actor user){
		HDF.TransferFire(self,user);
		super.actualpickup(user);
	}
	states{
	spawn2:
		SUIT A 1;
		SUIT A -1{
			if(!target)return;
			HDF.TransferFire(target,self);
		}
	use:
		TNT1 A 0{
			A_SetBlend("00 00 00",1,6,"00 00 00");
			A_PlaySound("weapons/pocket");
			A_ChangeVelocity(0,0,2);
			let onr=HDPlayerPawn(self);
			if(onr)onr.stunned+=60;
			if(!countinv("WornRadsuit")){
				int fff=HDF.TransferFire(self,self);
				if(fff){
					if(random(1,fff)>30){
						A_PlaySound("misc/fwoosh",CHAN_AUTO);
						A_TakeInventory("PortableRadsuit",1);
						return;
					}else{
						HDF.TransferFire(self,null);
						if(onr){
							onr.fatigue+=fff;
							onr.stunned+=fff;
						}
					}
				}
				A_GiveInventory("WornRadsuit");
			}else{
				actor a;int b;
				inventory wrs=findinventory("wornradsuit");
				[b,a]=A_SpawnItemEx("PortableRadsuit",0,0,height/2,2,0,4);
				if(a && wrs.stamina){
					let aa=HDActor(a);
					if(aa)aa.A_Immolate(a,self,wrs.stamina);
				}
				A_TakeInventory("WornRadsuit");
			}
		}fail;
	}
}




//-------------------------------------------------
// Light Amplification Visor
//-------------------------------------------------
class PortableLiteAmp:HDPickup replaces Infrared{
	default{
		inventory.maxamount 1;
		inventory.interhubamount 1;
		inventory.pickupmessage "Light amplification visor.";
		inventory.icon "PPVIA0";
		scale 0.5;
		accuracy 1;
	}
	int spent;bool worn;
	const LITEBAT=84000;
	override void DetachFromOwner(){
		if(owner && owner.player && owner.player.fixedcolormap==5)owner.player.fixedcolormap=-1;
		worn=false;
		owner.player.fixedlightlevel=-1;
		super.DetachFromOwner();
	}
	override void DoEffect(){
		super.DoEffect();
		if(owner && owner.player){
			if(
				worn
				&&!owner.countinv("PowerInvisibility")
				&&(owner.player.fixedcolormap<0||owner.player.fixedcolormap==5)
			){
				owner.player.fov=min(owner.player.fov,90);
				owner.player.fixedcolormap=5;
				owner.player.fixedlightlevel=1;
				if(!random[rand1](0,LITEBAT-spent)){
					owner.player.fixedcolormap=-1;
					owner.player.fixedlightlevel=-1;
				}
				spent++;
				if(spent>LITEBAT)worn=false;
			}else{
				if(owner.player.fixedcolormap==5)owner.player.fixedcolormap=-1;
				owner.player.fixedlightlevel=-1;
			}
		}
	}
	states{
	spawn2:
		PVIS B -1;
	use:
		TNT1 A 0{
			A_SetBlend("01 00 00",0.8,16);
			if(invoker.spent>=LITEBAT){
				if(countinv("HDCellPacks")){
					A_TakeInventory("HDCellPacks",1,TIF_NOTAKEINFINITE);
					invoker.spent=0;
				}else if(countinv("HDCellAmmo")){
					int rnd=min(random(1,19),countinv("HDCellAmmo"));
					A_TakeInventory("HDCellAmmo",rnd,TIF_NOTAKEINFINITE);
					invoker.spent-=rnd*LITEBAT/20;
				}else A_Log("No power for lite-amp.",true);
			}
			if(invoker.spent<LITEBAT){
				if(invoker.worn)invoker.worn=false;else invoker.worn=true;
			}
		}fail;
	}
}









//-------------------------------------------------
// Ladder
//-------------------------------------------------

//show where the ladder is hanging
//no it doesn't swing, math is hard :(
class hdladdersection:idledummy{
	default{
		+wallsprite
	}
	double proportion;
	override void postbeginplay(){
		super.postbeginplay();
		//master is top, target is bottom
		if(!master||!target){
			destroy();return;
		}
		proportion=target.pos.z-master.pos.z;
		if(!proportion){
			destroy();return;
		}
		proportion=abs(master.pos.z-pos.z)/proportion;
	}
	override void tick(){
		if(!master||!target){
			destroy();return;
		}
		double mpz=master.pos.z;
		setz(mpz+(mpz-target.pos.z)*proportion);
		nexttic();
	}
	states{
	spawn:
		ROCK A -1;
	}
}
class hdladdertop:hdactor{
	default{
		+missile //testing
		+flatsprite
		height 1;radius 2;
	}
	override void postbeginplay(){
		super.postbeginplay();
		pitch=-14;
		bmissile=false;master=target;
		setz(floorz);
		fcheckposition tm;
		vector2 mvlast=pos.xy;
		vector2 mv=angletovector(angle,2);
		for(int i=0;i<10;i++){
			mvlast+=mv;
			checkmove(mvlast,PCM_DROPOFF|PCM_NOACTORS,tm);

			//found a place for the ladder to hang down
			int htdiff=clamp(floorz-tm.floorz,0,LADDER_MAX);
			if(htdiff){
				A_PlaySound("misc/ladder");

				//spawn the ladder end
				target=spawn("hdladderbottom",tm.pos);
				target.target=self;
				target.master=master;

				//spawn the ladder sections
				int sectionlength=min(htdiff,LADDER_MAX)/LADDER_SECTIONS;
				for(int i=0;i<LADDER_SECTIONS;i++){
					tm.pos.z-=sectionlength;
					actor sss=spawn("hdladdersection",tm.pos);
					sss.master=self;sss.target=target;sss.angle=angle;
				}

				//now that we're at the bottom, move the ladder end
				target.setz(tm.pos.z);

				return;
			}
		}

		//if there's no lower floor to drop the ladder, abort.
		if(master){
			master.A_Log("No point hanging a ladder here.",true);
			master.A_GiveInventory("HDLadder");
		}else{
			actor hdl=spawn("HDLadder",pos);
			hdl.A_PlaySound("misc/ladder");
		}
		destroy();
	}
	override void tick(){
		setz(floorz+2);
		nexttic();
	}
	states{
	spawn:
		BAL2 A -1;
	}
}
enum ladderfigures{
	LADDER_MAX=800,
	LADDER_SECTIONS=LADDER_MAX/20,
}
class hdladderbottom:hdactor{
	default{
		+nogravity
		height 60.1;radius 10.1;
	}
	actor currentuser;
	double currentuserz;
	override bool used(actor user){
		if(currentuser){
			disengageladder();
			return false;
		}
		currentuser=user;
		currentuser.vel.z+=1;
		currentuserz=user.pos.z;
		currentuser.A_Log("You climb the ladder.",true);
		return true;
	}
	void disengageladder(){
		if(!currentuser)return;
		currentuser.A_Log("Ladder disengaged.",true);
		currentuser=null;
	}
	override void tick(){
		if(!target){destroy();return;}
		setz(clamp(target.pos.z-LADDER_MAX,getzat(),target.pos.z+LADDER_MAX));

		if(currentuser){
			if(currentuser.health<1){currentuser=null;return;}
			if(
				currentuser.pos.z>target.pos.z-16
			){

				if(currentuser.player){
					int bt=currentuser.player.cmd.buttons;
					if(
						bt&BT_JUMP
						||bt&BT_SPEED
					){
						disengageladder();
						if(bt&BT_CROUCH&&bt&BT_JUMP){
							actor hdl=spawn("HDLadder",target.pos);
							hdl.A_PlaySound("misc/ladder");
							target.destroy();
							if(self)destroy();
						}
						return;
					}
				}
				if(target.distance2d(currentuser)>40){
					vector2 tp=target.pos.xy;
					currentuser.setorigin((
						clamp(currentuser.pos.x,
							tp.x-40,
							tp.x+40
						),
						clamp(currentuser.pos.y,
							tp.y-40,
							tp.y+40
						),
						currentuser.pos.z
					),true);
				}
				return;
			}
			currentuser.vel.z=0;

			bool facing=
				abs(
					deltaangle(
						angleto(currentuser,true),
						currentuser.angle
					)
				)>100;

			if(currentuser.player){
				int fm=currentuser.player.cmd.forwardmove/8000;
				int sm=currentuser.player.cmd.sidemove/8000;
				int bt=currentuser.player.cmd.buttons;

				//barehanded and descending are faster
				if(facing){
					if(!sm&&fm<0)fm*=1.5;
					weapon wp=currentuser.player.readyweapon;
					if(wp is "Ring"||wp is "NullWeapon"){
						sm*=2;fm*=2;
					}
				}else fm*=-1;

				//apply climbing
				currentuserz+=fm;

				//jump also disengages
				//crouch+jump to remove the rope
				if(bt){
					if(bt&BT_JUMP){
						if(bt&BT_CROUCH){
							currentuser.A_Log("Ladder taken down.",true);

							actor hdl=spawn("HDLadder",target.pos);
							hdl.A_PlaySound("misc/ladder");
		
							vector2 vc=(currentuser.pos.xy-pos.xy).unit();
							currentuser.vel.xy+=vc*7;
							hdl.vel.xy+=vc*4;

							target.destroy();
							if(self)destroy();
							return;
						}else disengageladder();
					}
				}

				//should be able to move around a bit
				if(sm)currentuser.trymove(
					currentuser.pos.xy+angletovector(currentuser.angle-90,sm),
					true
				);
			}
			if(!currentuser)return;

			currentuser.vel*=0.7;
			currentuserz=clamp(currentuserz,
				currentuser.floorz,
				currentuser.ceilingz-currentuser.height
			);
			currentuser.setorigin((
				clamp(currentuser.pos.x,
					pos.x-16,
					pos.x+16
				),
				clamp(currentuser.pos.y,
					pos.y-16,
					pos.y+16
				),
				currentuserz
			),true);
		}
		nexttic();
	}
	states{
	spawn:
		BAL1 A -1;wait;
	}
}
class HDLadder:HDPickup{
	default{
		inventory.icon "PLAYA1";
		inventory.pickupmessage "Picked up a ladder.";
		height 24;radius 16;
	}
	states{
	spawn:
		BAL7 B -1;
	use:
		TNT1 A 0{
			actor aaa;int bbb;
			[bbb,aaa]=A_SpawnItemEx(
				"HDLadderTop",14,0,32,
				flags:SXF_NOCHECKPOSITION|SXF_SETTARGET
			);if(!aaa)return;

			//only face player if above player's height - otherwise why not just mantle?
			if(aaa.floorz>pos.z+height){
				aaa.angle+=180;
			}
		}stop;
	}
}



